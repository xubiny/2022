# 파이썬 프로그래밍 기초
- 파이썬은 우리에게 친숙한 워드 프로세서, 이메일 프로그램, 웹 브라우저 등 다른 애플리케이션과 마찬가지로 일련의 프로그램으로 구성되어 있다. 모든 프로그램이 그러하듯 파이썬도 컴퓨터에 제대로 설치되어 있어야 한다. 파이썬은 기본 운영 체제에 포함되어 있는 경우도 많으며, 내려받기도 쉽다. 그리고 텍스트편집기와 터미널 애플리케이션이 필요하다.

<br/><br/><br/><br/>

## 파이썬 프로그램 개발 과정
### 1. 프로그램 작성
- 프로그램을 입력해 `<프로그램명>.py` 형식의 이름으로 파일에 저장한다.
### 2. 프로그램 실행
- 터미널 창에서 `python3 <프로그램명>.py` 명령을 이용해 실행한다.

<br/><br/>

- 첫 번째 단계에서는 빈 화면에서 시작해 문자를 차례대로 입력해 하나의 프로그램을 작성하는데 이메일 메시지나 에세이를 쓰는 과정과 비슷하다. 다만 프로그래머는 입력한 프로그램을 코드라고 하며, 코드를 작성하는 과정은 코딩이라고 부른다.

<br/>

- 두 번째 단계에서는 컴퓨터의 제어권을 시스템에서 작성한 프로그램으로 넘겨준다(프로그램이 실행을 마치면 제어권이 다시 시스템으로 돌아간다). 프로그램을 작성하고 실행하는 방법은 시스템에 따라 더욱 세분화되기도 하고 다양하다.

<br/><br/>

### 프로그램 작성
- 문장이나 한 편의 시와 마찬가지로 파이썬 프로그램도 그저 일련의 문자열로 구성되어 있으며, 다만 .py 확장자를 가진 파일에 저장될 뿐이다. 이메일 클라이언트나 다른 컴퓨터 애플리케이션을 사용할 때와 마찬가지로 프로그램을 작성하는 일도 문자들의 시퀀스(Sequence)를 정의하면 된다. 프로그램을 작성할 때는 어떤 텍스트 편집기나 사용할 수 있지만, 파이참(PyCharm) 같은 통합 개발 환경에서 제공하는 편집기를 사용할 수도 있다.

<br/><br/>

### 프로그램 실행
- 일단 프로그램을 작성한 후에는 실행할 수 있다. 프로그램 실행은 상당히 흥미로운 부분으로서 우리가 작성한 프로그램이(파이썬이 허용하는 범위 안에서) 컴퓨터를 제어한다. 엄밀히 말하면 우리가 내린 명령을 컴퓨터가 따른다고 할 수 있는데, 기술적으로는 파이썬 컴파일러가 컴퓨터에서 실행하기 좋은 언어로 파이썬 프로그램을 번역한다고 설명하는 편이 더 정확하다. 

<br/>

- 그러고 나서 파이썬 인터프리터(interpreter, 해석기)는 우리가 지정한 명령을 컴퓨터가 따르도록 지시한다. 대게 프로그램을 컴파일하고 인터프리트(interpret, 해석) 하는 과정을 하나로 합쳐 실행이라는 용어로 부른다.
- 예를 들어 "파이썬이 이 프로그램을 실행할 때 ..."와 같이 설명한다. 
- 파이썬 컴파일러와 인터프리터를 사용해 프로그램을 실행하려면 터미널 창에서 python 명령 뒤에 파이썬 프로그램을 담고 있는 파일명을 입력한다.

<br/>

![image](https://user-images.githubusercontent.com/61584142/160219263-b078ff57-715a-4bdb-ad92-71871b9378a6.png)

<br/><br/><br/><br/>

**파이썬 프로그램은 문장(Statement)으로 구성된다.
- 일반적으로 한 행에 문장 하나를 놓는다.

<br/><br/>

<pre><code>import stdio

# 표준 출력 장치에 Hello, World 메시지를 출력한다.
stdio.writeln(‘Hello, World’)</code></pre>
- 이 코드는 간단한 작업을 수행하는 파이썬 프로그램이다. 프로그래밍 입문서는 전통적으로 Hello, World를 출력하는 프로그램을 처음으로 작성한다. 아래 글상자에서는 프로그램을 실행한 결과를 보여준다. 터미널 애플리케이션은 명령 줄 프롬프트(이 책에서는 %)를 출력하고 여러분이 입력한 명령(이 책에서는 볼드체로 표시한다)을 실행한다. 윈도 환경에서는 명령 줄 프롬프트에 홑화살괄호(>)를 출력한다. 이 코드를 python3 명령으로 실행하면 터미널 창에 Hello, World 메시지를 출력한다(코드 중 네 번째 줄).

<br/>

• helloworld.py의 첫 번째 줄에는 import 문이 들어 있다. 이 문장은 stdio.py라는 이름의 파일 안에 있는 stdio 모듈에 정의된 기능을 사용하겠다는 것을 파이썬에 알려준다. stdio.py 파일은 이 책 예제에서 사용하기 위해 만든 라이브러리 모듈 중 하나다. 메시지의 입력과 출력에 관련된 함수를 정의하는 stdio 모듈을 임포트하면 나중에 이 모듈 안에 정의된 함수를 호출할 수 있다. <br/><br/>

• 두 번째 줄은 비어 있다. 파이썬은 빈 행을 무시하지만, 프로그래머는 빈 행을 이용해 코드 블록을 논리적으로 구분한다. <br/><br/>

• 세 번째 줄은 주석인데, 프로그램을 문서화하는 용도로 사용된다. 파이썬 주석은 해시 문자(#)로 시작해 그 행이 끝날 때까지 계속된다. 이 책에서 주석은 회색으로 표시한다. 주석은 파이썬이 무시하며, 단지 사람이 읽기 위한 것이다. <br/><br/>

• 네 번째 줄이 이 프로그램의 핵심이다. 이 문장에서는 stdio.writeln() 함수를 호출해, 전달받은 문자열을 출력한다. 다른 모듈에서 함수를 호출할 때는 모듈명, 점(.), 함수명의 형태로 호출한다. 

<br/><br/>

### stdio 공통 모듈
- 입출력을 위해 파이썬의 기본 함수 print 대신 stdio.writeln 함수를 사용한다. 공통 모듈을 사용하면 파이썬 버전이나 언어의 변화에 의한 영향을 줄일 수 있다.

<br/>

1970년대 이후 초보 프로그래머가 프로그래밍을 시작할 때 Hello, World 메시지를 출력하는 것이 하나의 관례가 되었다. 

<br/><br/>

### 오류
- 프로그램의 편집, 컴파일, 인터프리트 과정의 차이가 모호해지기 쉽지만, 프로그래밍을 공부할 떄는 각 단계를 구분해야 발생하는 오류의 영향을 잘 이해할 수 있다.

<br/>

- 이메일 메시지를 작성하면서 철자와 문법 오류를 수정하는 것과 마찬가지로 프로그램을 작성할 때도 신중히 검토하면 오류를 대부분 피할 수 있다. 컴파일(compile-time) 오류는 파이썬이 프로그램을 컴파일할 때 발생한다. 컴파일 오류가 발생하면 프로그램을 변환할 수 없으며, 파이썬 컴파일러는 SyntaxError를 발생시켜 컴파일 오류를 알려준다. 그 외 실행(run-time) 오류는 파이썬이 프로그램을 인터프리트할 때 발생한다. 예를 들어 helloworld.py에서 import stdio 문장을 지우고 실행 시 파이썬 인터프리터가 NameError를 발생시킨다.

<br/>

- 일반적으로 프로그램에 있는 오류는 버그(bug)라고 하며, 프로그래머의 존재를 위협한다. 때때로 오류 메시지는 이해하기 힘들거나 오해를 불러일으키므로 오류의 원인을 찾아내기 어렵다. 프로그래밍하면서 가장 먼저 얻는 기술 중 하나는 오류를 찾아내는 기술이지만, 오류를 발생시키지 않도록 코딩할 때 주의하는 방법도 배우게 된다.

<br/><br/>

### 입출력
- 일반적으로 프로그램은 입력을 받는다. 입력은 결과를 만들어내기 위해 처리할 데이터를 말한다.

<pre><code>import sys
import stdio

stdio.write(‘Hi, ‘)
stdio.write(sys.argv[1])
stdio.writeln(’. How are you?’)</code></pre>

```
% python3 useargument.py Alice
Hi, Alice. How are you?
% python3 useargument.py Bob
Hi, Bob. How are you?
% python3 useargument.py Carol
Hi, Carol. How are you?
```
- 명령 줄 인수로 프로그램의 작동을 조절할 수 있다.
- 이 프로그램은 명령 줄 인수를 입력받고, 인수를 이용해 메시지를 출력한다.

<br/>

- useargument.py에서 import sys 문장은 sys 모듈에 정의된 기능을 사용하겠다는 것을 파이썬에게 알려준다. sys 모듈 기능 중 argv는 명령 줄 인수 목록을 담고 있으며, 명령 줄에서 python3 useargument.py 다음에 전달한 공백으로 분리된 인수를 담고 있다. useargument.py와 마찬가지로 프로그램 안에서 사용한 sys.argv[1]이 명령 줄에 입력한 문자열을 나타낸다.

<br/>

write() 함수는 writeln()과 같지만, 그저 문자열을 출력할 뿐 행은 바꾸지 않는다.

<br/>

- 조금 더 개념적으로 생각해보면 useargument.py는 그저 하나의 문자열(인수)을 다른 문자열(터미널에 출력되는 메시지)로 대응시키는 것일 뿐이라는 것을 알 수 있다. 이 개념을 이용하면 우리가 만드는 파이썬 프로그램은 입력 문자열을 출력 문자열로 변환하는 일종의 블랙박스라고 생각할 수 있다.

<br/><br/>

### Q. 왜 파이썬을 이용해 프로그래밍을 배우는가?

**A.** 우리가 공부할 프로그램은 다른 여러 언어에서도 상당히 비슷하게 구현되므로, 어떤 언어를 사용하는지는 중요하지 않다. 파이썬은 다양한 플랫폼에서 사용할 수 있고, 최신 언어가 제공하는 추상성을 모두 제공하며, 다양한 프로그램 오류를 자동으로 검사해주므로, 프로그래밍을 배우기에 적합하기 때문에 이 책에서는 파이썬을 이용한다. 파이썬은 진화하고 있으며 여러 버전이 사용되고 있다.

<br/><br/>

### Q. 탭, 공백, 개행 문자 등 공백 문자에 대해 파이썬은 어떤 규칙을 가지고 있나?

**A.** 일반적으로 파이썬은 프로그램 안에 있는 공백 문자를 모두 동일하게 처리하지만, 문자열 리터럴과 들여쓰기에서는 예외적으로 구분한다. 문자열 리터럴은 'Hello, World'처럼 작은따옴표 안에 들어 있는 일련의 문자들이다. 따옴표 안에 넣는 공백은 정확히 그대로 인식된다. 들여쓰기는 행의 앞에 나오는 공백을 말한다. 소스코드 각 줄 앞에 나오는 공백의 수는 파이썬 프로그램을 구조화하는 데 중요한 역할을 한다. 

<br/><br/>

### Q. 주석은 왜 사용하는가?

**A.** 작성한 코드를 다른 사람이 이해하거나, 혹은 나중에 자신의 코드를 다시 볼 때에 코드를 이해할 수 있게 도와주므로 주석을 반드시 사용해야 한다. 

<br/><br/><br/><br/>

## 내장 데이터 타입
- 파이썬에서 프로그래밍할 때는 프로그램이 처리하는 데이터가 어떤 데이터인지 늘 알고 있어야 한다. 데이터 타입(data type)은 값 집합과 이 값에 대해 정의된 연산 집합이다.

<br/>

- 파이썬 언어에는 몇 가지 데이터 타입이 내장되어 있다. 정수를 나타내는 int형, 실수를 나타내는 float 형, 일련의 문자들을 나타내는 str형, 참이나 거짓 값을 나타내는 bool 형

![image](https://user-images.githubusercontent.com/61584142/160220479-ee210488-72b5-4d29-b0b2-bac4c14951c8.png)

<br/>

```
a = 1234
b = 99
c = a + b
```
- 이 코드는 리터럴(literal) 1234와 99, 표현식(expression) a + b를 이용해 int형 객체(object) 세 개를 생성하고, 할당문(assignment statement)을 이용해 각 객체를 변수(variable) a, b, c에 바인딩(binding)한다(‘바인딩’은 연결의 생성을 기술적으로 표현하는 용어다). 결국 값이 1333인 int형 객체에 변수 c가 바인딩된다. 

<br/><br/>

### 리터럴
- 리터럴은 파이썬 코드에서 어떤 데이터 타입의 값을 표현한 것이다. 1234나 99처럼 일련의 숫자를 사용해 int형 값을, 3.14159나 2.71828처럼 일련의 숫자 사이에 소수점을 사용해 float형 값을, True나 False를 이용해 bool형 값을, 'Hello, World'처럼 문자들을 나열하고 양쪽에 따옴표로 에워싸서 str형 값을 표현한다.

<br/><br/>

### 연산자
- 연산자는 파이썬 코드에서 데이터 연산을 표현한다. 파이썬에서 정수와 실수의 덧셈과 곱셈은 +와 * 를 이용해 표현한다. 그리고 불형 연산을 나타내기 위해 and, or, not 연산자를 사용한다.

<br/><br/>

### 식별자 
- 식별자(identifier)는 파이썬 코드에서 어떤 이름을 나타낸다. 모든 식별자는 문자, 숫자, 밑줄 문자`(_)`로 구성되며, 문자나 밑줄 문자로 시작한다. 따라서 abc, Ab_, a_b는 모두 파이썬에서 사용할 수 있는 올바른 식별자이지만, Ab*, 1abc, a+b는 올바른 식별자가 아니다. 그리고 식별자는 대소문자를 구분하므로 Ab, ab, AB는 모두 서로 다른 이름이다. and, import, in, def, while, from, lambda 등의 키워드(keyword)는 예약되어 있으므로 식별자로 사용할 수 없으며, int, sum, min, max, len, id, file, input 등의 이름은 파이썬에서 특별한 의미를 갖고 있으므로, 식별자로 사용하지 않는 편이 좋다.

<br/><br/>

### 변수 
- 변수(variable)는 데이터 값에 연결된 이름이다. 계산을 진행하면서 변경되는 값을 추적하기 위해 변수를 사용한다. 예를 들어 이 책에 나오는 여러 프로그램에서 숫자들의 합계를 보관하기 위해 total이라는 변수를 사용한다. 변수명을 정할 때 일반적으로 프로그래머들은 일정한 스타일 관례를 따른다. 이 책에서는 소문자로 시작해 중간중간에 대문자가 들어가고, 경우에 따라 숫자를 붙여 변수명으로 사용하는 관례를 따른다(하나의 변수명이 여러 단어로 구성된 경우, 두 번째 단어부터 첫 글자만 대문자를 사용한다). 예를 들어 i, x, y, total, isLeapYear, outDegrees 등의 변수명을 사용한다.

<br/><br/>

### 상수 변수 
= (적어도 다음번 실행할 때까지) 프로그램을 실행하는 동안 바뀌지 않는 데이터 값에 연결된 변수를 설명하기 위해 상수 변수(constant variable)라는 다소 모순된 용어를 사용한다. 이 책에서는 상수 변수를 표현하기 위해 대문자, 숫자, 밑줄 문자로 구성된 이름을 사용한다. 예를 들어 SPEED_OF_LIGHT나 DARK_RED와 같은 형태의 상수 변수명을 사용한다.

<br/><br/>

### 표현식
- 표현식(expression)은 리터럴, 변수, 연산자의 조합으로서, 파이썬이 평가(evaluate)해 하나의 값을 생성한다. 표현식은 연산자를 이용해 하나 이상의 피연산자(operand)에 수행할 데이터 연산을 지정하며, 수학에서 사용하는 식과 비슷한 경우가 많다. 대부분의 연산자는 이진 연산자(binary operator)로서, x - 3이나 5 * x처럼 딱 두 개의 피연산자를 받는다. 어떠한 표현식도 피연산자가 될 수 있으며, 표현식을 피연산자로 사용할 때는 괄호에 넣는 경우가 많다. 예를 들어 4 * (x - 3)이나 5 * x - 6과 같이 표현식을 구성하며, 파이썬은 우리가 어떻게 연산하기를 원하는지 잘 안다. 표현식은 일련의 연산을 수행하라는 명령이며 연산 수행 결과를 나타낸다.

<br/><br/>

### 연산자 우선순위 
- 표현식은 일련의 연산을 간략히 압축해서 표현한 것이다. 그런데, 이 연산들을 어떤 순서대로 적용해야 하는가? 파이썬에는 수학에서의 산술식과 똑같이 자연스럽게 연산 순서를 명시하는 우선순위(precedence) 규칙이 잘 정의되어 있다. 산술 연산의 경우, 곱셈과 나눗셈이 덧셈과 뺄셈보다 먼저 수행되므로, a – b * c와 a – (b * c)의 연산 순서는 같다. 산술 연산자의 우선순위가 같을 때는 좌측 결합(left associative)되어 계산되므로, a – b – c와 (a – b) – c의 연산 순서가 같다. 다만 거듭제곱 연산자`(**)`는 예외적으로 우측 결합(right associative)되므로 a ** b ** c는 a ** (b ** c)와 같은 순서로 계산된다. 그러나 괄호를 이용하면 우선순위 규칙을 무시하므로, 원한다면 a – (b – c)와 같이 쓸 수 있다. 실제 파이썬 코드를 접하다 보면 우선순위 규칙의 미묘한 특징에 의존하는 코드를 볼 수 있는데, 이 책에서는 괄호를 이용해 연산 우선순위를 명시적으로 나타낼 것이다.

<br/><br/>

### 할당문 
- 파이썬에서는 어떻게 식별자를 변수로 정의하는가? 변수에 값은 어떻게 연결하는가? 파이썬에서는 할당문(assignment statement)을 이용해 이 두 개의 작업을 수행한다. 파이썬에서 a = 1234 문장을 작성하면 두 값이 같은지 검사하는 것이 아니라, 다음과 같은 작업을 수행하도록 명령하는 것이다.

    - (기존에 a라는 변수가 없었다면) a라는 식별자를 새로운 변수로 정의한다.
    - 변수 a에 정수형 값 1234를 연결한다. <br/><br/>

- 할당문의 오른쪽에는 어떠한 표현식도 올 수 있다. 이때 파이썬은 오른쪽에 나온 표현식을 평가해 계산된 값을 왼쪽에 있는 변수에 연결시킨다. 예를 들어 c = a + b 문장은 “변수 a와 b에 연결된 값을 더해 변수 c에 연결”하는 작업을 표현한다. 할당문의 왼쪽에는 변수 하나만 있어야 한다. 따라서 파이썬에서1234 = a나 a + b = b + a는 모두 잘못된 문장이다. 간단히 말해 프로그램에서 등호(=)의 의미는 수학 방정식에서 등치를 나타내는 등호와는 의미가 완전히 다르다.

<br/><br/>

### 비공식 트레이스 
- 한 줄씩 문장이 실행된 후에 영향을 받는 변수에 값을 할당하는 표를 사용하면 변수에 연결된 값을 효율적으로 추적할 수 있다. 이런 표를 트레이스(trace)라고 하며, 이 기법은 프로그램의 작동을 이해하기 위해 오랫동안 사용되어 검증된 방법이다.

![image](https://user-images.githubusercontent.com/61584142/160220591-0dafbbf8-315e-4eac-a235-436ea9e1d509.png)

<br/><br/>

### 객체 
- 파이썬 프로그램에서 데이터 값은 모두 객체(object) 및 객체 간의 관계로 표현된다. 객체는 특정 데이터 타입의 값을 컴퓨터 메모리 내부에 표현한 것이다. 각 객체는 정체성, 형, 값이라는 특징을 갖고 있다.

    - 정체성(identity)은 각 객체를 구분해준다. 정체성은 객체가 저장된 컴퓨터 메모리 내에서의 위치(메모리 주소)로 생각할 수 있다.
    - 객체의 타입은 객체가 표현할 수 있는 값 집합과 이 값에 수행할 수 있는 연산 집합을 명시한다.
    - 객체의 값은 객체가 나타내는 값이다. <br/><br/>

- 객체는 하나의 값을 저장한다. 예를 들어 int형 객체는 1234, 99, 1333 등의 값을 저장할 수 있다. 서로 다른 객체가 같은 값을 저장할 수도 있다. 예를 들어 어떤 str형 객체가 'hello' 값을 저장하고, 또 다른 str형 객체도 똑같은 'hello' 값을 저장할 수 있다. 객체 형에 의해 정의된 어떠한 연산도 객체에 적용할 수 있다(다만 해당 객체에 정의된 연산만 적용할 수 있다). 예를 들어 int형 객체 두 개를 곱할 수 있지만, str형 객체 두 개는 곱할 수 없다.

<br/><br/>

### 객체 참조 
- 객체 참조(object reference)는 그저 객체의 정체성(객체가 저장된 메모리 주소)을 명시적으로 표현한 것일 뿐이다. 파이썬 프로그램은 객체의 값에 접근하거나 객체 참조 자체를 조작하기 위해 객체 참조를 사용한다. 

<br/><br/>

### 객체에 기반한 공식적인 정의
• 리터럴(literal)은 파이썬이 해당 값을 가진 객체를 생성하게 만드는 명령이다.
• 변수(variable)는 객체 참조에 붙여진 이름이다. 
• 표현식(expression)은 파이썬이 지정된 연산을 수행해 계산된 값을 가진 객체를 생성하게 만드는 명령이다.
• 할당문(assignment statement)은 파이썬이 등호의 오른쪽에 나온 표현식을 계산해 생성된 객체를 등호의 왼쪽에 있는 변수에 바인딩하게 만드는 명령이다(기존에 바인딩되어 있던 다른 객체에 무관하게 변수는 새로운 객체에 바인딩된다).

![image](https://user-images.githubusercontent.com/61584142/160220649-45804e31-2dfc-4384-adef-3b0d28758503.png)

<br/><br/>

### 객체 수준 트레이스

![image](https://user-images.githubusercontent.com/61584142/160220659-dd28deab-a962-432d-8fe0-52e1d512dccb.png)

- a = 1234 문장은 1234 값을 가진 int 객체를 생성하고, 생성된 객체에 변수 a를 바인딩한다.
- b = 99 문장은 99 값을 가진 int 객체를 생성하고, 생성된 객체에 변수 b를 바인딩한다.
- c = a + b 문장은 a에 바인딩된 객체의 값과 b에 바인딩된 객체의 값을 더해 계산된 1333 값을 가진 int 객체를 생성하고, 생성된 객체에 변수 c를 바인딩한다.

<br/><br/>

### 문자열 
- str 데이터 타입은 텍스트 처리를 위해 사용되는 문자열을 나타낸다. str 객체 안에 들어가는 값은 일련의 문자들이다. 한 쌍의 작은따옴표 안에 일련의 문자들을 넣어 str형 리터럴을 지정할 수 있다. 예를 들어 ‘ab’는 문자 ‘a’ 다음에 ‘b’, 두 개의 문자를 저장하고 있는 str 객체를 나타낸다. 문자열에 들어갈 수 있는 문자들은 많이 있지만, 일반적으로 영문자, 숫자, 기호, 탭이나 개행 문자와 같은 공백 문자를 주로 표현한다. 역슬래시`(</code>)`를 사용해 특별한 의미를 가진 문자들도 표현할 수 있다. 예를 들어 ‘\t’, ‘\n’, ‘\‘, “\”은 각기 탭, 개행 문자, 역슬래시, 작은따옴표를 나타낸다.

<br/>

#### 더하기표(+)
- 문자열 두 개를 연결(concatenate)할 수 있다. 즉 더하기표는 두 개의 str 객체를 피연산자로 받아 첫 번째 str 객체에 들어 있는 문자열 뒤에 두 번째 str 객체에 들어 있는 문자열을 값으로 가지는 새로운 str 객체를 생성한다. 예를 들어 표현식 ‘123’ + ‘456’은 값이 ‘123456’인 str 객체로 평가된다. 이 예제에서 알 수 있듯이 + 연산자를 두 개의 str 객체에 적용(문자열 연결)하면 + 연산자를 두 개의 int 객체에 적용할 때와 아주 다르게 작동한다.

![image](https://user-images.githubusercontent.com/61584142/160220725-aaf44426-024a-43c3-b646-3b1eb781be90.png)

<br/>

#### 숫자를 문자열로 변환해 출력하기 
- 파이썬에서 제공하는 str() 함수를 이용하면 숫자를 문자열로 변환할 수 있다. 예를 들어 str(123)을 실행하면 '123'이라는 str 객체로 평가되며, str(123.45)을 실행하면 '123.45'라는 문자열로 평가된다. stdio.write()이나 stdio.writeln()에 str형 이외의 객체를 인수로 전달하면 이 함수들은 인수에 str() 함수를 호출해 문자열을 생성한 후 출력한다. 따라서, stdio.write(123), stdio.write(str(123)), stdio.write('123'), 중 어떠한 형태로 호출하든지 화면에는 123이 출력된다.

<br/>

#### 문자열을 숫자로 변환해 입력하기
- 파이썬에서는 문자열을 숫자로 변환하는 함수도 제공한다(프로그램 명령 줄 인수로 입력받은 숫자는 str형이므로, 인수를 계산에 사용하려면 숫자로 변환해야 한다). int() 함수는 정수형으로, float() 함수는 실수형으로 변환한다. 예를 들어 프로그램 코드 안에 int('1234')로 입력하면 int 리터럴 1234를 입력한 것과 똑같은 효과를 낸다. 사용자가 첫 번째 명령 줄 인수로 1234를 입력하면 코드 안에서 int(sys.argv[1]) 문장을 실행해 값이 1234인 int 객체 1234로 평가된다. <br/><br/>
- 방금 설명한 형 변환 기능을 추가해도, 파이썬 프로그램을 문자열 인수를 받아 문자열을 생성하는 일종의 블랙박스로 보는 관점은 여전히 유효하지만, 이제는 문자열을 숫자로 해석해 의미 있는 계산을 하기 위한 기반으로 사용할 수 있다.

![image](https://user-images.githubusercontent.com/61584142/160220784-1a19d47c-834a-49a7-b4ef-578346081f73.png)

<br/><br/>

### 정수형 
- int 데이터 타입은 정수나 자연수를 나타낸다. int 리터럴은 0에서 9 사이의 숫자를 나열해 지정할 수 있다. 파이썬이 int 리터럴을 만나면 지정된 값을 담고 있는 int 객체를 생성한다. 정수가 실세계에서 빈번히 사용될 뿐만 아니라 프로그램을 작성할 때 자연스럽게 발생하므로, int 객체를 자주 사용하게 된다. <br/><br/>

- 파이썬은 덧셈에 +, 뺄셈에 -, 곱셈에 * , 바닥 나눗셈(floored division)에 //, 나머지에 %, 거듭제곱에 등 정수에 널리 사용되는 연산에 사용하기 위한 연산자를 가지고 있다. 이 이진 연산자들은 일반적으로 두 개의 int 객체를 피연산자로 받아 하나의 int 객체를 생성한다. 파이썬에는 정수의 부호를 지정하기 위한 +와 – 단항 연산자도 가지고 있다. 이 연산자들은 모두 초등학교 때 배운 연산을 그대로 수행하도록 정의되어 있다(바닥 나눗셈의 결과는 정수라는 점을 명심하라). 두 개의 int 객체 a와 b가 있을 때, 표현식 a // b는 b가 a에 들어가는 횟수를 계산하고 소수점 이하는 버리며, a % b는 a를 b로 나누었을 때의 나머지를 계산한다. 예를 들어 17 // 3은 5가 되고, 17 % 3은 2가 된다. 바닥 나눗셈이나 나머지 연산 모두 0으로 나눌 때는 실행 시 ZeroDivisionError 예외를 발생시킨다.

![image](https://user-images.githubusercontent.com/61584142/160220819-41b69f1a-0bd3-4122-9946-d24d9afc95ec.png)

<br/>

- 파이썬에서 int 형이 가질 수 있는 값의 범위는 제한이 없다. 오로지 컴퓨터 시스템에 있는 메모리의 크기에 의해 제한될 뿐이다. 다른 프로그래밍 언어에서는 정수의 범위를 제한한다. 예를 들어 자바 프로그래밍 언어의 경우 정수의 범위가 –2<sup>31</sup>(–2147483648)에서 2<sup>31</sup> – 1(2147483647)까지다. 그러나 파이썬 프로그래머는 정수가 너무 커서 범위에 들어가지 않을지 걱정할 필요 없다. 대신 버그 있는 프로그램이 아주 큰 정수를 만들어 컴퓨터 메모리를 모두 소모해 버리지 않을지 걱정해야 한다.

![image](https://user-images.githubusercontent.com/61584142/160220851-bdf8f02e-2a3c-4221-bc18-5397e9941440.png)

<br/><br/>

### 실수형 
- float 데이터 타입은 과학이나 금융 애플리케이션에서 사용할 수 있는 실수를 나타낸다. float를 이용해 실수를 표현할 수 있지만, 수학에서 의미하는 실수를 모두 표현할 수 있는 것은 아니다! 실수는 무한히 많이 있지만, 디지털 컴퓨터에서는 한정된 개수의 실수만 표현할 수 있기 때문이다. float가 실수를 충분히 유사하게 표현할 수 있어서 애플리케이션에서 사용할 수 있기는 하지만 언제나 정확하게 계산할 수 있는 것은 아니므로, 정확도 문제를 해결해야 하는 경우가 종종 발생한다.

![image](https://user-images.githubusercontent.com/61584142/160220873-af21b339-0923-430a-921d-643b45a5d996.png)

<br/>

- 실수 리터럴은 일련의 숫자와 소수점을 이용해 지정할 수 있다. 예를 들어 3.14159는 파이(𝜋)의 근삿값을 나타낸다. 아니면 과학 표기법을 이용해 아보가드로 상수 6.022 × 10<sup>23</sup>을 6.022e23으로 표기할 수도 있다. 정수와 마찬가지로 이 표기법을 이용해 프로그램 안에서 실수 리터럴을 표현하거나 명령 줄에서 문자열 인수로 사용할 수 있다.

![image](https://user-images.githubusercontent.com/61584142/160220888-05296771-3c16-47df-b1a1-75d2d9af6c2b.png)

<br/><br/>

### 불형 
- bool 데이터 타입은 논리에서 사용하는 참값(참 혹은 거짓)을 나타낸다. 불형은 참과 거짓에 해당하는 True와 False, 단 두 개의 리터럴이 있다. bool 형에 적용할 수 있는 연산은 True나 False 값을 가진 피연산자를 받아 평가해 결과적으로 True나 False가 된다. 얼핏 보기에 간단해 보이지만, bool 데이터 타입은 컴퓨터 과학의 기반이 된다. bool 객체에 정의된 연산자 and, or, not은 논리 연산자로 알려져 있으며, 익히 알고 있듯이 다음과 같이 정의된다.

![image](https://user-images.githubusercontent.com/61584142/160220908-aaafe000-1378-4460-9daf-5ae548e7935e.png)

<br/>

• a and b는 두 피연산자 모두 True일 때에만 True이며, 그 외에는 False이다.
• a or b는 두 피연산자 모두 False일 때에만 False이며, 그 외에는 True이다.
• not a는 a가 False일 때 True, a가 True일 때는 False이다.

<br/>

- 이렇게 간단히 정의되므로 쉽게 알 수 있지만, 표에서 보는 것처럼 진리표(truth table)를 만들어 가능한 모든 연산의 결과를 정리해둘 필요가 있다. not 연산자는 피연산자를 하나만 가지며, 가능한 모든 값에 대한 연산 결과는 두 번째 열에 나와 있다. and와 or 연산자는 두 개의 피연산자를 받으며, 가능한 모든 값에 대한 연산 결과는 오른쪽 끝에 있는 두 개의 열에 나와 있다.

![image](https://user-images.githubusercontent.com/61584142/160220930-006280d2-d871-4820-b01a-46cd04c0a4ee.png)

<br/>

- 괄호 및 우선순위 규칙과 함께 이 연산자들을 활용하면 상당히 복잡한 표현식을 만들 수 있으며, 이 표현식은 하나의 불형 함수를 나타낸다. not 연산자는 and보다 우선순위가 높고, and 연산자는 or보다 우선순위가 높다.

<br/>

- 논리식에서는 같은 연산을 수행하는 함수가 다른 모습으로 나타나는 경우가 종종 있다. 예를 들어 표현식 (a and b)와 not (not a or not b)는 대등하다. 진리표 검증(truth-table proof) 기법을 이용해 모든 경우에 동일한 값으로 평가되는지 확인하면 두 표현식이 대등한지 검증할 수 있다.

![image](https://user-images.githubusercontent.com/61584142/160220946-d0fb3dbc-d429-4e67-bcc2-408d4de31ea5.png)

<br/>

- 이렇게 표현식을 조작하는 것에 대해 수학적으로 연구하는 것을 불 논리(Boolean logic)라고 하며, 컴퓨터 과학의 기반이 된다. 불 논리는 컴퓨터 하드웨어 자체의 설계 및 연산에 있어서 핵심적인 역할을 하며, 컴퓨터 과학에 있어서 이론적 기반의 출발점이기도 하다. bool 표현식이 프로그램의 작동을 제어하는 데 사용되므로 여기에서는 일단 bool 표현식을 살펴보자. 일반적으로 관심의 대상이 되는 조건은 불 표현식으로 지정된다. 그러고 나서 표현식이 참으로 평가될 때 실행할 일련의 문장들과 표현식이 거짓으로 평가될 때 실행할 일련의 문장들로 프로그램 코드를 구성한다. 

<br/><br/>

### 비교 
- 자신이 받은 피연산자의 데이터 타입과 다른 데이터 타입 결과를 생성하는 혼합형(mixed-type) 연산자도 있다. 비교 연산자(comparison operator)`(==, !=, <, <=, >,>=)`는 대표적인 혼합형 연산자로서, 정수형과 실수형에 대해 모두 정의되어 있으며, 불형 결과를 반환한다. 연산은 데이터 타입에 대해서만 정의되므로, 각각의 비교 연산자는 데이터 타입 별로 정의된다. 비교할 피연산자들은 서로 호환되는 데이터 타입이어야 하며, 결과는 언제나 불형이다.

![image](https://user-images.githubusercontent.com/61584142/160220975-0b2be58a-9175-4c4d-9df9-dfa8bc2ca624.png)

<br/>

- 숫자 표기법에 대해 깊이 파고들지 않더라도, 데이터 타입에 따라 비교 연산이 상당히 다를 것이라는 것은 명백히 알 수 있다. 예를 들어 `(2 <= 2)`가 True인지 검사하기 위해 두 개의 정수를 비교하는 것과 `(2.0 <= 0.002e3)`가 True인지 검사하기 위해 두 개의 실수를 비교하는 것은 아주 다르다. 그렇지만 각각의 비교 연산이 데이터 타입 별로 잘 정의되어 있으므로, 표에서 보는 것처럼 `(b*b - 4.0*a*c) >= 0.0` 등의 조건을 검사하는 코드를 작성하는 데 유용하게 쓰인다.

![image](https://user-images.githubusercontent.com/61584142/160220996-86c9c855-49d8-415e-b8e8-a088b0a86b03.png)

<br/>

- 비교 연산자의 우선순위는 산술 연산자보다는 낮고 불 연산자보다는 높으므로, `(b*b - 4.0*a*c) >= 0.0`과 같은 표현식에서는 괄호가 필요 없으며, month가 1과 12 사이에 있는지 검사하기 위해서는 괄호 없이 `month >= 1 and month <= 12`처럼 표현식을 작성할 수 있다
- (그러나 괄호를 사용하면 표현식의 의도를 명확히 알려주므로, 더 좋은 코딩 스타일이다).

<br/>

- 비교 연산은 불 논리와 함께 파이썬에서 의사 결정을 하는 기반이 된다. 

<br/><br/>

### 함수와 API
- 이미 앞에서 살펴본 것처럼 프로그램을 작성할 때는 내장된 연산자뿐만 아니라, 유용한 작업을 수행하는 함수(function)도 사용한다. 이 책에서는 함수를 다음과 같이 세 가지로 구분한다.

<br/>

• 내장 함수: 모든 파이썬 프로그램에서 바로 사용할 수 있는 함수(int(), float(), str() 등)
• 표준 함수: 파이썬 표준 모듈에 정의되어 있으며, 모듈을 임포트하는 모든 프로그램에서 사용할 수 있는 함수(math.sqrt() 등)
• 예제용 라이브러리 함수: 이 책의 예제 코드에서 사용하는 라이브러리 모듈을 임포트하는 모든 프로그램에서 사용할 수 있는 함수(stdio.write(), stdio.writeln() 등). 별도로 설치해야 하는 서드파티 라이브러리의 일종이다.

<br/>

- 사용할 수 있는 내장 함수, 표준 함수, 예제용 라이브러리 함수는 아주 많이 있다. 프로그래밍을 공부하면서 점점 더 많은 함수를 사용하게 되지만, 처음에는 되도록이면 적은 수의 함수에 집중하는 편이 좋다. 이번 장에서는 출력, 데이터 타입 변환, 수학 계산을 위해 이미 함수를 사용해왔다. 

<br/>

#### 파이썬에서 널리 사용되는 함수들의 API

![image](https://user-images.githubusercontent.com/61584142/160221350-5f05aaca-48a2-4245-94f2-3b24a5b3603d.png)

<br/>

- 코드 안에서는 함수명 뒤에 나오는 괄호 안에 인수(argument)를 콤마로 구분해 전달함으로써 함수를 호출할 수 있다. 파이썬이 프로그램을 실행할 때, 파이썬이 주어진 인수를 이용해 함수를 호출(call)(혹은 평가(evaluate))하고 값을 반환(return)한다. 엄격히 말하면 함수는 객체에 대한 참조를 반환하며, 이 객체가 값을 가지고 있는 것이다. 함수를 호출하는 문장도 일종의 표현식이므로, 함수를 호출할 때는 `math.sin(x) * math.cos(y)`처럼 변수와 리터럴을 이용해 복잡한 표현식을 만드는 방식을 그대로 사용할 수 있다. 그리고 표현식을 이용해 인수를 전달할 수도 있다. 파이썬은 표현식을 먼저 평가하고 그 결괏값을 인수로 전달한다. 따라서 `math.sqrt(b*b - 4.0*a*c)`처럼 같이 호출해도 파이썬은 의도한 바를 제대로 파악해 처리한다.

![image](https://user-images.githubusercontent.com/61584142/160221374-5230b54d-23eb-4790-a0a6-abcb5172c4e4.png)

<br/>

- 선택적 인수를 전달하지 않는 경우 기본값(default value)을 사용하는 함수도 있다. math.log()는 로그 밑수를 두 번째 인수에 선택적으로 받으며, 두 번째 인수를 지정하지 않는 경우 e를 밑수로 하는 자연로그를 구한다.

<br/>

- 순수 함수는 동일한 인수를 받으면 언제나 동일한 값을 반환하며, 외부 환경에 미치는 부작용(side effect)이 없는 함수이다. random.random()과 random.randrange()는 호출할 때마다 다른 값을 반환하므로 순수 함수가 아니며, stdio.write()와 stdio.writeln()은 표준 출력 장치에 문자열을 출력하는 부작용이 있으므로 순수 함수가 아니다. <br/><br/>
- math 모듈에서는 원주율과 자연로그를 상수인 math.pi와 math.e로 정의하고 있으므로, 프로그램 안에서 이 값이 필요할 때 상수를 사용할 수 있다. 따라서 math.sin(math.pi/2)는 1.0을 반환하고(math.sin()은 라디안 값을 받는다) math.log(math.e)는 1.0을 반환한다(math.log()의 기본값 밑수가 e이다).

<br/><br/>

### 형 변환 
- 프로그래밍할 때는 보통 여러 데이터 타입을 처리하게 된다. 데이터 타입을 알아야 객체가 정확히 어떤 값을 가질 수 있고, 객체에 어떤 연산을 수행할 수 있는지 알 수 있으므로, 프로그램이 처리할 데이터의 타입을 늘 알고 있어야 한다. 특히 어떤 데이터 타입에서 다른 데이터 타입으로 변환해야 하는 일이 종종 생긴다. 예를 들어 1, 2, 3, 4, 네 개의 정수의 평균을 구하려 한다고 생각해보자. 자연스럽게 표현식 (1 + 2 + 3 + 4) / 4가 떠오르겠지만, 형 변환 때문에 이 표현식으로는 원하는 결과가 나오지 않는 프로그래밍 언어가 많다. 

![image](https://user-images.githubusercontent.com/61584142/160221415-30e945b0-3f03-41ba-bdb8-0c2d25d59a5b.png)

<br/>

- 문제는 피연산자가 정수형이지만 실수형 결과를 기대한다는 사실 때문에 발생한다. 따라서 도중에 정수에서 실수로 형을 변환해야 한다. 파이썬에서는 형을 변환하기 위해 명시적인 방법이나 암시적인 방법을 사용한다.

<br/>

#### 명시적 형 변환 
- 먼저 어떤 형의 인수를 받아 다른 형의 객체를 반환하는 함수를 사용하는 방법이 있다. 우리는 문자열에서 정수나 실수로, 그리고 숫자를 문자열로 변환하기 위해 이미 int(), float(), str() 내장 함수를 사용해왔다. 이와 같이 문자열과 숫자 간의 형 변환을 가장 흔히 볼 수 있지만, 표에서 보는 것처럼 정수에서 실수로, 실수에서 정수로 변환하기 위해서도 사용할 수 있다. 예를 들어 int(x)나 int(round(x))를 이용해 실수를 정수로, float(x)를 이용해 정수를 실수로 변환할 수 있다. 따라서 float(1 + 2 + 3 + 4) / float(4)는 우리가 원하는 대로 파이썬 3와 파이썬 2에서 모두 2.5로 평가된다.

![image](https://user-images.githubusercontent.com/61584142/160221432-514f1b79-752f-4ab8-a81a-f5dd73ac960e.png)

<br/>

#### (정수에서 실수로) 암묵적 변환 
- 파이썬은 가능한 경우 자동으로 정수를 실수로 변환하기 때문에 실수가 필요한 곳에 정수를 사용할 수 있다. 예를 들어 10/4.0은 2.5로 평가된다. 4.0이 실수이고 피연산자 두 개가 모두 같은 형이어야 하므로, 10이 실수로 변환되어 결국 두 개의 실수로 나눗셈을 하기 때문이다. 그리고 math.sqrt(4)를 평가하면 2.0이 된다. math.sqrt()가 실수를 인수로 받기 때문에 4가 실수로 변환되고 연산 후 실수를 반환하기 때문이다. 이러한 방식으로 이루어지는 형 변환을 자동 승격(automatic promotion), 혹은 억제(coercion)라고 한다. 정보를 손실하지 않고 형을 변환할 수 있으므로 파이썬에서 제공하는 자동 형 변환 기능은 타당하다. 그러나 주의할 점이 몇 가지 있다. 예를 들어 앞에서 살펴본 것처럼 파이썬 3는 / 연산자의 피연산자를 자동으로 실수형으로 변환하지만, 파이썬 2는 변환하지 않는다. 따라서 (1 + 2 + 3 + 4) / 4는 파이썬 3에서는 2.5, 파이썬 2에서는 2로 평가된다. <br/><br/>
- 늘 int()와 float() 함수를 사용해 형 변환 의도를 명시한다면 자동 승격 개념은 필요 없다. 가능한 한 자동 승격을 피하는 프로그래머들도 있다. 그러나 자동 승격에 의존하는 코드는 더 간단하고 읽기 쉬우므로, 이 책에서는 자동 승격을 이용한다. 그러나 / 연산자로 숫자 두 개를 나눌 때는 언제나 피연산자 두 개 중 최소 하나는 실수형이 되도록 만들 것이다. 앞에서 설명한 것처럼 표현식 (1 + 2 + 3 + 4) / 4.0을 파이썬이 평가할 때, 첫 번째 피연산자를 자동 승격시켜 우리가 원하는 결과인 2.5로 평가되기 때문이다. 자동 승격을 이용하면 코드가 파이썬 3와 파이썬 2에서 모두 제대로 작동하며, 이런 방식을 지원하는 다른 언어들도 많다. 그러나 이 책에서는 두 개의 정수를 나눌 때는 / 연산자를 사용하지 않는다.

<br/><br/>

- 데이터 타입은 값의 집합이며 이 값들에 적용할 일련의 연산을 정의한다. 파이썬에는 bool, str, int, float형이 내장되어 있으며, 다른 형들은 나중에 알아볼 것이다. 파이썬 코드에서는 우리에게 익숙한 수학적 표기법과 비슷한 연산자와 표현식을 사용해 데이터 타입과 관련된 연산을 실행한다. bool형은 참, 거짓 값을 계산하기 위해 사용되고, str형은 문자열을 나타내기 위해 사용되고, int와 float형은 숫자를 계산하기 위해 사용된다. <br/><br/>
- and, or, not 논리 연산자를 포함하는 bool형은 파이썬 프로그램에서 ==, !=, <, <=, >, >= 등의 비교 연산자들과 함께 사용되어 논리적으로 의사 결정을 하는 기반이 된다. 구체적으로 bool 표현식은 파이썬의 조건문(if)과 반복문(while)에서 실행 흐름을 제어하기 위해 사용된다. <br/><br/>
- 숫자 데이터 타입, 내장 함수, 파이썬 표준과 확장 모듈에 정의된 함수, 이 책의 예제용 라이브러리에 정의된 함수를 이용하면 파이썬을 강력한 수학 계산기로 사용할 수 있다. `+, -, *, /, //, %, **` 등의 내장 연산자와 파이썬 함수를 사용해 다양한 산술 표현식을 만들 수 있다.

<br/><br/>

### 대화형 파이썬 
- 사실 파이썬은 대화형 계산기로 사용할 수도 있다. 터미널 창에서 python3 명령을 실행하면 된다. 파이썬은 자기 버전을 보여주고, >>> 프롬프트를 출력한다. 이 프롬프트에 파이썬 문장을 입력하면 파이썬이 문장을 실행한다. 파이썬 표현식을 입력하면 파이썬이 입력된 표현식을 평가해 결괏값을 출력한다. 아니면 help()를 입력해 파이썬의 어마어마한 대화형 문서를 볼 수도 있다. 사용하는 예는 다음과 같다(볼드체는 입력하는 부분을 나타낸다). 이 방법을 이용하면 새로 만든 코드를 테스트하고 문서를 확인해보면서 궁금한 모듈이나 함수에 대해 공부할 수 있다. 

![image](https://user-images.githubusercontent.com/61584142/160221581-9cd9abec-c113-40b9-b81d-c0100bedd444.png)

<br/><br/>

### Q. 파이썬은 문자열을 내부에 어떻게 저장하는가?
**A.** 문자열은 최신 텍스트 인코딩 표준인 유니코드(Unicode)로 인코딩된 문자들을 나열한 것이다. 유니코드는 100여 개 언어에서 사용하는 10만 개 이상의 문자를 지원하며, 수학이나 음악에서 사용하는 기호도 지원한다.

<br/><br/>

### Q. 문자 하나를 표현하기 위해 파이썬에서는 어떤 데이터 타입을 제공하는가?
**A.** 파이썬에는 문자 하나를 표현하기 위한 별도의 데이터 타입이 없다. 'A' 등의 문자는 그저 요소가 하나만 들어 있는 문자열일 뿐이다.

<br/><br/>

### Q. 내장 연산자 ==과 <, 혹은 내장 함수인 max()나 min()을 이용해 문자열을 비교할 수 있는가?

**A.** 할 수 있다. 공식적인 것은 아니지만 파이썬은 책의 인덱스나 사전에서 볼 수 있는 사전순으로 두 문자열을 비교한다. 예를 들어 'hello'와 'hello'는 똑같고, 'hello'와 'goodbye'는 같지 않으며 'goodbye'가 'hello'보다 작다. 

<br/><br/>

### Q. 작은따옴표 대신 큰따옴표 쌍을 이용해 문자열 리터럴을 표현할 수 있는가?

**A.** 할 수 있다. 예를 들어 'hello'와 "hello"는 똑같은 리터럴이다. 작은따옴표를 담고 있는 문자열을 표현할 때는 큰따옴표를 사용하면 이스케이프 문자를 사용하지 않고 문자열을 표현할 수 있다. 예를 들어 'Python\'s'와 "Python's"는 똑같은 문자열 리터럴이다. 그리고 따옴표 세 개를 이용해 여러 줄에 걸친 문자열을 지정할 수도 있다. 예를 들어 다음 코드는 두 줄로 구성된 문자열을 변수 s에 할당한다.

<br/><br/>

### Q. 파이썬에서 정수는 내부적으로 어떻게 저장되는가?
**A.** 작은 양수의 경우 간단히 이진법(binary number system)을 이용해 고정된 크기의 컴퓨터 메모리 안에 각각의 정수가 표현된다.

<br/><br/>

### Q. 음수는 어떻게 저장되는가?

**A.** 작은 음수의 경우 2의 보수(two's complement)라고 하는 방법으로 처리되지만, 여기에서는 자세히 설명하지 않을 것이다. ‘작은’이라고 할 때의 크기는 컴퓨터 시스템의 설계에 따라 다르다. 구형 32비트 컴퓨터의 경우, ‘작은’ 숫자는 –2147483648(–231)에서 2147483647(231 – 1)까지의 범위를 표현할 수 있다. 최신 64비트 컴퓨터의 경우 ‘작은’ 숫자는 –263에서 263 – 1까지의 숫자를 표현할 수 있으므로, 그리 작은 숫자는 아니다! ‘작은’ 숫자로 표현할 수 있는 것보다 큰 숫자는 파이썬이 자동으로 형을 변환해 더욱 정교한 표기법을 사용하는데, 컴퓨터 시스템의 메모리가 허용하는 한 아주 큰 숫자를 저장할 수 있다. 숫자가 어떤 방법으로 저장되었는지는 프로그램에서 알 수 없으며, 프로그래머는 내부 표기법에 따른 데이터 형 변환에 신경 쓰지 않고 자유롭게 숫자를 사용할 수 있다.

<br/><br/>

### Q. 1/0 표현식은 파이썬에서 어떻게 평가되는가?
**A.** 이 표현식은 실행 시 ZeroDivisionError 예외를 발생시킨다. 이런 것은 질문할 필요 없이 파이썬을 대화형 모드로 실행해 간단히 확인할 수 있다. 

<br/><br/>

### Q. 바닥 나눗셈 연산자 //와 나머지 연산자 %를 음수에 적용하면 어떻게 되는가?

**A.** -47 // 5는 -10, -47 % 5는 3으로 평가된다. 일반화해보자면 바닥 나눗셈 연산자 //는 정수 몫(즉, 음수 무한대 쪽으로 반올림한 몫)으로 평가된다. 나머지 연산자 %는 약간 더 복잡하게 작동한다. 파이썬에서는 a와 b가 정수일 때, 표현식 a % b는 b와 동일한 부호를 갖도록 평가된다. 따라서 모든 정수 a와 b에 대해 b * (a // b) + a % b = a가 성립된다. 자바 등의 언어에서는 표현식 a % b는 a와 같은 부호를 갖도록 평가된다.

<br/><br/>

### Q. 10^6이 1000000이 아니라 12가 되는 이유는?

**A.** ^ 연산자를 거듭제곱 연산자로 생각하기 쉽지만, 파이썬에서 ^ 연산자는 거듭제곱 연산을 나타내지 않고, 논리적 배타합(XOR)을 나타낸다. ^ 연산자는 이 책에서는 사용하지 않는다. 리터럴 1000000이 필요할 때는 표현식 10 ** 6을 사용할 수 있지만, 리터럴을 사용해도 되는 곳에 표현식을 사용하면 실행 시 컴퓨터의 처리 능력을 소모하게 만든다.

<br/><br/>

### Q. 실수의 데이터 타입 이름이 float인 이유는?
**A.** 소수점이 실수를 구성하는 숫자들 사이를 떠다닐 수 있기 때문이다. 이와 반대로 정수의 경우, (암묵적으로) 소수점이 가장 낮은 숫자 뒤에 고정되어 있다.

<br/><br/>

### Q. 파이썬에서는 실수를 내부적으로 어떻게 저장하는가?

**A.** 일반적으로 파이썬은 해당 컴퓨터 시스템에서 자연스럽게 표현될 수 있는 표기법을 사용한다. 대부분의 컴퓨터는 IEEE 754 표준이 정의한 대로 실수를 저장한다. 이 표준에 따라 실수는 부호, 가수, 지수, 3개의 부분으로 나뉘어 저장된다. 그리고 IEEE 754 표준은 특별한 값(양의 영, 음의 영, 양의 무한대, 음의 무한대, NaN(Not a Number))을 처리하는 방법도 명시한다. 예를 들어 -0.0/3.0은 -0.0으로, 1.0/0.0은 양의 무한대, 0.0/0.0은 NaN으로 평가된다. 계산에서 양의 무한대를 나타내는 float(‘inf’)와 음의 무한대를 나타내는 float(‘-inf’) 표현식을 사용할 수 있지만, 파이썬은 IEEE 754에서 이 부분에 대한 표준은 따르지 않는다. 예를 들어 파이썬에서 -0.0/3.0은 정확히 -0.0으로 평가되지만, 1.0/0.0과 0.0/0.0은 모두 실행 시 ZeroDivisionError 예외를 발생시킨다.

<br/><br/>

### Q. 실수에서 15자리 숫자면 나에게는 충분해 보인다. 실수의 정밀도에 대해 신경 써야 하는가?
**A.** 신경 써야 한다. 사람은 무한한 정밀도를 가진 실수에 기반한 수학에 익숙해져 있지만, 컴퓨터는 근삿값을 표현할 수 있을 뿐이다. 예를 들어 IEEE 754 실수에서 표현식 (0.1 + 0.1 == 0.2)은 참이지만, 표현식 (0.1 + 0.1 + 0.1 == 0.3)은 참이 아니다! 과학 문제에 컴퓨터를 적용할 때 이런 문제는 어렵지 않게 볼 수 있다. 초보 프로그래머들은 두 실수가 같은지 비교하는 연산을 하지 않도록 주의해야 한다.

<br/><br/>

### Q. 두 개의 실수에 바닥 나눗셈 연산자 //를 적용할 수 있나?
**A.** 적용할 수 있다. 실수를 나눈 후 소수점 이하를 제거한 몫 부분이 결과가 된다. 

<br/><br/>

### Q. 인수의 소수점 부분이 0.5일 때 round()는 어떤 값을 반환하는가?
**A.** 파이썬 3에서 round()는 가장 가까운 정수를 반환한다. 즉 round(2.5)는 2, round(3.5)는 4, round(-2.5)는 -2를 반환한다. 그러나 파이썬 2에서 round()는 0에서 반올림하고 실수형으로 변환해 반환한다. 즉 round(2.5)는 3.0, round(3.5)는 4.0, round(-2.5)는 -3.0을 반환한다.

<br/><br/>

### Q. float형과 int형을 비교할 수 있는가?
**A.** 형을 변환해야 비교할 수 있다. 그러나 파이썬이 필요한 형 변환을 자동으로 해준다는 사실을 잊지 말자. 예를 들어 x가 정수 3이면 표현식 (x < 3.1)은 정수 3을 실수 3.0으로 승격한 후 3.0과 3.1을 비교해 True를 반환한다.


<br/><br/>

### Q. 파이썬의 math 모듈은 아크 사인, 쌍곡선 사인, 시컨트 등 다른 삼각함수도 제공하는가?

**A.** 그렇다. 파이썬의 math 모듈은 역삼각함수와 쌍곡선 함수들도 제공한다. 그러나 math.sin(), math.cos(), math.tan()를 이용해 쉽게 계산할 수 있으므로 별도의 시컨트, 코시컨트, 코탄젠트 등의 함수는 제공하지 않는다. API에 어떤 함수를 포함시킬지 판단할 때는 필요한 모든 함수를 제공함으로써 얻어지는 편리함과 아주 긴 목록에서 필요한 함수를 찾아내는 번거로움 간의 적절한 조절이 필요하다. 어떤 것을 선택하더라도 모든 사용자를 만족시킬 수는 없고 파이썬은 만족시켜야 할 사용자가 아주 많다. 이미 API에 포함된 함수들 중에서도 중복되는 것은 아주 많다. 예를 들어 math.sin(x) / math.cos(x)를 간단히 계산할 수 있으므로 math.tan(x)는 필요 없다.

<br/><br/>

### Q. 객체에 바인딩되지 않은 변수에 접근하면 어떻게 되나?
**A.** 실행 시 파이썬이 NameError 예외를 발생시킨다.

<br/><br/>

### Q. 변수형은 어떻게 결정하나?

**A.** 상당히 까다로운 질문이다. 자바 등의 다른 프로그래밍 언어와 달리 파이썬 변수는 데이터 타입을 가지고 있지 않다. 대신 변수에 바인딩된 객체가 형을 가지고 있다. 다음 코드에서 보는 것처럼 하나의 변수에 여러 개의 다른 데이터 타입 객체를 바인딩할 수 있다. <br/><br/>
+그러나 하나의 변수에 서로 다른 형의 객체를 바인딩하는 것은 좋지 않은 생각이다.

<br/><br/>

### Q. 객체의 데이터 타입, 정체성, 값은 어떻게 알 수 있나?
**A.** 파이썬은 이런 용도에 사용하기 위한 내장 함수를 제공한다. type() 함수는 객체의 데이터 타입을, id() 함수는 객체의 정체성을, repr() 함수는 객체를 알아보기 쉽게 표현하는 문자열을 반환한다. <br/><br/>
+일반적으로 프로그래밍할 때는 이런 함수들이 필요치 않지만, 디버깅할 때는 상당히 유용하다.

<br/><br/>

### Q. =과 ==은 다른가?

**A.** 그렇다. 아주 다르다! = 연산자는 변수에 할당하는 연산을, == 연산자는 피연산자 두 개를 비교해 불형 결과를 생성한다. 

<br/><br/>

### Q. 표현식 `a < b < c`로 a, b, c가 순서대로 되어 있는지 검사할 수 있나?

**A.** 그렇다. 파이썬은 수학에서 널리 사용하는 방식에 따라 `a < b < c`처럼 비교 연산을 체이닝(chaining)할 수 있게 지원한다. 그러나 자바와 같은 다른 언어에서는 표현식 `a < b < c`는 잘못된 표현식이다. 먼저 하위 표현식 `a < b`를 평가해 불형 값을 평가하고 나서 이 불형 값을 숫자 c와 비교하는데, 불형 값과 숫자를 비교하는 것은 의미가 없기 때문이다. 그러나 이 책에서는 비교 연산자를 체이닝하지 않고, 표현식 `(a < b) and (b < c)`을 사용한다.

<br/><br/>

### Q. a = b = c = 17 문장은 변수 세 개를 모두 17로 설정하는가?
**A.** 그렇다. 파이썬 할당문은 표현식이 아니지만, 파이썬은 할당문들을 무한히 체이닝할 수 있게 해준다.

<br/><br/>

### Q. 불형이 아닌 피연산자에 논리 연산자 and, or, not을 사용할 수 있는가?
**A.** 사용할 수 있다. 논리 연산자를 만나면 파이썬이 0, 0.0, 빈 문자열은 False로, 그 외 정수, 실수, 문자열은 True로 간주하기 때문이다. 그러나 명료한 코드를 작성하고자 한다면 이런 성질은 사용하지 말기 바란다.

<br/><br/>

### Q. 불형 피연산자에 산술 연산자를 사용할 수 있는가?
**A.** 할 수 있기는 하지만, 좋지 않은 생각이다. 산술 연산자에 불형 피연산자를 사용하면 불형 피연산자가 승격되어 False는 0, True는 1이 된다. 예를 들어 (False - True - True) * True는 -2가 된다.

<br/><br/>

### Q. 내가 만든 변수에 max라는 이름을 붙일 수 있는가?
**A.** 할 수 있다. 그러나 max라는 이름의 변수를 정의하면 내장 함수 max()를 사용할 수 없다. min(), sum(), float(), eval(), open(), id(), type(), file() 등의 다른 내장 함수도 마찬가지다.

<br/><br/><br/><br/>

## 조건문과 반복문
- 프로그램에서 문장이 실행되는 순서를 제어 흐름(control flow)이라고 한다. 

<br/>

- 조건문(conditional)은 어떤 조건에 따라 다른 문장을 실행하거나 실행하지 않는 문장 
- 반복문(loop)은 어떤 조건에 따라 다른 문장을 여러 번 실행시킨다.

<br/><br/>

### if 조건문
- 입력에 따라 다르게 계산해야 하는 경우가 많다. 파이썬에서는 if 조건문을 이용해 경우에 따라 다르게 처리하는 부분을 표현할 수 있다.

```
if <불형 표현식>:
    <문장>
    <문장>
    ...
```

- 이 설명에서는 템플릿(template)이라고 하는 공식적인 표기법을 보여준다. 앞으로는 템플릿을 이용해 파이썬 구성자(construct)의 형식을 설명할 것이다. 홑화살괄호`(<>)` 안에는 이미 정의된 구성자가 들어가며, 그 자리에는 해당 구성자에 속하는 어떠한 것도 들어갈 수 있다. 앞에 설명에서 `<불형 표현식>`은 비교 연산 등 불 값으로 평가되는 표현식을 나타낸다. `<문장>`은 파이썬 문장을 나타내며, 각각의 `<문장>`은 서로 다른 문장이 될 수 있다. `<불형 표현식>`과 `<문장>`에 대해 공식적으로 정의를 내릴 수도 있지만, 이 책에서는 그 정도까지 깊이 들어가지는 않는다. if 조건문의 의미는 키워드 if로 자명하다. 파이썬은 `<불형 표현식>`이 참이 될 때에만 들여 쓴(indented) `<문장>`을 실행한다. 들여 쓴 문장들은 블록(block)이라고 한다. 블록은 들여 쓰지 않은 문장이 나올 때까지 계속된다. 대부분의 파이썬 프로그래머들은 들여 쓸 때 공백 문자 4개를 사용한다.

<br/>

- 간단한 예로 정수 x의 절댓값을 구하고 싶다고 생각해보자. 다음 코드가 바로 그 일을 해준다.
```
if x < 0:
    x = -x
```
- (엄밀히 말해 x가 참조하는 객체의 값이 음수이면 그 값의 절댓값을 가진 새로운 객체를 만들어 x가 그 객체를 참조하도록 변경하는 것이다.)

<br/>

![image](https://user-images.githubusercontent.com/61584142/160222091-dbf53e54-b80d-459b-89d0-2468b356477e.png)

- 왼쪽 코드는 한 문장을 블록으로 가진 if 조건문 뒤에 다른 문장이 온다. 
- 오른쪽 코드는 if 조건문이 두 문장을 블록으로 가진다. x가 0보다 크거나 같으면 두 코드는 모두 not negative를 출력한다. 
- 그러나 x가 0보다 작은 경우, 왼쪽 코드는 negative를 출력하지만 오른쪽 코드는 아무것도 출력하지 않는다.

<br/><br/>

### else 절 
- if 조건문에 else 절을 추가하면 불형 표현식이 참일 때 어떤 문장(이나 블록)을 실행하고, 아닐 때는 다른 문장을 실행하는 개념을 표현할 수 있다. else 절이 추가된 if 조건문의 구조는 다음 템플릿으로 표현할 수 있다.
```
if <불형 표현식>:
    <문장 블록>
else:
    <문장 블록>
```

<br/>

- else 절이 필요한 간단한 예를 보자. 다음 코드는 두 정수 중 큰 값을 변수 maximum에 할당한다(내장 함수 max()를 호출해도 똑같은 결과가 나온다).
```
if x > y:
    maximum = x
else:
    maximum = y
```

<br/>

#### if나 else 블록에 문장이 하나만 들어가는 경우에는 다음 표의 세 번째와 네 번째 예제처럼 문장을 if나 else 키워드와 같은 줄에 넣어 간략히 표현할 수 있다.

![image](https://user-images.githubusercontent.com/61584142/160222134-820dbb7e-5024-413d-b73a-627f170dfc8a.png)

<br/><br/>

### 순서도(flowchart)
- 순서도라고 하는 그림을 그리면 제어 흐름을 이해하기 쉽다. 순서도 화살표의 흐름은 프로그램의 제어 흐름에 해당한다. 프로그래머들이 저수준 언어를 사용하고 제어 흐름을 이해하기 어려웠던 컴퓨터 초창기에 순서도는 프로그래밍하는 데 중요한 역할을 담당했다. 최신 언어를 사용하는 요즘은 그저 if 조건문과 같은 기본 블록을 처음 공부할 때 사용할 뿐이다.

![image](https://user-images.githubusercontent.com/61584142/160222148-c80b344f-d898-49ad-a1df-6df64e2eacd4.png)

<br/><br/>

### while 반복문
- 본질적으로 반복되는 성질을 가진 계산 작업이 많다. 이런 반복 연산을 처리하기 위해 파이썬은 다음과 같은 구성자를 제공한다.

```
while <불형 표현식>:
    <문장 1> 
    <문장 2>
    ...
```

![image](https://user-images.githubusercontent.com/61584142/160222159-9ff816fc-8714-4e15-a12e-f4737b7a6712.png)

<br/>

- while 반복문은 if 조건문과 동일한 구조를 가지고 있지만(다만 키워드가 if에서 while로 달라졌을 뿐이다), 의미는 상당히 다르다. while 반복문은 `<불형 표현식>`을 평가해 False이면 아무런 일도 하지 않는다. `<불형 표현식>`이 True이면 (if 조건문과 마찬가지로) 문장 블록을 차례대로 실행하고 나서 `<불형 표현식>`을 다시 평가한다. 그러고 나서 `<불형 표현식>`이 True이면 다시 문장 블록을 실행하며, `<불형 표현식>`이 거짓이 될 때까지 문장 블록을 계속 실행한다. 
- 따라서 제어 흐름이 계속 `<불형 표현식>`으로 거슬러 올라간다. 이런 반복 구조는 순서도를 보면 잘 알 수 있다. 여기에서 while 반복문은 루프(loop), while 반복문 안에 있는 문장 블록은 루프 본체(loop body), `<불형 표현식>`은 루프-진행 조건(loop-continuation condition)이라고 한다. 일반적으로 루프-진행 조건에서는 어떤 변수의 값을 검사하므로, 변수의 처음 값을 설정하는 초기화(initialization) 코드가 while 루프 앞에 나오는 게 보통이다.

<br/>

#### while 반복문은 다음과 같이 if 조건문을 죽 나열한 것과 똑같다.
```
if <불형 표현식>:
    <문장 1>
    <문장 2>
    ...
if <불형 표현식>:
    <문장 1>
    <문장 2>
    ...
if <불형 표현식>:
    <문장 1>
    <문장 2>
    ...
...
```

![image](https://user-images.githubusercontent.com/61584142/160222204-261a8e5c-1cae-4bdd-80b5-e8ab09b3ef39.png)

- 루프 본체는 변수를 변경해 언젠가는 루프-진행 조건이 False로 평가되게 만들며, 루프-진행 조건이 거짓이 되면 루프 문이 종료된다.

<br/><br/>

**컴퓨터 과학에서는 2의 거듭제곱에 익숙하면 도움이 되는 때가 많으므로, 이 표에서 처음 10개까지의 값 정도는 암기하고 있어야 한다. 그리고 210은 천, 220은 백만, 230은 십억에 가까운 값이라는 것도 기억해두는 편이 좋다.

![image](https://user-images.githubusercontent.com/61584142/160222239-fceef7ec-c72e-404e-80cb-2aabefcddc81.png)

<br/><br/>

### 약식 할당문 표기법 
- 프로그래밍할 때 변수를 변경하는 것은 상당히 자주 수행하는 연산이므로 파이썬과 같은 최신 프로그래밍 언어들은 이런 용도에 맞는 약식 표기법을 지원한다. 특히 i = i + 1 형태의 할당문을 약식 표기법 i += 1로 간단히 표현하는 것은 흔히 볼 수 있다. 이 표기법은 `-, *, /` 등 다른 이진 연산자에도 동일하게 적용된다. <br/><br/>
- `power = 2 * power 대신 power *= 2`를 사용한다. 이런 약식 표기법은 1970년대 C 프로그래밍 언어와 함께 널리 사용되기 시작해 표준적인 표기법이 되었다. 프로그램이 간결하고, 우아하고, 이해하기 쉬워지므로 이런 약식 표기법은 오랜 검증 기간을 거쳐 살아남은 것이다. 지금부터 우리가 작성할 프로그램에서는 가능한 한 이와 같은 연산 할당문(augmented assignment statement)을 사용할 것이다.*

<br/><br/>

### for 반복문
- for 반복문은 while 반복문과 근본적인 차이가 있는 것은 아니지만, while 반복문을 사용할 때보다 더욱 간결하고 가독성 좋게 코드를 작성할 수 있게 해준다.

<br/>

- 앞에서 설명한 것처럼 반복 횟수를 추적하기 위해 정수 변수를 사용하는 루프를 만드는 경우가 많다. 초기에 어떤 정수를 변수에 할당한 후, 루프를 실행할 때마다 현재 값보다 하나 더 큰 값을 변수에 할당하고, 루프를 더 반복하기 전에 이 값이 사전에 설정한 최댓값을 넘었는지 확인한다. 이런 루프를 계수(counting) 루프라고 한다.

<br/>

#### 파이썬에서 while 반복문으로 구현하는 계수 루프는 다음과 같은 패턴을 가진다.

```
<변수> = <초깃값>
while <변수> < <종료 값>:
    <문장 블록>
    <변수> += 1
```

<br/>

#### 계수 루프는 for 반복문을 이용해 더 간결하게 구현할 수 있다. 
- 파이썬에서 for 반복문은 여러 형태로 사용할 수 있지만, 일단 지금은 다음과 같은 템플릿을 알아본다.
```
for <변수> in range(<초깃값>, <종료 값>):
    <문장 블록>
```

<br/>

#### for와 while 반복문의 사용 예시

![image](https://user-images.githubusercontent.com/61584142/160222488-a5682d68-084e-4281-a835-a5df4c80af62.png)

<br/>

- 내포 if, while, for 반복문은 파이썬에서 할당문이나 여타 문장과 동일한 지위를 가진다. 즉 어떤 문장이 필요한 곳이라면 어느 곳이든 if, while, for 반복문을 사용할 수 있다. 특히 다른 문의 본체 안에 이 문장들을 내포(nest)시킬 수 있다. 

<br/><br/>

### 몬테카를로 시뮬레이션
- 컴퓨터를 이용해 실세계에서 발생할 수 있는 일을 시뮬레이션함으로써 정보에 근거한 의사결정을 내릴 수 있게 해주는 상황을 잘 보여준다. 우리가 여기서 알아볼 예제는 도박꾼의 파산(gambler’s ruin)이라고 하는 잘 알려진 문제이다. 도박꾼이 얼마의 판돈으로 시작해 한 판에 $1씩 판돈을 낼 수 있다고 가정하자. 도박꾼은 결국엔 파산하기 마련이지만, 게임에 어떤 제한을 걸면 다양한 질문을 할 수 있다. 예를 들어 사전에 어떤 목표액을 설정해 이 금액에 도달하면 도박을 중단한다고 가정해보자. 도박꾼이 돈을 딸 확률은 얼마나 될까? 돈을 따거나 파산할 때까지 베팅을 몇 번 해야 할까? 도박하는 동안 도박꾼이 가질 수 있는 최대 판돈은 얼마나 될까?

<br/>

![image](https://user-images.githubusercontent.com/61584142/160223303-8486d7e1-103e-43db-94cc-ad20b998f2ea.png)

<br/>

- (gambler.py)에서 구현한 시뮬레이션은 이런 질문에 답할 수 있다. 이 프로그램은 random.randrange()를 이용해 각 베팅 결과를 시뮬레이션하고, 도박꾼이 파산하거나 목표액에 도달할 때까지 계속 진행하면서 진행한 판의 승패를 기록한다. 지정된 판 수까지 도박판을 시뮬레이션한 후에는 평균을 계산해 출력한다. 여러분은 명령 줄 인수를 바꿔가면서 프로그램을 실행해보고 싶을 것이다. 딱히 다음에 카지노에 갈 계획을 세우기 위해서라기보다는 다음과 같은 질문이 떠오르기 때문일 것이다.

    - 실제 도박할 때 시뮬레이션한 것처럼 결과가 나올까?
    - 정확한 답이 나오려면 도박을 몇 판 해야 하나?
    - 이런 시뮬레이션을 수행할 때 계산할 수 있는 한계는 얼마나 될까?<br/><br/>

- 시뮬레이션은 경제, 과학, 공학 분야에서 폭넓게 응용되며, 시뮬레이션할 때 이런 질문을 하는 것은 아주 중요하다.

<br/>

```
import random
import sys
import stdio
 
stake  = int(sys.argv[1])
goal   = int(sys.argv[2])
trials = int(sys.argv[3])
 
bets = 0
wins = 0
for t in range(trials):
    # 도박 한 판을 진행한다.
    cash = stake
    while (cash > 0) and (cash < goal):
    # 한 번의 베팅을 시뮬레이션한다.
        bets += 1
        if random.randrange(0, 2) == 0:
            cash += 1
        else:
            cash -= 1
    if cash == goal:
        wins += 1 
 
stdio.writeln(str(100 * wins // trials) + '% 이김')
stdio.writeln('평균 베팅 수: ' + str(bets // trials))
```

![image](https://user-images.githubusercontent.com/61584142/160223321-8be25a74-3030-433e-a678-a343feb86381.png)

- 이 프로그램은 명령 줄 인수로 초기 판돈(stake), 목표액(goal), 시도 횟수(trials)를 입력받는다. 도박판을 시도 횟수만큼 진행하며, 각 도박판은 초기 판돈으로 시작해 파산하거나 목표액에 도달할 때까지 계속 베팅하면서 진행한다. 그러고 나서 이길 확률과 도박 한 판에서 수행한 평균 베팅 수를 출력한다. 내부 while 루프에서는 도박꾼이 stake로 시작해 목표액에 도달하거나 파산할 때까지 $1 베팅하는 것을 시뮬레이션한다. 이 프로그램의 실행 시간은 전체 베팅 수(시도 횟수 * 평균 베팅 수)에 비례한다. 예를 들어 마지막 실험에서는 거의 난수를 1억 번 생성해야 했다.

<br/>

- gambler.py에서는 시뮬레이션 결과를 고전적인 확률 이론으로 검증해보면 돈을 딸 확률은 목표액에 대한 판돈 비율이며, 예상 베팅 수는 초기 판돈과 벌고자 하는 돈(목표액과 초기 판돈의 차액)의 곱에 비례한다. 예를 들어 도박장에 가서 $500를 $2,500로 만들고자 하는 경우, 성공률은 나쁘지 않지만(20%), $1 베팅을 백만 번 해야 한다. $1를 $1,000으로 만들고자 하는 경우, 성공률은 0.1%이며(대부분의 경우 파산한다) 돈을 따려면 (평균적으로) 999번 베팅해야 한다.<br/><br/>
- 시뮬레이션과 분석은 나란히 서로를 검증한다. 실제로 시뮬레이션 값은 분석하기 너무 어려워서 대답하기 어려운 문제에 대한 답을 제시한다. 예를 들어 백만 번이나 베팅할 시간이 없다는 걸 잘 아는 도박꾼은 베팅 수 한도를 사전에 설정하고자 할 것이다. 각각의 경우 도박꾼은 얼마만큼의 돈을 가져갈 수 있다고 예상할 수 있을까? 위의 코드를 수정하면 간단히 답할 수 있지만, 수학적으로 분석해 답을 구하기는 쉽지 않다.

<br/><br/>

### 소인수 분해
- 소수(prime number)는 1과 자신 이외의 다른 양수로는 나누어지 않는 1보다 큰 수를 말한다. 정수를 소인수 분해하면 여러 소수의 곱으로 표현된다. 예를 들어 3757208 = 2*2*2*7*13*13*397으로 분해할 수 있다. `factors.py`는 주어진 양의 정수를 소인수 분해한다. 우리가 지금까지 보아온 (계산기나 심지어 종이와 연필로 몇 분 만에 풀 수 있는) 문제들과는 반대로, 이렇게 큰 숫자는 컴퓨터 없이는 계산할 수 없다. 287994837222311같은 수의 소인수를 어떻게 찾아낼 수 있을까? 소인수 17은 간단히 찾을 수 있을지 모르지만, 계산기를 사용해도 1739347을 찾아내기까지는 상당한 시간이 걸린다.

<br/>

- factors.py는 짧고 간단하지만 모든 정수에 대해 원하는 결과를 출력할지 확신이 들기까지는 약간의 시간이 필요할 것이다. 늘 해오던 것처럼 바깥쪽 while 루프를 반복할 때마다 변숫값을 추적해보면 코드가 수행하는 부분을 이해하기 쉬울 것이다. n의 초깃값이 3757208인 경우, 내부 while 루프는 factor가 2일 때 3번, 3, 4, 5, 6일 때는 한 번도 반복되지 않는다. 3, 4, 5, 6은 469651을 나눌 수 없기 때문이다. 그러고 나서 factor를 계속 하나씩 증가시키면서 나눌 수 있는지 여부를 확인한다.

<br/>

```
import sys
import stdio
 
n = int(sys.argv[1])
 
factor = 2
while factor*factor <= n:
    while (n % factor) == 0:
        # 소인수로 나눈 후 소인수를 출력한다.
        n //= factor 
        stdio.write(str(factor) + ' ')
    factor += 1
    # n의 모든 소인수는 factor보다 크거나 같다.
 
if n > 1:
    stdio.write(n)
stdio.writeln()
```

![image](https://user-images.githubusercontent.com/61584142/160223372-9be84f19-bc1c-4757-963c-69c74d311d9e.png)
![image](https://user-images.githubusercontent.com/61584142/160223377-052d0ed0-5980-41d6-8bc4-a6f1b019ade3.png)

<br/>

- 몇 가지 입력을 예로 프로그램을 추적해보면 프로그램이 어떻게 돌아가는지 잘 알 수 있다. 모든 입력에 대해 이 프로그램이 원하는 대로 작동하는지 확신이 서려면 각각의 루프가 어떤 작업을 수행하는지 잘 생각해봐야 한다. 내부 while 루프는 n을 factor로 나누고 출력한다. 이 프로그램은 외부 while 루프가 반복되는 초기에 n은 2와 factor - 1로는 인수분해되지 않는다는 명제가 유지된다는 것을 알아야 이해할 수 있다. 따라서 factor가 소수가 아니면 n을 나눌 수 없다. factor가 소수이면 while 루프는 factor로 나누는 시도를 해보며, 이때도 명제는 유지된다. n은 n의 제곱근이나 제곱근보다 1만큼 작은 수로 인수분해되므로 factor * factor가 n보다 크면 루프를 중단한다.

<br/>

- 조금 더 원시적으로 구현해 외부 루프의 종료 조건을 `(factor < n)`이라고 했다면 아무리 빠른 최신 컴퓨터라 해도 인수분해를 시도할 엄청난 횟수 때문에 실행 시간이 오래 걸릴 것이다. 초당 수십억 번의 연산을 수행할 수 있는 컴퓨터에서 종료 조건이 `(factor*factor <= n)`인 경우 109번 나누는 연산은 몇 초면 끝나지만, 종료 조건이 `(factor < n)`인 경우 1018번 나누는 연산은 상당히 오래 걸린다. 루프를 이용하면 어려운 문제도 해결할 수 있지만, 간단한 프로그램도 실행 시간이 상당히 길어질 수 있으므로, 늘 성능 문제를 염두에 두어야 한다.

<br/>

- 암호화와 같은 최신 분야에서는 아주 큰 수(수백이나 수천 자리의 정수)를 소인수 분해해야 하는 것이 핵심이다. 전문가들이 빠른 컴퓨터를 사용하더라도 아직까지 이런 계산은 불가능에 가까울 정도로 어렵다.

<br/><br/>

### 중간 탈출 루프 
- 우리에게 필요한 루프가 for나 while 루프의 제어 구조에 딱 맞지 않는 경우가 종종 있다. 예를 들어 일련의 문장을 수행한 후 어떤 루프 종료 조건이 만족되면 빠져나가고, 그렇지 않으면 나머지 문장들을 실행하길 원하는 경우가 있을 수 있다. 즉 루프 제어 조건을 루프 시작 부분이 아니라 루프 중간에 두어야 하는 경우이다. 루프 종료 조건을 검사하기 전에 루프 일부를 실행해야 하므로, 이런 경우를 중간 탈출 루프(loop and a half)라고 한다. 파이썬에서는 루프를 처리 도중에 빠져나갈 수 있도록 break 문을 제공한다. 파이썬이 break 문을 만나면 가장 안쪽에 있는 루프를 바로 빠져나간다.

<br/>

- 예를 들어 단위 원판에 무작위로 분산된 점을 생성하는 문제를 생각해보자. random.random()을 호출해 x와 y 좌표로 사용하면 원점을 중심으로 가로세로 크기 2인 정사각형 안에 무작위로 분산된 점을 생성할 수 있다. 대부분의 점은 단위 원판 안에 들어갈 것이므로, 원 안에 들어가지 않는 점들만 버리면 된다. 그러나 적어도 점을 최소 하나는 생성해야 하므로 루프-진행 조건이 언제나 참인 while 루프를 만들어, 루프 안에서 2x2 정사각형 안에 들어가는 무작위점 (x, y)을 생성하고, 이 점이 단위 원판 안에 있으면 break 문을 이용해 while 반복문을 빠져나간다.

<br/>

- 중간에 탈출하는 루프에 대해서는 전문가들의 의견이 분분하다. 잘못 사용하면 break 문은 루프의 제어 흐름을 복잡하게 만들 수 있다. 그렇지만, 지금과 같은 문제에서 중간 탈출 루프 이외의 다른 방법을 사용하려면 코드가 복잡해진다. 이런 문제를 처리할 수 있도록 do-while 반복문을 제공하는 언어도 있다. 파이썬에서는 필요에 따라 break 문을 신중히 사용하기를 권장한다.

<br/><br/>

### Q. =과 ==은 어떻게 다른가?
**A.** 조건식에서 실제로 ==을 원하면서 =을 잘못 사용하지 않도록 여기에서 한 번 더 설명하기 위해 이 질문을 넣었다. x = y 문장은 y를 x에 할당하는 반면 x == y 표현식은 두 변수의 값이 같은지 검사한다. 이 차이점으로 커다란 문제가 발생하면서도 이 문제를 탐지하지 못하는 프로그래밍 언어들이 있다. 그러나 파이썬에서 할당문은 표현식이 아니다.

<br/><br/>

### Q. if, while, for 반복문에서 콜론을 빠트리면 어떻게 되는가?
**A.** 파이썬 컴파일러가 컴파일할 때 SyntaxError를 발생시킨다.

<br/><br/>

### Q. 문장 블록을 들여 쓰는 규칙에는 어떤 것이 있는가?
**A.** 블록 안의 문장들은 모두 동일하게 들여써야 한다. 그렇지 않으면 파이썬은 컴파일하는 동안 IndentationError를 발생시킨다. 일반적으로 파이썬 프로그래머는 한 단계 들여 쓸 때마다 공백 문자 네 개를 사용한다.

<br/><br/>

### Q. 탭 키를 이용해 코드를 들여 쓸 수 있는가?

**A.** 탭 키를 사용할 수 없다. .py 파일을 편집할 때는 탭 키로 들여 쓰지 않아야 한다. 그러나 탭 키로 들여 써서 프로그램을 작성하고, 프로그램을 저장할 때 탭 문자를 일련의 공백 문자로 바꿔주는 옵션을 가진 편집기들도 있다. 파이썬 프로그램을 작성할 때 이 옵션을 활용하는 것도 나쁘지 않다.

<br/><br/>

### Q. 긴 문장을 여러 줄에 걸쳐 작성할 수 있는가?
**A.** 할 수 있다. 그렇지만 파이썬이 들여쓰기를 처리하는 방식에 주의해야 한다. 여러 줄에 걸쳐 작성할 표현식이 괄호(나 대괄호, 혹은 중괄호) 안에 들어 있다면 특별히 더 해야 할 일은 없다. 예를 들어 다음은 세 줄에 걸친 하나의 문장이다.
```
stdio.write(a0 + a1 + a2 + a3 +
            a4 + a5 + a6 + a7 +
            a8 + a9)
```
그러나 괄호가 없다면 다음 코드처럼 연결된 각 문장의 끝에 역슬래시(</code>)를 사용해야 한다.
```
total = a0 + a1 + a2 + a3 + 

        a4 + a5 + a6 + a7 + 

        a8 + a9
```

<br/><br/>

### Q. 루프 안에 코드 일부를 건너뛰고 다음 반복으로 넘어가거나, 조건문 본체를 비워서 아무런 문장이 실행되지 않게 하고 싶다. 파이썬에서 이와 같은 것을 지원하는가?
**A.** 지원한다. 파이썬은 그런 용도로 continue와 pass 문을 제공한다. 그러나 이 문장이 필요한 경우는 상당히 드물다. 이 책에서는 이 문장들을 사용하지 않는다. 그리고 다른 언어에서는 상호배타적인 대안을 선택할 수 있도록 switch 문을 제공하지만 파이썬은 제공하지 않는다. 그리고 아무 데로나 이동해 제어 흐름 구조를 복잡하게 만드는 goto 문도 제공하지 않는다.

<br/><br/>

### Q. if나 while의 조건 표현식에 불형 이외의 표현식을 사용할 수 있는가?
**A.** 사용할 수 있지만, 좋은 생각은 아니다. 0이나 빈 문자열로 평가되는 표현식은 False로 간주되며, 그 외의 숫자 값이나 표현식은 True로 간주된다.

<br/><br/>

### Q. while 반복문은 안 되고 꼭 for 반복문을 써야 하는 경우가 있는가? 아니면 for 반복문은 안 되고 while 반복문을 써야 하는 경우는?
**A.** 앞에서 설명한 것처럼 while 반복문은 어떠한 루프라도 구현할 수 있지만, for 반복문은 유한한 정수열에 대해 반복하는 루프에만 사용할 수 있다. 

<br/><br/>

### Q. 내장된 range() 함수를 이용해 1이 아닌 다른 값만큼 건너뛰는 정수열을 생성할 수 있는가?
**A.** 할 수 있다. range()는 선택적으로 세 번째 인수 step을 제공한다. 따라서 `range(<시작>, <끝>, <간격>)`으로 호출하면 `<시작>, <시작>+<간격>, <시작>+2*<간격>, ...`의 정수열을 만든다. `<간격>`이 양수이면 `<끝>`보다 커지기 전까지, `<간격>`이 음수이면 `<끝>`보다 작아지기 전까지 간격을 더해간다. 예를 들어 range(0, -100, -1)은 0, -1, -2, ..., -99 정수열을 반환한다.

<br/><br/>

### Q. 실수를 range() 인수로 사용할 수 있는가?
**A.** 사용할 수 없다. 모든 인수가 정수형이어야 한다.

<br/><br/>

### Q. for 루프 안에서 루프 인덱스 변수의 값을 변경할 수 있는가?
**A.** 할 수 있다. 그러나 range()에 의해 생성된 정수열에는 영향을 미치지 못한다. 예를 들어 다음 코드는 0에서 99까지 100개의 정수를 출력한다.
```
for i in range(100):
    stdio.writeln(i)
    i += 10
```

<br/><br/>

### Q. for 루프를 마친 후 루프 제어 변수의 값은 어떻게 되는가?
**A.** 루프를 실행한 최종 상태의 값이 남아 있다. 앞에 나온 질문의 답에 있는 예제 코드의 경우 for 루프를 마치고 난 후의 i는 109이다. 그러나 for 루프를 종료하고 나서 루프 제어 변수를 사용하는 것은 좋지 않은 생각이다. 

<br/><br/><br/><br/>

## 배열
- 아주 많은 양의 데이터를 쉽게 저장하고 조작할 수 있게 해주므로, 여러 데이터처리 작업에서 핵심적인 역할을 담당한다. 배열은 수학과 과학 프로그래밍에서 널리 사용되는 벡터나 행렬에도 쉽게 대응된다. 

<br/>

- 데이터 구조(data structure)는 컴퓨터 프로그램으로 처리할 데이터를 조직화하는 방법이다. 데이터 구조는 컴퓨터 프로그래밍에서 핵심적인 역할을 담당이다.

<br/>

- 1차원 배열은 일련의 객체(에 대한 참조)를 저장한다. 배열 안에 있는 각 객체는 요소(element)라고 하며, 요소를 참조하기 위해서는 인덱스(index)를 사용한다. 배열 안에 n개의 요소가 있을 때 각 요소의 0부터 n-1까지의 인덱스를 가진다. 그러고 나서 이 범위 안에서 i 인덱스를 가진 요소는 i번째 요소라고 부름으로써 고유하게 식별할 수 있다.

<br/>

- 2차원 배열은 1차원 배열(의 참조)에 대한 배열이다. 1차원 배열의 요소는 정수 하나로 인덱싱할 수 있지만, 2차원 배열의 요소는 정수 두 개를 이용해 행과 열을 지정해 인덱싱한다.

<br/>

- 처리할 데이터가 아주 많을 때는 먼저 하나 이상의 배열에 데이터를 모두 집어넣는다. 그러고 나서 인덱스를 이용해 각 요소를 참조해 데이터를 처리한다. 시험 성적, 주가, DNA에 들어 있는 뉴클레오티드, 책에 들어 있는 글자들이 배열에 들어갈 수 있다. 이때 모두 동일한 데이터 타입의 객체가 아주 많이 배열에 들어가곤 한다. 

<br/><br/>

### 파이썬 배열
- 파이썬에서는 한 쌍의 대괄호 안에 콤마로 리터럴을 집어넣어 간단히 배열을 생성할 수 있다.

<br/>

#### 예를 들어 다음 코드는 4개의 문자열로 카드 한 벌을 만든다.
```
suits = ['Clubs', 'Diamonds', 'Hearts', 'Spades']
```

<br/>

#### 그리고 다음 코드는 각각 3개의 실수를 담고 있는 배열 x[]와 y[]를 만든다.
```
x = [0.30, 0.60, 0.10]
y = [0.40, 0.10, 0.50]
```

- 각 배열은 효율적으로 접근할 수 있또록 구조화된 데이터(실제로는 '구조화된 데이터 객체에 대한 참조')를 담고 있다. 실제 구조는 약간 복잡하지만 배열을 저장학 ㅗ있는 메모리 안에 각 요소에 대한 참조가 차례차례 연속적으로 저장된다고 생각하면 된다.

<br/>

- 배열을 사용하면 각 요소에 일일이 이름을 붙일 필요가 없다는 장점이 있다. 사실 배열 인덱스를 사용하는 것은 배열명에 인덱스를 합한 이름을 붙이는 것과 다름이 없다. 예를 들어 실수 8개를 처리할 때 a0, a1, a2, a3, a4, a5, a6, a7이라는 이름의 변수를 따로 만들 수도 있을 것이다. 그러나 수십 개의 변수명을 일일이 지정하는 것은 번거로우며, 수백만 개의 변수가 있을 때는 사실상 불가능하다.

<br/>

- 먼저 배열을 이용해 벡터를 표현하는 예를 살펴보자. 벡터는 3.3절에서 자세히 설명하지만, 일단 벡터는 일련의 실수라고 생각하자. 두 벡터의 스칼라곱은 같은 위치에 있는 요소들 간의 곱을 더한 것이다. 예를 들어 두 배열 `x[]`와 `y[]`가 벡터를 표현하고 있다면 스칼라곱은 `x[0]*y[0] + x[1]*y[1] + x[2]y[2]`이다. 이 표현식을 일반화해, 길이가 변수 n인 1차원 실수 배열 `x[]`와 `y[]`의 내적은 다음과 같이 for 루프를 이용해 구할 수 있다.

```
total = 0.0
for i in range(n):
    total += x[i]y[i]
```
- 이런 연산을 아주 간단히 표현할 수 있으므로 배열을 사용하는 것은 아주 자연스러운 선택이다. 

<br/><br/>

### 0-기반 인덱스 
- a[] 배열의 첫 번째 요소는 a[0], 두 번째 요소는 a[1]이다. 첫 번째 요소를 a[1], 두 번째 요소를 a[2]로 표기하는 게 더 자연스러워 보일 수 있지만, 인덱스를 0에서 시작하면 여러 장점이 있으므로 대부분의 최신 프로그래밍 언어들은 인덱스를 0에서 시작한다. 이 관례를 알고 있지 않으면 하나 차이 오류(off-by-one error)라고 불리는 디버깅하기 어려운 오류를 범하게 되므로, 이 관례에 주의하라!

<br/><br/>

### 배열 길이 
- 파이썬 내장 함수 len()을 이용해 배열의 길이를 구할 수 있다. len(a)는 a[] 배열의 길이를 반환한다. 따라서 a[] 배열의 마지막 요소는 언제나 a[len(a) - 1]임에 주의하라.

<br/><br/>

### 실행 도중 배열의 길이 늘리기 
- 파이썬에서는 += 연산자를 이용해 배열 뒤에 요소를 추가할 수 있다. 예를 들어 a[]가 [1, 2, 3]일 때 a += [4] 문장을 실행하면 배열을 [1, 2, 3, 4]로 만든다. 이 연산을 일반화해 다음과 같이 코드를 작성하면 각각이 0.0으로 초기화된 n개의 실수를 가진 배열을 만들 수 있다.

```
a = []
for i in range(n):
    a += [0.0]
```

- a = [] 문장은 빈 배열(길이가 0이고 요소가 하나도 없는 배열)을 생성하고 a += [0.0]은 요소 하나를 배열의 끝에 추가한다. 파이썬에서 이런 방식으로 배열을 생성하는 데 걸리는 시간은 배열의 길이에 비례하므로 주의해야 한다.

<br/><br/>

### 메모리 표현 
- 배열은 거의 모든 컴퓨터에서 메모리 시스템과 직접적인 연관이 있다는 점에서 핵심적인 데이터 구조체이다. 배열 요소에 대한 참조는 메모리에 연속적으로 저장되므로 배열 요소에 대한 접근은 간단하면서도 효율적이다. 사실 메모리 자체도 하나의 거대한 배열로 볼 수 있다. 최신 컴퓨터에서 메모리는 연속된 인덱스를 가진 하드웨어적 장치로 구현되므로, 인덱스를 적절히 사용하면 각각의 메모리 위치를 빠르게 접근할 수 있다. 컴퓨터 메모리를 이야기할 때 보통은 위치를 주소(address)라고 한다. 배열명을 배열 길이 및 요소에 대한 참조를 담고 있는 하나의 연속된 메모리 블록이라고 생각하면 편하다. 

![image](https://user-images.githubusercontent.com/61584142/160224065-b1d5d538-6661-45b8-82ec-1faac3ce0b47.png)

<br/>

- 이제 배열 x[]의 세 요소가 메모리 위치 523에서 526에 저장되어 있으며, 길이는 523에, 배열 요소에 대한 참조는 524에서 526에 저장되어 있다고 가정하자. 코드에서 x[i]로 접근하면 파이썬은 배열의 첫 번째 요소의 주소에 인덱스 i를 더하는 코드를 생성한다. 이 그림에서처럼 x[2]는 메모리 위치 524 + 2 = 526에서 객체에 대한 참조를 찾는 코드를 생성한다. 메모리와 배열, 색인이 아주 큰 경우에도 이런 간단한 방법을 효율적으로 적용할 수 있다. 배열의 i번째 요소의 참조에 접근할 때, 두 개의 정수를 더해 메모리를 참조하면 되므로 기본적인 연산 두 개만 수행해 상당히 효율적으로 접근할 수 있다.

<br/><br/>

### 경계 검사
- 배열을 이용해 프로그래밍할 때는 주의할 점이 있다. 배열 요소에 접근할 때 인덱스를 올바로 사용하는 것은 전적으로 프로그래머의 책임이다. 길이가 n인 배열을 만들고 나서 n-1보다 큰 인덱스를 사용하면 실행 시 프로그램에서 IndexError 예외가 발생한다(대부분의 프로그래밍 언어에서는 이런 버퍼 오버플로(buffer overflow) 조건을 시스템이 검사하지 않는다. 이와 같은 검사되지 않은 오류 때문에 디버깅하다 밤을 새기도 하지만, 이런 오류를 발견하지 못하고 최종 시스템에 들어가기도 한다. 이런 오류를 악용해 해커가 시스템 혹은 심지어 여러분의 PC의 제어권을 획득해 바이러스를 뿌리거나, 개인 정보를 훔치거나, 악의적인 행위를 할 수도 있다는 것을 알게 되면 깜짝 놀랄 것이다). 처음에는 이 파이썬 오류 메시지가 짜증나겠지만, 안전한 프로그램을 만드는 대가치고는 상당히 저렴한 비용이다.

<br/><br/>

### 가변성 
- 객체의 값을 변경할 수 있는 성질을 가변성(mutability)이라고 한다. 배열은 요소를 변경할 수 있으므로 가변 객체이다. 예를 들어 x = [.30,.60,.10] 코드로 배열을 생성하고 나서 x[1] = .99 할당문을 실행하면 배열의 값은 [.30, .99, .10]이 된다. 이 연산을 객체 수준 트레이스로 표현하면 아래 그림과 같다.

![image](https://user-images.githubusercontent.com/61584142/160224086-f32ae7a5-b69b-4623-9ce7-15a3909ad565.png)

<br/>

- 때로는 배열 안의 요소를 재배치하기도 한다. 예를 들어 다음 코드는 배열 a[]에 들어 있는 요소들을 역순으로 재배치한다.
```
n = len(a)
for i in range(n // 2):
    temp = a[i]
    a[i] = a[n-1-i]
    a[n-1-i] = temp
```
- for 루프 안의 세 문장은 1.2절에서 처음으로 할당문에 대해 배울 때 봤던 교환 연산을 구현한다. 이 코드를 일곱 개의 요소를 가진 [3, 1, 4, 1, 5, 9, 2] 배열에 적용할 때 요소들이 어떻게 바뀌는지 아래 표의 비공식 트레이스를 보면 이해하기 쉬울 것이다. 이 표에서는 for 루프를 반복할 때마다 i와 일곱 개의 요소가 어떻게 바뀌는지 추적한다.

![image](https://user-images.githubusercontent.com/61584142/160224102-9100e358-0c80-4288-b4f7-6345706ee1a3.png)

- 배열을 사용할 때는 당연히 값을 바꿀 수 있을 것이라고 생각하겠지만, 데이터 타입을 설계할 때 가변성은 중요한 문제이며 여러 가지 의미를 지닌다. 

<br/><br/>

### 반복
- 배열에서 가장 기본적인 연산 중의 하나는 요소들을 모두 반복(iterate)하는 것이다. 예를 들어 다음 코드는 실수 배열을 모두 반복해 평균을 구한다.

<br/>

```
total = 0.0
for i in range(len(a)):
    total += a[i]
average = total / len(a)
```
- 파이썬에서는 배열의 인덱스를 명시하지 않고도 요소를 반복하는 방법을 제공한다. 다음과 같이 for 반복문에서 in 키워드 다음에 배열명을 넣을 수 있다.

<br/>

```
total = 0.0
for v in a:
    total += v
average = total / len(a)
```
- 파이썬은 루프를 반복할 때마다 배열에 있는 각 요소를 루프 제어 변수 v에 할당하므로, 이 코드는 사실상 바로 앞에 나온 코드와 똑같다. 이 책에서는 앞에서 스칼라곱을 구하는 예제나 배열을 역순으로 재배치하는 예제처럼 인덱스를 이용해 배열 요소를 참조해야 하는 경우에는 인덱스를 이용해 반복한다. 평균을 구하는 이 예제처럼 인덱스가 아니라 요소의 순서만 중요한 경우에는 요소를 반복해도 된다.

<br/><br/>

### 내장 함수 
- 이미 사용해본 len() 함수처럼, 파이썬에는 배열을 인수로 받는 내장 함수가 많이 있다. 그 외 배열 a[]의 요소가 숫자일 때는 sum()으로 a[]의 합계를 구할 수 있다. 따라서 바로 앞 예제처럼 루프를 구현하지 않고도 간단히 float(sum(a)) / len(a)로 배열 a[]의 평균을 구할 수 있다. 그리고 배열을 min()과 max()에 인수로 전달해 배열 요소 중 최솟값과 최댓값을 간단히 구할 수도 있다.

<br/><br/>

### 배열의 출력 
- stdio.write()나 stdio.writeln()에 배열을 전달해 배열을 출력할 수 있다. 먼저 여는 `대괄호([)를 출력하고, 배열 요소 하나를 콤마와 공백으로 구분해 모두 출력한 후 닫는 대괄호(])`를 출력한다. 배열에 들어 있는 각 객체는 문자열로 변환되고, 이 모든 것을 한 줄에 출력한다. 이와 다른 형태로 출력하려면 for 반복문을 이용해 각 요소를 별도로 출력해야 한다.

<br/><br/>

### 배열 별명과 사본 
- 배열을 이용하는 프로그램을 살펴보기 전에 배열을 처리하는 핵심적인 두 가지 연산에 대해 자세히 살펴볼 필요가 있다. 여기에서 설명하는 내용의 핵심은 간단하지만, 상당히 중요하다. 

![image](https://user-images.githubusercontent.com/61584142/160224223-8828db54-f6b6-48e2-bb5f-d1975fb343b3.png)

<br/><br/>

### 별명
- 배열을 참조하는 변수는 다른 데이터 타입의 객체를 참조하는 변수와 똑같은 방법으로 사용할 수 있지만, 변수를 사용하는 방법이 미치는 영향을 이해하는 것은 아주 중요하다. 먼저 ‘배열 변수명을 할당문의 왼쪽에 놓으면 어떻게 될까?’하는 질문이 생길 수 있다. 즉 x[]와 y[]가 배열일 때 x = y 문장을 실행하면 어떤 영향을 미칠까? 답은 파이썬에서 다른 데이터 타입을 사용하는 경우와 마찬가지로 간단하다. x와 y가 동일한 배열을 참조한다. 그러나 이것은 예상치 못한 결과를 발생시킨다. 일단 x와 y가 독립적인 두 개의 배열을 참조한다고 생각하기 쉬운데, 사실은 그렇지 않다. 예를 들어 다음의 할당문들을 실행한 후, 코드에서는 y[1]을 직접 언급하지 않지만 y[1]의 값도 .99가 된다.

<br/>

```
x = [.30, .60, .10]
y = x
x[1] = .99
```

- 두 변수가 동일 객체를 참조하는 이런 상황을 별명(alias)이라고 한다.

<br/><br/>

### 복사와 슬라이싱 
- 그러면 ‘주어진 배열 x[]의 사본 y[]를 만들려면 어떻게 해야 할까?’하는 생각이 들 것이다. 사본 배열을 만들 때는 다음 코드처럼 배열 x[]를 반복해 배열 y[]를 만들 수 있다.

<br/>

```
y = []
for v in x:
    y += [v]
```
복사한 후 x[]와 y[]는 다른 배열을 참조한다. 즉 x[1]이 참조하는 객체의 값을 바꾸더라도 y[1]에는 영향을 미치지 않는다. 아래의 그림은 객체 수준 트레이스를 이용해 이 과정을 보여준다.

![image](https://user-images.githubusercontent.com/61584142/160224254-b38c6578-dae4-44f2-a57e-aa831df297ce.png)

<br/>

- 실제로 배열을 복사하는 작업은 많이 쓰이기 때문에 파이썬은 슬라이싱(slicing)이라고 하는 더욱 범용적인 복사 연산을 지원한다. 슬라이싱은 배열 안의 연속된 일정 부위를 다른 배열에 복사해준다. 표현식 a[i:j]를 평가하면 a[i], ..., a[j-1]을 요소로 하는 새로운 배열이 만들어진다. 게다가 i의 기본값은 0, j의 기본값은 len(a)이므로 y = x[:] 표현식은 앞에서 배열을 복사한 코드와 똑같은 작업을 수행한다. 표기법은 간단하지만, 이 간단해 보이는 코드가 실제로는 아주 비싼 연산이 될 수도 있다는 점을 명심해야 한다. 이 연산의 실행 시간이 x[]의 길이에 비례하기 때문이다.

<br/><br/>

### 파이썬 내장 리스트 데이터 타입 
- 가장 기본적인 형태로서 생성, 인덱스를 이용한 접근, 인덱스를 이용한 할당, 반복, 총 4가지 핵심 연산을 지원한다. 내장된 리스트 데이터 타입으로도 이런 기본적인 연산을 수행할 수 있으므로 이 책에서는 내장된 리스트 데이터 타입을 사용한다. 파이썬 프로그래머는 배열과 파이썬 리스트를 구분하지 않는다. 여기에서 구분하는 이유는 C나 자바 등의 다른 프로그래밍 언어에서 고정 길이 배열과 네 가지 기본 연산(배열 길이를 변경할 수 있는 연산은 지원하지 않는다)을 지원하는 기능을 내장하고 있기 때문이다.

<br/><br/>

### 파이썬 numpy 모듈
- 프로그래밍 언어를 설계할 때 간결함과 효율성의 적절한 타협점을 찾아야 한다는 것이 핵심이었다. 컴퓨터가 1초 동안 기본 연산을 엄청나게 많이 수행할 수 있어 보이지만, 실행 속도가 느리게 느껴지는 경우도 종종 있다. 파이썬의 경우 간단한 작업을 수행하는 프로그램에서도 내장된 리스트 데이터 타입이 성능에 심각한 문제를 일으킬 수 있다. 그렇기 때문에 과학자나 공학자들은 숫자로 구성된 아주 큰 배열을 처리하기 위해 numpy라는 파이썬 확장 모듈을 사용하곤 한다. 이 모듈은 표준 파이썬 리스트의 비효율적인 문제점을 해결한 저수준 표현 방식을 사용하기 때문이다. 

<br/><br/>

### 예제용 라이브러리의 stdarray 모듈 
- 앞에서 정수, 실수, 문자열, 불형을 읽고 쓰는 함수들을 정의한 stdio 모듈에 대해 소개했으며, stdio.write()와 stdio.writeln() 함수를 많이 사용해왔다. stdio 모듈은 도서 예제용 라이브러리에 포함된 모듈로서, 예제용 라이브러리는 이 책의 예제를 구현하기 위해 만든 비표준 모듈이다. 이제 예제용 라이브러리에서 제공하는 또 다른 모듈인 stdarray를 소개하고자 한다. stdarray 모듈은 이 책에서 사용할 배열을 처리하기 위한 함수들을 정의한다.

<br/>

- n개의 요소를 가진 배열을 생성하고 주어진 값으로 초기화하는 연산은 배열을 처리하는 거의 모든 프로그램에서 볼 수 있다. 이런 연산은 파이썬에서 다음과 같은 코드로 수행할 수 있다.

```
a = []
for i in range(n):
    a += [0.0]
```

- 주어진 길이의 배열을 생성하고 요소를 모두 어떤 값으로 초기화하는 연산은 아주 흔히 볼 수 있는 연산이므로 파이썬에서도 이를 위한 특별한 표기법을 지원한다. `a = [0.0]*n` 문장은 앞에 나온 코드와 똑같은 작업을 수행한다. 그런 지루한 코드를 반복해 사용하지 않도록 이 책에서는 다음과 같은 문장으로 배열을 생성하고 초기화한다.

```
a = stdarray.create1D(n, 0.0)
```

<br/>

- 일관성을 유지하기 위해 stdarray 모듈은 create2D() 함수도 제공한다. 이 함수에 대해서는 나중에 다시 설명할 것이다. 이 함수는 파이썬에서 숙어처럼 사용되는 구문을 반복 사용할 필요 없게 해주고 프로그래머의 의도를 명확히 알 수 있도록 코드 ‘자신을 문서화(self-documenting)’해주는 효과가 있기 때문에, 이 함수들을 사용한다.

<br/>

**파이썬 리스트를 간단히 배열이라고 부른다. 파이썬 리스트가 배열을 특징 짓는 핵심 연산(생성, 인덱스를 통한 접근, 인덱스를 통한 할당, 반복)을 지원하기 때문이다.

<br/>

![image](https://user-images.githubusercontent.com/61584142/160224311-b2d0f147-22b2-4288-bb7b-138d6334de71.png)

<br/><br/>

### 초기화 
- 파이썬에서 2차원 배열을 생성하는 가장 간단한 방법은 콤마로 구분된 1차원 배열을 한 쌍의 대괄호 안에 넣는 것이다. 예를 들어 다음의 정수 행렬은 2행 3열로 구성된다.

```
18 19 20
21 22 23
```

<br/>

- 이 행렬은 파이썬에서 다음과 같이 배열의 배열로 표현된다.

`a = [[18, 19, 20], [21, 22, 23]]`

<br/>

- 이런 배열은 2 x 3 배열이라고 한다. 관례적으로 첫 번째 차원은 행의 수, 두 번째 차원은 열의 수를 나타낸다. 파이썬은 2 x 3 배열을 3개의 객체를 가진 배열 객체 2개를 가진 배열로 표현한다. <br/><br/>
- 일반적으로 파이썬은 m x n 배열을 n개의 객체를 담고 있는 배열 객체 m개를 담고 있는 배열로 나타낸다. 예를 들어 다음 파이썬 코드는 m x n 크기의 실수 배열 a[][]를 만들어 모두 0.0으로 초기화한다.

<br/><br/>

### 인덱싱 
- 2차원 배열 a[][]에 대해 a[i]는 i 행을 참조한다. 예를 들어 a[][]가 [[18, 19, 20], [21 22, 23]] 배열이라면 a[1]은 [21, 22, 23]을 나타낸다. 2차원 배열에서 특정 요소를 참조할 때 a[i][j] 구문은 i 행 j열에 있는 요소를 참조한다. 앞의 a[][] 배열에서 a[1][0]은 21이다. 2차원 배열에서 모든 요소에 접근하려면 내포된 for 루프를 사용한다. 예를 들어 다음 코드는 m x n 크기의 a[][] 배열을 화면 한 줄에 한 행씩 모두 출력한다.

<br/>

```
for i in range(m):
    for j in range(n):
        stdio.write(a[i][j])
        stdio.write(’ ‘)
    stdio.writeln()
```

<br/>

- 다음 코드는 인덱스를 사용하지 않고 앞 코드와 똑같은 작업을 수행한다.

```
for row in a:
    for v in row:
        stdio.write(v)
        stdio.write(’ ‘)
    stdio.writeln()
```

<br/><br/>

### 스프레드시트 
- 숫자 테이블을 보관하기 위한 스프레드시트를 구현할 때도 배열이 널리 사용된다. 예를 들어 한 반에 있는 m명의 학생에게 n번의 시험을 보게 한 선생님은 학생들의 성적을 보관하기 위해 (m+1) x (n+1) 배열이 필요할 것이다. 마지막 열은 학생별 평균, 마지막 행은 반 평균을 위해 사용한다. 이런 계산은 보통 전문적인 스프레드시트 프로그램을 사용하지만, 우리는 배열 처리를 공부하고 있으므로 이 연산을 어떻게 배열로 구현하는지 알아보겠다. 한 학생의 평균 점수를 계산하려면 한 행의 평균을 구하면 되므로, 한 행의 값을 모두 더한 후 n(시험 횟수)으로 나누면 된다. 이 방식처럼 행렬을 한 행씩 처리할 때의 순서를 행 우선(row-major) 순서라고 한다. 이와 비슷하게 반 평균을 구하려면 각 열에 있는 모든 요소를 더해 m(학생 수)로 나누면 반 평균을 구할 수 있다. 이 방식처럼 행렬을 한 열씩 처리할 때의 순서를 열 우선(column-major) 순서라고 한다. 

![image](https://user-images.githubusercontent.com/61584142/160224387-bb9a4e2e-4a81-4f5e-83f2-d9cdb2bd7c9d.png)

<br/><br/>

### 행렬 연산 
- 과학과 공학에서 사용하는 애플리케이션들은 행렬을 2차원 배열로 표현하고 다양한 행렬 연산을 구현한다. 이런 연산은 일반적으로 특화된 애플리케이션이나 라이브러리를 이용해 처리하지만, 계산을 어떻게 구현하는지 알아 둘 필요가 있다.

<br/>

- 예를 들어 n x n 행렬 a[][]와 b[][]는 다음과 같이 행렬 덧셈을 구현할 수 있다.
```
c = stdarray.create2D(n, n, 0.0)
for i in range(n):
   for j in range(n):
       c[i][j] = a[i][j] + b[i][j]
```

<br/>

![image](https://user-images.githubusercontent.com/61584142/160224401-8e088397-6843-46e0-9696-91d73bbb5f31.png)

<br/>

- 마찬가지로 다음과 같이 행렬 곱셈을 구현할 수도 있다. 이미 수학 시간에 행렬 곱셈을 배웠겠지만, 잘 기억이 나지 않는다면 다음 파이썬 코드를 잘 살펴보길 바란다. 다음 코드에서 정방행렬을 곱하는 과정은 본질적으로 수학에서 정의한 과정과 똑같다. a[][]와 b[][]의 행렬곱 c[][]의 c[i][j]는 a[][]의 i행과 b[][]의 j열의 스칼라곱이다.

```
c = stdarray.create2D(n, n, 0.0)
for i in range(n):
    for j in range(n):
        # i행과 j열의 스칼라곱 계산
        for k in range(n):
            c[i][j] += a[i][k] * b[k][j]
```

- 이 정의는 정방행렬이 아닌 행렬에도 적용된다.

<br/><br/>

### 특이한 행렬 곱셈 
- 행렬 곱셈의 두 가지 특수 경우는 아주 중요한 의미를 지니고 있다. 이 특수 경우는 두 행렬 중 하나의 차원이 1일 때 발생하며, 그 행렬은 벡터라고 생각할 수 있다. 행렬-벡터 곱셈에서는 m x n 행렬과 열벡터(n x 1 행렬)를 곱해 m x 1 열벡터가 만들어진다(각 요소는 행렬의 해당 행과 벡터의 스칼라곱이다). 벡터-행렬 곱셈에서는 행벡터(1 x m 행렬)와 m x n 행렬을 곱해 1 x n 벡터가 만들어진다(각 요소는 벡터와 행렬의 해당 열의 스칼라곱이다).

![image](https://user-images.githubusercontent.com/61584142/160224419-bd4fe50d-76d2-4df2-8fa2-a3011862317d.png)

<br/>

- 이런 연산을 이용하면 여러 행렬 계산을 간단히 표현할 수 있다. 예를 들어 m행과 n열의 스프레드시트에서 각 행별 평균은 1.0/n 값을 n개 가진 열벡터와 행렬-벡터 곱으로 구할 수 있다. 마찬가지로 이 스프레드시트의 각 열별 평균은 1.0/m 값을 m개 가진 행벡터 벡터-행렬 곱으로 구할 수 있다.

<br/><br/>

### 비균일 배열 
- 사실 2차원 배열에서 모든 행의 길이가 같아야 하는 것은 아니다. 각 행의 길이가 서로 다른 행렬을 비균일 배열(ragged array)라고 한다. 2차원 배열에서 각 행의 길이가 다를 때는 더욱 조심해야 한다. 예를 들어 비균일 배열의 내용을 출력하는 코드는 다음과 같다.

```
or i in range(len(a)):
    for j in range(len(a[i])):
        stdio.write(a[i][j])
        stdio.write(’ ‘)
    stdio.writeln()
```

- 이 코드로 파이썬 배열을 얼마나 알고 있는지 테스트할 수 있다. 그러니 시간을 들여 자세히 공부하길 바란다. 이 코드에서처럼 len(a[i])를 사용하고 있다면 배열의 크기가 모두 같지 않을 수 있음을 나타낸다.

<br/>

- 다음 코드는 인덱스를 사용하지 않지만 앞 코드와 마찬가지로 일반 행렬이나 비균일 배열에서 제대로 작동한다.

```
for row in a:
   for v in row:
       stdio.write(v)
       stdio.write(’ ‘)
   stdio.writeln()   
```

<br/><br/>

### 다차원 배열
- 이와 같은 표기법을 확장해 다차원 배열을 이용하는 코드도 작성할 수 있다. 배열의 배열의 ...의 배열을 이용해 3차원 배열, 4차원 배열 등을 만들고 각 요소는 a[i][j][k]...와 같은 형태로 접근할 수 있다.

<br/>

- 2차원 배열은 행렬을 자연스럽게 표현하므로 과학, 수학, 공학 분야의 거의 모든 곳에서 볼 수 있다. 그리고 2차원 배열은 아주 많은 데이터도 자연스럽게 표현할 수 있기 때문에 스프레드시트 및 여러 계산용 애플리케이션에서 많이 사용된다. 직교 좌표를 통해 2차원과 3차원 배열은 실제 물리적인 세계를 모델링하는 기반이 된다.

<br/><br/>

- 배열은 거의 모든 프로그래밍 언어에서 할당문, 조건문, 반복문 다음으로 자주 나오는 기본적인 구성자이다. 이번 절에 나온 예제 프로그램을 통해 알아본 것처럼 이 구성자들만 이용해도 거의 모든 문제를 풀 수 있는 프로그램을 작성할 수 있다. 다음 절에서 설명할 다른 프로그램과의 통신 메커니즘까지 배우고 나면 기본적인 프로그래밍 메커니즘은 모두 익히게 되는 셈이다.

<br/>

- 우리가 접하는 많은 프로그램에서 가장 눈에 띄는 요소는 배열이며, 여기에서 설명한 기본 연산들은 여러 프로그래밍 작업에서 도움이 된다. 여러분이 작성한 코드에서 배열을 명시적으로 사용하지 않더라도 어디선가에서는 암묵적으로 배열을 사용하고 있다. 모든 컴퓨터에 있는 메모리는 개념적으로 배열과 대등하기 때문이다.

<br/>

- 배열이 프로그램에 끼친 핵심적인 영향은 프로그램의 상태(state) 규모가 엄청나게 커질 수 있다는 것이다. 프로그램의 상태는 프로그램이 어떤 일을 할지 판단하기 위해 알아야 할 정보로 정의할 수 있다. 배열이 없는 프로그램에서는 몇 가지 변수의 값과 다음에 수행할 문장들을 보면 대개의 경우 프로그램이 다음에 어떤 작업을 처리할 것인지 판단할 수 있었다. 프로그램을 추적할 때는 본질적으로 프로그램의 상태를 추적하는 것이다. 그런데 프로그램이 배열을 사용하면 너무 많은 값들(문장 하나로도 이 값 모두가 바뀔 수 있다)을 가지고 있어서 변수 전체를 효율적으로 추적할 수 없다. 이런 차이 때문에 배열을 사용하지 않는 프로그램보다 배열을 사용하는 프로그램을 작성하는 것이 훨씬 더 까다롭다.

<br/>

- 벡터와 행렬을 직접적으로 표현할 수 있으므로, 배열은 과학과 공학에서의 여러 기본적인 문제와 관련된 계산을 간단히 처리할 수 있다. 게다가 배열은 아주 많은 데이터를 동일한 방식으로 처리할 수 있는 간결한 표기법을 제공하므로, 엄청나게 많은 데이터를 처리하는 애플리케이션에서 핵심적인 역할을 수행한다. 

<br/>

- 무엇보다 중요한 점은 배열은 그저 빙산의 일각이라는 것이다. 배열은 데이터 구조의 첫 번째 사례로서, 데이터 구조는 데이터를 편리하고 효율적으로 처리하기 위해 데이터를 조직화할 수 있게 해준다. 4장에서 가변 길이 배열, 연결 리스트, 이진 검색 트리, 해시 테이블 등 더 많은 데이터 구조를 살펴본다. 그리고 배열은 컬렉션(collection)의 첫 번째 사례로서, 컬렉션은 많은 요소를 하나의 단위로 묶어준다.

<br/><br/>

### Q. 파이썬 배열 인덱스는 왜 1이 아니라 0에서 시작하는가?
**A.** 이런 관례는 기계어로 프로그래밍하던 시절에 생겨났다. 기계어로 프로그래밍할 때 배열 요소의 주소는 배열 시작 주소에 인덱스를 더해서 구한다. 인덱스를 1부터 시작하면 배열이나 문자열의 첫 번째 공간을 낭비하거나 매번 인덱스에서 1을 빼는 연산을 수행해야 하므로 CPU 처리 능력을 낭비하게 만든다.

<br/><br/>

### Q. 배열 인덱스에 음수를 사용하면 어떻게 되나?
**A.** 약간 놀라운 일이 생긴다. 배열 a[]가 있을 때 인덱스 -i는 len(a) - i의 단축 표기이다. 예를 들어 배열의 마지막 요소는 a[-1]이나 a[len(a) - 1]로, 첫 번째 요소는 a[-(len)a]나 a[0]으로 접근할 수 있다. -len(a)에서 len(a) - 1 이외의 인덱스를 사용해 배열에 접근하면 파이썬은 IndexError 예외를 발생시킨다.

<br/><br/>

### Q. 슬라이스 a[i:j]에 a[i]는 포함하지만 a[j]는 포함하지 않는 이유는?

**A.** 이 표기법은 왼쪽 끝은 포함하지만 오른쪽 끝은 포함하지 않는 range()에 정의된 범위와 일관성을 유지한다. 그리고 이러한 성질 때문에 여러 가지 매력적인 특성을 가진다. 예를 들어 j - i는 부분 배열(subarray)의 길이, a[0:len(a)]는 전체배열, a[i:i]는 빈 배열, a[i:j] + a[j:k]는 부분 배열 a[i:k]를 나타낸다.

<br/><br/>

### Q. (a == b)로 a[] 배열과 b[] 배열을 비교하면 어떻게 되나?
**A.** 경우에 따라 다르다. 숫자 배열(혹은 다차원 배열)의 경우에는 두 배열의 길이가 같고 해당 요소들이 서로 같을 때 참이 된다.

<br/><br/>

### Q. 배열을 사용할 때 주의할 점이 어떤 게 있나?
**A.** 배열을 생성할 때, 배열 길이 만큼의 시간이 걸린다는 점을 주의하라. 특히 루프 안에서 배열을 생성할 때 조심해야 한다.

<br/><br/><br/><br/>

## 입출력
- 파이썬 프로그램과 외부 세계 간의 인터페이스로 사용해왔던 간단한 장치(명령 줄 인수와 표준 출력)를 표준 입력, 표준 그래픽스, 표준 오디오로 확장한다. 표준 입력은 어떠한 크기든 데이터를 입력해 처리하는 프로그램을 작성하기 쉽게 해준다. 표준 그래픽스는 그림으로 표현된 이미지로 작업할 수 있게 함으로써 모든 것을 텍스트로 인코딩할 필요 없게 해준다. 표준 오디오는 프로그램에 사운드를 추가한다. 이 확장 모듈들은 사용하기 쉬우며 프로그래밍의 또 다른 세계로 안내한다.

<br/>

- I/O는 입력(input)과 출력(output)을 의미하는 약자로서 프로그램이 외부 세계와 소통하는 종합적인 메커니즘을 나타내는 집합적인 용어이다. 운영 체제는 컴퓨터에 연결된 물리적인 장치들을 제어한다. ‘표준 입출력’을 구현하기 위해서는 운영 체제에 밀접한 관련이 있는 함수를 제공하는 모듈을 사용한다.

<br/>

- 우리는 이미 명령 줄에서 인수를 입력받고 터미널 창에 출력하는 작업들을 해왔다. 이번 절에서는 데이터를 처리하고 표현하는 더욱 풍부한 도구들을 제공하고자 한다. 우리가 이미 사용해온 stdio.write()와 stdio.writeln() 함수처럼 입출력 함수들은 순수 수학적인 기능은 구현하지 않지만, 입력 장치나 출력 장치에 부가적인 작업을 수행한다. 우리는 주로 정보를 가져오고 내보내기 위해 이 장치들을 사용하는 데에만 관심을 갖는다.

<br/>

- 프로그램의 관점에서 보면 표준 입출력 메커니즘의 중요한 특징은 데이터의 입력이나 출력의 양에 제한이 없다는 것이다. 우리가 만든 프로그램은 무한히 입력을 소비하고 출력을 생산할 수 있다.

<br/>

- 표준 입출력 메커니즘은 프로그램을 컴퓨터의 외부 저장소에 있는 파일에 연결하기 위해 사용된다. 표준 입력, 표준 출력, 표준 그래픽스, 표준 오디오는 파일에 간단히 연결할 수 있다. 이렇게 연결함으로써 파이썬 프로그램이 결과를 보관하기 위해 파일에 저장하거나 읽어오고, 나중에 다른 애플리케이션이나 프로그램이 참조하기 쉽게 해준다.

<br/>

- 파이썬 프로그램은 명령 줄에서 입력 값을 받고 문자열을 출력으로 내보낸다. 기본적으로 명령 줄 인수와 표준 출력은 명령(python3 명령 뒤에 입력한 프로그램)을 받는 애플리케이션에 연결되어 있다. 이 애플리케이션은 일반적으로 터미널 창이라고 한다. 이 모델은 우리가 만든 프로그램과 데이터를 이용하기 위한 편리하고 직접적인 방법을 제공한다.

<br/><br/>

### 명령 줄 인수 
- 프로그램에 데이터를 입력하기 위해 사용해온 이 메커니즘은 파이썬 프로그래밍에서의 표준적인 부분이다. 운영 체제는 파이썬 프로그램에 입력한 명령 줄 인수를 sys.argv[]라는 이름의 배열에 넣어준다. 관례적으로 파이썬과 운영 체제는 인수를 문자열로 다루므로, 인수를 숫자로 사용하려면 int()나 float()를 이용해 문자열을 적절한 숫자로 변환해야 한다.

<br/><br/>

### 표준 출력 
- 프로그램에서 값을 출력하기 위해 우리는 예제용 라이브러리에서 제공하는 stdio.write()와 stdio.writeln() 함수를 사용해왔다. 파이썬은 이 함수를 호출한 결과를 표준 출력이라고 알려진 문자열의 추상화된 형태로 변환한다. 기본적으로 운영 체제는 표준 출력을 터미널 창에 연결한다. 지금까지 프로그램의 모든 출력은 터미널 창에 나타났다.

<br/><br/>

### 표준 입력 
- 예제용 라이브러리의 stdio 모듈은 write()와 writeln() 외에도 표준 출력에 대응해 표준 입력을 추상화하는 여러 함수를 제공한다. 즉 stdio 모듈은 표준 입력으로부터 데이터를 읽을 수 있게 해주는 함수도 제공한다. 프로그램을 실행하는 도중에 언제라도 표준 출력에 데이터를 출력할 수 있는 것처럼 프로그램 실행 도중 언제라도 표준 입력 스트림에서 데이터를 읽을 수 있다.

<br/><br/>

### 표준 그래픽스
- 예제용 라이브러리에 있는 stddraw 모듈을 이용하면 프로그램에서 그림을 그릴 수 있다. 간단한 그래픽 모델을 이용해 컴퓨터 화면에 점, 선, 기하학적 도형을 그릴 수 있게 해 줄 뿐만 아니라 텍스트, 색상, 애니메이션 기능도 제공한다.

<br/><br/>

### 표준 오디오 
- 예제용 라이브러리 stdaudio 모듈에는 프로그램에서 사운드를 생성하고 조작할 수 있게 해준다. 표준 서식을 이용해 정수 배열을 사운드로 변환한다.

<br/><br/>

### 파이썬 프로그램에 대한 조감도

![image](https://user-images.githubusercontent.com/61584142/160225048-b38998ad-aa13-4686-8cc6-5ab7957caef6.png)

- 이 모듈을 사용하려면 파이썬에서 stdio.py, stddraw.py, stdaudio.py 모듈을 사용하게 만들어야 한다(이번 절 뒤에 나오는 Q&A를 참조하라).

<br/>

- 표준 입력과 출력 추상화는 1970년대 유닉스 운영 체제를 개발하면서 정립된 개념으로서 최신 운영 체제에서도 여러 형태로 제공된다.

<br/>

- 표준 입출력 추상화는 이후에 개발된 여러 메커니즘에 비해 원시적이지만, 최신 운영 체제에서 개발하는 프로그래머들도 프로그램에 데이터를 연결하는 듬직한 방법으로서 여전히 표준 입출력에 의존한다. 앞에서 이미 살펴본 예제용 라이브러리 함수들과 마찬가지로 stddraw와 stdaudio는 시각적인 내용과 사운드 출력을 쉽게 생성할 수 있도록 만들었다.

<br/><br/>

### 표준 출력에 관련된 예제용 라이브러리 함수

![image](https://user-images.githubusercontent.com/61584142/160225069-1df449b1-276f-4569-8d87-ccf186ed4e07.png)

- 실수를 화면에 출력해오면서 지금까지 소수점 이하 자리가 너무 길게 출력되어 보기에 불편했다. 예를 들어 일반적으로 𝜋를 3.14나 3.14159라고 출력하고 싶은데, stdio.write(math.pi)를 호출하면 3.141592653589793이 출력된다. stdio.write()와 stdio.writeln() 함수는 소수점 이하 몇 자리만 보여줘도 충분한 경우에도 최대 16자리까지 출력한다. stdio.writef() 함수는 융통성이 높아서 숫자 객체를 출력하기 위해 문자로 변환할 때 자릿수와 정밀도를 지정할 수 있게 해준다. 예를 들어 stdio.writef('%7.5f', math.pi)를 호출하면 3.14159가 출력된다.

<br/><br/>

### 서식을 사용하는 출력 기초 
- 가장 간단한 형태의 stdio.writef()는 인수를 하나만 가지며, 이때 stdio.writef()는 사실상 표준 출력 장치에 stdio.write()와 똑같이 출력한다. 일반적으로 stdio.writef()는 두 개의 인수를 가진다. 이때 첫 번째 인수는 서식 문자열(format string)이라고 하며, 서식 문자열에 들어 있는 서식 지정자(format specifier)는 두 번째 인수를 어떤 문자열로 변환할지 명시한다. 서식 지정자는 %w.pc 형태로 되어 있으며, 숫자 w와 p 및 문자 c는 다음과 같이 해석된다.

![image](https://user-images.githubusercontent.com/61584142/160225082-43194173-b805-4724-b928-8d9d2ffdb64e.png)

<br/>

    - w(필드 너비): 출력할 문자열의 길이를 나타낸다. 출력할 문자열의 길이가 필드 너비보다 크면 필드 너비를 무시하고, 작으면 왼쪽을 공백 문자로 채운다. 필드 너비를 음수로 지정하면 출력 문자열의 오른쪽을 공백 문자로 채운다.
    - p(정밀도): 실수의 경우 소수점 이하에 출력될 숫자의 개수를 지정한다. 문자열의 경우 출력할 문자의 개수를 지정한다. 정수에는 사용하지 않는다.
    - c(변환 코드): 정수로 변환할 때는 d, 실수는 f, 실수를 과학적 표기법으로 변환할 때는 e, 문자열은 s를 지정해야 한다.

<br/>

- 서식 지정자에서 필드 너비와 정밀도는 생략할 수 있지만, 변환 코드는 반드시 지정해야 한다.

<br/>

- 파이썬은 서식 지정자의 명령에 따라 두 번째 인수를 변환할 수 있어야 한다. 모든 데이터 타입은 str() 함수를 통해 문자열로 변환할 수 있으므로, 변환 코드 s에 대해서는 제한이 없다. 그러나 이와 반대로 stdio.writef('%12d', 'Hello')는 문자열을 정수로 변환할 수 없으므로 실행 시 TypeError 예외를 발생시킨다. 서식 지정자를 사용하는 예는 아래의 표를 참조하라.

![image](https://user-images.githubusercontent.com/61584142/160225108-c138a29f-4465-4c30-98db-f520113798a0.png)

- 서식 문자열에서 서식 지정자가 아닌 부분은 표준 출력 장치에 그대로 출력된다. 예를 들어 stdio.writef('pi의 값은 대략 %.2f\n이다.', math.pi) 문은 다음과 같이 출력한다.

```
pi의 값은 대략 3.14이다.
```

- stdio.writef()를 사용할 때는 줄을 바꾸려면 개행 문자(\n)를 명시적으로 지정해야 한다.

<br/><br/>

### 다중 인수
- stdio.writef() 함수를 호출할 때는 인수가 세 개 이상일 때도 있다. 이때 서식 문자열 안에 있는 서식 지정자는 콤마로 구분된 각각의 인수에 대응된다. 예를 들어 sqrt.py(프로그램 1.3.6)에 있는 stdio.write(t)를 stdio.writef('%.1f의 제곱근은 %.6f이다.', c, t)로 바꾸면 다음과 같이 출력된다.

```
2.0의 제곱근은 1.414214이다.
```

<br/>

- 더 자세한 예로 대출금을 갚을 때 다음과 같이 루프 안에서 월별로 대출금, 잔액, 이자를 출력하는 코드를 작성할 수 있다.

```
format = '%3s $%6.2f $%7.2f $%5.2f\n'
stdio.writef(format, month[i], pay, balance, interest)
```

- 이 문장을 이용하면 다음과 같은 표의 두 번째 이후 줄을 출력할 수 있다.

```
     상환액   잔액      이자
Jan  $299.00  $9742.67  $41.67 
Feb  $299.00  $9484.26  $40.59 
Mar  $299.00  $9224.78  $39.52 
 ...
```
<br/>

- 문자열을 일일이 연결해 출력 문자열을 생성하는 것보다 코드가 훨씬 더 간단해지기 때문에 문자열을 서식해 출력하는 것이 더 편리하다.

<br/><br/>

### 표준 입력 
- 예제용 라이브러리 stdio 모듈에는 표준 입력 스트림에서 데이터를 가져오는 함수가 몇 가지 있다. 표준 입력 스트림에는 공백 문자(빈칸, 탭, 개행 문자 등)로 구분된 일련의 값이 들어 있다. 각각의 값은 정수, 실수, 불형, 혹은 문자열을 나타낸다. 프로그램이 데이터를 읽을 때 표준 입력 스트림을 소비하며, 값을 한 번 읽고 나면 다시 읽을 수 없다. 이 가정 사항은 제약으로 들릴 수도 있지만, 입력 장치의 물리적 특성을 잘 반영하여 추상화하고 있으며, 이 추상성을 쉽게 구현할 수 있게 해준다. stdio 모듈은 표준 입력 장치에서 데이터를 읽는 13개의 API를 제공한다. 이 함수들은 다음과 같이 세 가지 종류로 분류할 수 있다.

<br/>

    - 개별 토큰을 한 번에 하나씩 읽고 정수, 실수, 불형, 문자열로 변환하는 함수
    - 표준 입력 장치에서 한 번에 한 줄씩 읽는 함수
    - 같은 데이터 타입의 값을 한꺼번에 읽어 배열을 반환하는 함수

<br/>

- 일반적으로 하나의 프로그램에서 서로 다른 종류의 함수를 섞어서 사용하는 것은 좋지 않다. 입력 스트림 모델에 따라 이 함수들은 이름만으로도 수행하는 작업을 충분히 알 수 있지만, 정확히 어떻게 수행되는지 생각해볼 필요가 있으므로 몇 가지 예를 자세히 살펴보자.

![image](https://user-images.githubusercontent.com/61584142/160225188-9d9eabde-d9fd-4750-b376-17f7a48254ed.png)

<br/><br/>

### 키보드로 입력하기 
- 명령 줄에서 python3 명령으로 파이썬 프로그램을 실행할 때 다음의 세 가지 작업이 수행된다.
    - 1 명령을 호출해 파이썬 프로그램을 실행한다.
    - 2 명령 줄 인수의 값을 명시한다.
    - 3 표준 입력 스트림을 정의한다.

<br/>

- 명령을 실행한 후 터미널 창에서 입력하는 문자들은 표준 입력 스트림이 된다. 문자를 입력하면 프로그램에 연결된다. 프로그램은 사용자가 표준 입력 스트림을 생성하기를 기다린다. 예를 들어 다음의 addints.py 프로그램은 명령 줄 인수로 정수 n을 입력받은 후, 표준 입력 스트림에서 n개의 정수를 입력받아 합계를 구한 후 표준 출력 스트림에 출력한다.

```
import sys
import stdio
 
n = int(sys.argv[1])
total = 0
 
for i in range(n):
    total += stdio.readInt()
 
stdio.writeln('합계: ' + str(total))
```

<br/>

![image](https://user-images.githubusercontent.com/61584142/160225216-b42ab41e-29c5-447f-8cfb-5a4c54846272.png)

<br/><br/>

### 모든 크기의 입력 스트림 처리하기 
- 일반적으로 입력 스트림은 유한하다. 프로그램이 입력 스트림을 읽으면서 스트림을 소진할 때까지 값을 가져온다. 그러나 입력 스트림에는 크기 제한이 없으며, 그저 입력 스트림을 모두 처리하는 프로그램도 있다. 다음 예제인 average.py(프로그램 1.5.3)는 표준 입력 스트림에서 일련의 실수를 읽고 이 숫자들의 평균을 출력한다. 이 프로그램은 프로그램에서 크기를 미리 알 수 없는 입력 스트림의 속성을 잘 보여준다. 사용자는 그저 필요한 만큼의 숫자를 모두 입력할 뿐이며, 프로그램은 평균을 계산할 뿐이다. 각 숫자를 읽기 전에 프로그램은 stdio.isEmpty()를 호출해 입력 스트림에 숫자가 더 있는지 검사한다.

<br/>

- 더 이상 입력할 데이터가 없다는 것은 어떻게 알려줄까? 관습에 따라 파일 끝(end-of-file)이라고 알려진 특별한 키 조합을 입력한다. 불행히도 우리가 일반적으로 접하는 운영 체제의 터미널 애플리케이션마다 이 키 조합은 다르다. [Ctrl]-[Z]를 파일 끝 문자로 사용하는 터미널 애플리케이션도 있지만, 이 책에서는 [Ctrl]-[D]를 이용해 파일 끝을 표시하겠다.

<br/>

- 그런데 표준 입력 스트림에서 일일이 숫자를 입력하는 경우는 거의 없다. 표준 입력을 이용하면 무한한 크기의 데이터를 처리하는 프로그램을 작성할 수 있다는 점이다. 나중에 알게 되겠지만 수많은 데이터를 처리하는 애플리케이션을 작성할 때 이 방법은 상당히 효율적이다.

<br/>

#### 일련의 숫자 평균 구하기(average.py)

![image](https://user-images.githubusercontent.com/61584142/160225314-9c83a3ac-310d-4e94-a6d2-05cc65aa6f72.png)

<br/><br/>

### 필터 
- 원래 1970년대 초반 유닉스 시스템에서 제공하던 핵심 기능인 파이프는 개별 프로그램들이 쉽게 통신할 수 있게 해주므로 최신 운영 체제에서도 살아남았다. 오늘날까지 사용되고 있는 수많은 유닉스 프로그램들이 원래 프로그램의 개발자가 상상했던 것보다 수백만 배나 더 큰 파일도 처리하고 있다는 사실은 이 기능이 얼마나 막강한지 잘 보여준다. 함수를 호출해 다른 파이썬 프로그램과 통신할 수 있지만, 표준 입력과 표준 출력은 다른 시기에 다른 언어로 작성된 프로그램과도 통신할 수 있게 해준다. 표준 입력과 표준 출력을 사용하면 외부 세계와 쉽게 연결할 수 있다.

<br/>

- 일반적으로 표준 입력을 표준 출력 스트림으로 변환하는 프로그램은 필터, 두 프로그램을 연결하는 메커니즘은 파이프라고 생각하면 된다. 예를 들어 rangefilter.py(프로그램 1.5.4)는 명령 줄 인수 두 개를 입력받아 지정된 범위에 속한 숫자들만 표준 출력 장치에 출력한다. 표준 입력 스트림은 어떤 장치에서 들어온 측정 데이터이며, 현재 실험에서 분석하지 않을 데이터를 제거하기 위해 필터를 사용한다고 생각할 수 있다.

<br/>

```
import sys
import stdio


lo = int(sys.argv[1])
hi = int(sys.argv[2])



while not stdio.isEmpty():
    # 정수 하나를 처리한다.
    value = stdio.readInt()
    if (value >= lo) and (value <= hi):
          stdio.write(str(value) + ’ ‘)
stdio.writeln()
```

- 이 프로그램은 명령 줄 인수로 정수 lo와 hi를 입력받고, 파일 끝에 도달할 때까지 표준 입력에서 정수를 읽어 lo와 hi 범위(lo와 hi 포함)에 있는 숫자를 출력한다. 따라서 이런 프로그램을 필터라고 한다. 스트림의 길이에는 제한이 없다.

<br/>

![image](https://user-images.githubusercontent.com/61584142/160225361-2453f23d-e59a-4862-8c23-8c7868655788.png)
![image](https://user-images.githubusercontent.com/61584142/160225363-1493b235-f168-4c14-81f0-acd29ed26eea.png)

<br/>

- 그 외 유용한 필터로 more가 있는데, more는 표준 입력 스트림(혹은 명령 줄 인수로 지정한 파일)에서 데이터를 읽어 터미널 창에 한 번에 한 화면씩 출력한다. 예를 들어 다음 명령을 입력하면 터미널 창에 난수를 화면을 가득 채울 때까지 출력하고 나서, 사용자가 [Space] 키를 누른 후에 그다음 화면을 보여준다.

```
% python3 randomseq.py 1000 | more
```

<br/>

- 필터라는 용어는 약간 오해의 소지가 있다. 원래는 rangefilter.py 프로그램처럼 표준 입력에서 읽은 데이터를 걸러내 표준 출력 스트림으로 보내기 위한 것이었지만, 이제는 표준 입력 스트림에서 데이터를 읽어 표준 출력 스트림으로 내보내는 모든 프로그램을 의미하는 용어로 사용된다.

<br/><br/>

### 다중 스트림 
- 여러 소스에서 입력받거나 여러 목적지로 출력하는 프로그램이 필요한 경우도 종종 있다.

<br/>

- 대량의 정보를 처리하는 것이 핵심인 컴퓨터 애플리케이션이 많이 있다. 과학자들은 여러 실험에서 수집한 데이터를 분석하고, 증권 전문가는 최근의 금융 거래에 대한 정보를 분석하고, 학생들은 음악과 영화 파일들을 관리하고 싶어 한다. 이런 작업에는 데이터-주도 프로그램이 표준이다. 표준 출력, 표준 입력, 리다이렉션, 파이프는 이런 작업을 파이썬 프로그램으로 할 수 있게 해준다. 웹이나 표준적인 장치를 통해 수집한 데이터를 파일에 저장하고 이 데이터를 리다이렉션과 파이프를 이용해 자신들이 작성할 프로그램에 연결한다.

<br/><br/>

### 표준 그래픽스 
- 지금까지 텍스트의 입출력에 대해 자세히 살펴보았다. 이제 그림을 출력으로 생성하는 방법에 대해 알아보자. 이 모듈은 사용하기 쉬우며 텍스트만 사용할 때보다 훨씬 더 많은 정보를 전달할 수 있는 시각적인 매체를 활용한다.

<br/>

- 표준 그래픽스는 매우 간단하다. 2차원 캔버스에 선과 점을 그리고 이 ‘캔버스’를 표준 그래픽스 창에 출력할 수 있는 추상적인 장치를 생각하면 된다. 이 장치는 프로그램에서 stddraw 모듈에 있는 함수를 호출해 실행한 명령에 응답한다.

<br/>

#### stddraw 모듈의 API는 다음과 같이 두 가지 함수로 분류된다.
- 그림 함수: 선이나 점을 그리는 등 장치가 어떤 행동을 하게 만든다.
- 제어 함수: 그림을 보여주는 방식을 제어하거나 펜 굵기나 좌표 배율 등 파라미터를 설정한다.

<br/>

#### 그림 생성
- 기본적인 그림 함수의 API는 아래 표와 같다. 표준 입출력 함수와 마찬가지로 그래픽스 함수도 함수명을 보면 하는 일을 쉽게 짐작할 수 있다. stddraw.line() 함수는 인수로 받은 두 점을 연결하는 직선을 그리고 stddraw.point()는 주어진 위치에 점을 찍는다. 표준 좌표 배율은 단위 정사각형이다(즉 모든 좌표는 0과 1 사이에 들어간다). 점(0.0, 0.0)은 왼쪽 아래, 점(1.0, 1.0)은 오른쪽 위로서, 우리에게 익숙한 직교 좌표계의 일사분면에 해당된다. 흰색 바탕에 검은 선과 점이 기본 그래픽 설정이다.

![image](https://user-images.githubusercontent.com/61584142/160225421-4d38b825-fa3a-41de-9508-9512e8308e24.png)

<br/>

#### 제어 함수
- stddraw.show()는 설명이 약간 더 필요하다. 프로그램이 stddraw.line()이나 stddraw.point() 등 그림 함수를 호출하면 stddraw는 배경 캔버스(background canvas)라고 하는 추상적인 화면에 그린다. 배경 캔버스는 화면에 보이지 않고 단지 컴퓨터 메모리에만 존재한다. 점, 선 등은 배경 캔버스에 그려지며 표준 그래픽스 창에 바로 나타나지 않는다. stddraw.show()를 호출해야 배경 캔버스에 그린 그림이 표준 그래픽스 창으로 복사되어 화면에 나타나며, 사용자가 그래픽 창 제목 줄의 닫기 버튼을 눌러 표준 그래픽스 창을 닫아야 종료된다.

<br/>

- stddraw가 배경 캔버스를 사용하는 이유는 무엇일까? 캔버스를 하나가 아니라 두 개를 사용하는 이유는 stddraw를 효율적으로 만들기 위해서이다. 복잡한 그림의 요소를 하나씩 그리는 작업은 대부분의 컴퓨터에서 참을 수 없을 정도로 비효율적인 작업이기 때문이다. 컴퓨터 그래픽스에서는 이런 방법을 이중 버퍼링(double buffering)이라고 한다.

<br/>

##### stddraw 모듈을 사용하는 프로그램은 일반적으로 다음과 같은 구조로 되어 있다.
    - stddraw 모듈을 임포트한다.
    - stddraw.line()과 stddraw.point() 등의 그림 그리기 함수를 이용해 배경 캔버스에 그림을 그린다.
    - stddraw.show()를 호출해 배경 캔버스를 표준 그래픽스 창에 보여주고 사용자가 창을 닫을 때까지 기다린다.

<br/>

- 모든 그림은 배경 캔버스로 간다는 점을 반드시 기억하라. 일반적으로 그림을 그리는 프로그램은 마지막에 stddraw.show()를 호출한다. stddraw.show()를 호출해야 화면에서 그림을 볼 수 있기 때문이다.

<br/>

### 그림 저장 
- 표준 그래픽스 창을 파일에 저장해 그림을 인쇄하거나 다른 사람과 공유할 수 있다. 파일로 저장하려면 캔버스 창 아무 곳이나 마우스 우클릭하라(프로그램에서 stddraw.show() 함수를 호출했으므로 stddraw는 무한정 대기 상태에 들어간다). 그러고 나면 stddraw는 파일명을 지정할 수 있게 해주는 파일 다이얼로그 상자를 보여준다(주의: 파일 다이얼로그가 표준 그래픽스 창 뒤에 숨어 있어 보이지 않을 수 있다. 이때 표준 그래픽스 창의 위치를 다른 곳으로 이동하라). 다이얼로그 상자에서 파일명을 입력한 후 [Save] 버튼을 클릭하면 stddraw는 표준 캔버스 창을 지정한 파일에 저장한다. 파일명은 반드시 .jpg나 .png로 끝나야 한다. 이번 절에서 그래픽스 프로그램으로 생성한 그림들은 모두 이 메커니즘으로 파일에 저장한 것이다.

<br/>

### 제어 명령 
- 표준 그래픽스 캔버스의 좌표계는 기본적으로 단위 정사각형이지만, 다른 배율을 원할 때도 있다. 예를 들어 x 좌표나 y 좌표, 혹은 xy 좌표의 값을 특정한 범위로 설정하고자 하는 때가 그렇다. 그리고 선의 두께나 점의 크기를 기본값과 다르게 설정하고 싶을 때도 있다. 이럴 때를 대비해 stddraw는 아래의 표와 같은 제어 함수를 제공한다.

![image](https://user-images.githubusercontent.com/61584142/160225462-2bb4ddb0-1d5d-4f11-ba7e-83ecdf6ad469.png)

<br/>

- 예를 들어 stddraw.setXscale(0, n)을 호출하면 x축 범위를 0에서 n까지 사용하겠다고 그래픽스 장치에 알려주는 것이다. 다음과 같이 호출하면 캔버스의 왼쪽 아래는 (x0, y0), 오른쪽 꼭대기는 (x1, y1)로 좌표 범위를 설정한다. 정수 인수로 이 함수를 호출하면 예상대로 파이썬은 정수를 실수로 프로모션(promotion)시켜 좌표 범위를 설정한다.

```
stddraw.setXscale(x0, x1)
stddraw.setYscale(y0, y1)
```

<br/>

![image](https://user-images.githubusercontent.com/61584142/160225476-2a10ddb7-02e3-4a40-905a-ff68cb549a8b.png)

<br/><br/>

### 도형과 색상을 이용한 그림 예제

![image](https://user-images.githubusercontent.com/61584142/160225542-095eb1c9-e965-42dd-98d0-e4bbc577cda5.png)

<br/><br/>

### 애니메이션
- stddraw.show()에 인수를 전달하면 프로그램은 이후에 또 다른 작업을 진행할 수 있다. 즉 배경 캔버스를 표준 그래픽스 창으로 복사하고 나서 인수로 전달한 숫자의 밀리초만큼만 기다린다. 잠시 후에 살펴보겠지만, 이 기능과 배경 캔버스를 지우는 기능을 결합하면 표준 그래픽스 창 안에 역동성을 부여함으로써 재미있는 효과를 무한히 만들어낼 수 있다. 이런 효과를 이용하면 사람들의 눈길을 끌어모을 수 있다. 

![image](https://user-images.githubusercontent.com/61584142/160225564-f87bf8dd-8b6a-44d1-afa4-493cf9ef21d5.png)

<br/>

#### Bouncing Ball
```
import stddraw 
 
stddraw.setXscale(-1.0, 1.0)
stddraw.setYscale(-1.0, 1.0)
 
DT = 20.0
RADIUS = 0.05
rx = 0.480
ry = 0.860
vx = 0.015
vy = 0.023
 
while True: 
    # 공의 위치를 갱신하고 새로운 위치에 공을 그린다.
    if abs(rx + vx) + RADIUS > 1.0: vx = -vx
    if abs(ry + vy) + RADIUS > 1.0: vy = -vy
    rx = rx + vx
    ry = ry + vy
 
    stddraw.clear(stddraw.GRAY)
    stddraw.filledCircle(rx, ry, RADIUS)
    stddraw.show(DT)
```

<br/>

- 이 프로그램은 표준 캔버스에 튕기는 공을 그린다. 즉, 기본 캔버스를 상자로 가정하고 그 안에서 튕기는 공을 흉내 낸다. 공은 탄성 충돌 법칙에 따라 경계선에서 튕긴다. 공이 있던 자리의 픽셀은 검은색이나 흰색으로 변하지만, 20밀리초 동안 머무는 검은 공 이미지는 화면 위에 계속 남아 있다. 대기 시간 DT를 명령 줄 인수로 받도록 수정하면 프로그램을 실행할 때 공의 속도를 지정할 수 있다. 

![image](https://user-images.githubusercontent.com/61584142/160225583-bd4de0dc-77df-4a03-a193-e83f11f67397.png)
![image](https://user-images.githubusercontent.com/61584142/160225588-2ec9318b-6ff9-4d6a-ba52-e410fa684df4.png)

<br/><br/>

### 표준 오디오
- 기본적인 출력 추상화에 대한 마지막 예로서 stdaudio 모듈을 살펴보자. stdaudio 모듈을 이용하면 사운드를 재생, 조작, 합성할 수 있다. 음악 파일을 조작하기 위해 컴퓨터를 활용해본 기억이 있을 것이다. 이제는 그런 일을 하는 프로그램을 작성하는 것이다. 이와 함께 컴퓨터 과학과 과학 컴퓨팅의 중요 활용 분야 중 하나인 디지털 신호 처리(digital signal processing)의 기반이 되는 개념도 알아보겠다. 여기에서는 흥미로운 주제에 대해 수박 겉핥기 정도로 설명하지만, 기반 개념은 놀라울 정도로 간단하다.

<br/>

- '라'음(A) 사운드는 분자의 진동(엄밀히 말하면 고막의 진동)을 느끼는 감각이다. 따라서 진동을 알아야 사운드를 이해할 수 있다. 가장 간단히 설명할 수 있는 음은 중간 ‘도’음 아래 있는 ‘라’이다. ‘라’음은 그저 사인 곡선으로서 초당 440번 진동하는 음이다. sin(t) 함수는 2𝜋 주기로 반복되므로, 초 단위인 t에 대해 sin(2𝜋t × 440) 함수를 그리면 초당 440번 진동하는 곡선을 만들 수 있다. 기타 줄을 튕기거나 트럼펫을 불거나 조그만 스피커를 진동시키든 ‘라’음에서는 이 사인 곡선이 이 사운드의 핵심 부분이다. 주파수는 헤르츠(hertz)(초당 사인 곡선의 반복 수) 단위로 측정한다. 주파수를 두 배로 하거나 반으로 줄이면 같은 음계를 한 옥타브 올리거나 내린다. 예를 들어 880헤르츠는 한 옥타브 위의 ‘라’음, 110헤르츠는 두 옥타브 아래의 ‘라’음이다. 참고로 사람은 20에서 20,000헤르츠 사이의 사운드를 들을 수 있다. 사운드의 진폭(y축)은 볼륨에 해당한다. 여기서는 -1과 1 사이에 곡선을 그리고 사운드를 녹음하거나 재생하는 장치는 이 그래프의 배율을 조절한다고 가정한다. 그리고 볼륨 손잡이를 조정하는 것은 진폭을 조정한다.

![image](https://user-images.githubusercontent.com/61584142/160225617-8e3330a7-3677-41dc-8230-1e2519e9b420.png)

<br/>

#### 다른 음
- 간단한 수식으로 반음계의 다른 음을 설명할 수 있다. 반음계에 있는 12개의 음은 밑수 2인 로그 함수로 균일하게 분할된다. i번째 음은 주파수에 2의 i/12 제곱을 곱해 구한다. 즉 반음계에 있는 각 음은 바로 아래 음에 21/12(대략 1.06)을 곱해 구한다. 자, 이제 음악을 컴퓨터로 재생할 기본적인 준비는 된 것 같다! 예를 들어 프레르 자크(Frère Jacques)의 노래를 연주하려면 A B C# A에 해당하는 주파수를 0.5초씩 생성하고 이 패턴을 반복하면 된다.

<br/>

#### 샘플링
- 디지털 사운드도 함수 그래프를 그리는 방법과 마찬가지로 일정 간격으로 샘플링해 곡선으로 표현한다. 이때 충분히 조밀하게 샘플링해야 정확한 곡선을 얻을 수 있으며, 일반적으로는 초당 44,100번 샘플링하는 방법이 널리 사용된다. ‘라’음의 경우 이 비율은 사인 곡선 하나를 약 100개의 점에서 샘플링해 그리는 정도가 된다. 일정한 간격으로 샘플링하므로 샘플로 선택한 점에서 y 값만 계산하면 된다. 샘플링은 이처럼 간단하다. 소리를 -1과 1 사이의 실수를 담은 배열로 표현하는 것이다. 예제용 라이브러리 stdaudio 모듈에는 인수로 실수 배열을 받아 이 배열이 표현하는 소리를 재생하는 stdaudio.playSamples() 함수가 있다.

<br/>

#### 파일에 저장하기 
- 음악은 컴퓨터에서 저장 공간을 많이 차지한다. 초당 44,100번 샘플링하는 경우 4분짜리 노래는 4 × 60 × 44100 = 10,584,000개의 숫자에 해당한다. 따라서 음악 파일에 들어가는 숫자는 표준 입출력 장치에서 숫자를 문자열로 표현하는 방법이 아니라 이진 서식을 사용해 저장 공간을 줄인다. 지난 수년간 다양한 음악 서식이 개발되었으며, stdaudio 모듈은 .wav 서식을 사용한다. 그러나 stdaudio 모듈에서 필요한 변환을 모두 수행해주므로, .wav 파일 서식을 상세히 알 필요는 없다. stdaudio 모듈을 사용하면 손쉽게 .wav 파일을 재생하고, 배열을 생성하고 조작하고, .wav 파일에 저장하거나 읽을 수 있다.

<br/>

#### 사운드 생성용 함수들

![image](https://user-images.githubusercontent.com/61584142/160225638-581870e4-03d1-4f22-8768-edee04cb0c65.png)

<br/>

#### 디지털 신호 처리(playthattune.py)
```
import math
import stdarray
import stdaudio
import stdio
 
SPS = 44100
CONCERT_A = 440.0
 
while not stdio.isEmpty():
    pitch = stdio.readInt()
    duration = stdio.readFloat()
    hz = CONCERT_A * (2 ** (pitch / 12.0))
    n = int(SPS * duration)
    samples = stdarray.create1D(n+1, 0.0)
    for i in range(n+1):
        samples[i] = math.sin(2.0 * math.pi * i * hz / SPS)
    stdaudio.playSamples(samples)
stdaudio.wait()
```

<br/>

- 이 프로그램은 표준 입력 스트림에서 사운드 샘플을 읽고 표준 사운드 장치에 출력한다. 이 데이터-주도 프로그램은 표준 입력 스트림에서 음높이(‘라’음에서의 거리)와 시간(초 단위)으로 정의된 반음계 순음(pure tone)을 재생한다. 여기에서는 표준 입력 스트림에서 음표를 읽고, 지정된 주파수와 시간 동안의 사인 곡선에서 초당 44,100개를 샘플링해 배열을 생성한 후, stdaudio.playSamples()를 호출해 각 음을 연주한다.

<br/>

![image](https://user-images.githubusercontent.com/61584142/160225661-f342ea18-49d8-4da7-be4f-775a471d62ef.png)
![image](https://user-images.githubusercontent.com/61584142/160225664-020d2799-707f-49bf-9f94-f8cba76c339e.png)

<br/>

- 사운드 처리는 우리에게 익숙한 과학 컴퓨팅의 중요한 응용 분야 중 하나이므로 기초 프로그래밍 도구에 포함시켰다. 디지털 신호를 처리하는 상업용 애플리케이션이 현대 사회에 상당한 영향을 미쳤을 뿐만 아니라, 디지털 신호 처리의 기반이 되는 과학과 공학은 물리학과 컴퓨터 과학을 재미있게 연결시켜준다. 

<br/><br/>

- 프로그램을 전혀 변경하지 않고 표준 입력, 표준 출력, 표준 그래픽스, 표준 오디오를 다양한 물리적 장치에 연결할 수 있으므로, 입출력은 추상화의 힘을 잘 보여주는 사례라고 할 수 있다. 실제 장치는 엄청나게 다를 수 있지만, 특정 장치의 특성에 의존하지 않고 입출력할 수 있는 프로그램을 작성할 수 있다. 이제부터는 stdio, stddraw, stdaudio 모듈이 제공하는 함수들을 이 책의 거의 모든 프로그램에서 호출할 것이다. 이런 모듈을 사용하면 여러분이 작성한 프로그램을 전혀 변경하지 않고도 기존 컴퓨터에서 더 빠르거나 싼 , 혹은 데이터를 더 많이 저장할 수 있는 컴퓨터로 자유롭게 바꿀 수 있다. 다른 컴퓨터로 바꿀 때의 기술적인 문제는 라이브러리 함수와 운영 체제 간 연결 부분에서의 문제만 해결하면 된다. 최신 컴퓨터 시스템을 위한 장치들은 일반적으로 운영 체제와 파이썬 간의 세부적인 사항들을 해결해주는 소프트웨어(장치 드라이버)도 함께 제공한다.

<br/>

- 개념적으로 표준 입력, 표준 출력, 표준 그래픽스, 표준 오디오 스트림의 가장 중요한 특징 중의 하나는 이 스트림들은 무한하다는 것이다. 프로그램의 관점에서 보면 길이에 제한이 없다. 이런 관점은 내재적인 한계를 가지고 있는 프로그램보다 기술 변화에 덜 민감하기 때문에 훨씬 더 오래 유용하게 사용할 수 있는 프로그램을 만들 수 있게 해준다. 그리고 무한 스트림은 튜링 기계(Turing machine)와도 관련되어 있다. 튜링 기계는 이론 컴퓨터 과학자가 사용하는 추상적인 장치로서 실제 컴퓨터의 근본적인 한계를 알 수 있게 해준다. 이 모델의 중요한 특징 중 하나는 입력과 출력을 무한히 할 수 있는 유한 상태 장치 개념이다.

<br/><br/>

### Q. 표준 출력을 처리하는 파이썬 표준 모듈이 있나?
**A.** 실제로 파이썬이 그런 기능이 내장되어 있다. 파이썬 2에서는 print 문을 이용해 표준 출력 스트림에 데이터를 출력할 수 있다. 그러나 파이썬 3에서는 print() 함수를 호출해야 한다. print() 함수는 파이썬 2의 print 문과 비슷하다.

<br/><br/>

### Q. 그렇다면 파이썬에서 이미 제공하는 기능을 사용하지 않고 예제용 라이브러리의 stdio 모듈을 사용하는 이유는 무엇인가?
**A.** print 문을 사용하면 파이썬 2에서는 작동하지만 파이썬 3에서는 작동하지 않는다. 그러나 stdio 모듈을 사용하면 파이썬 2와 파이썬 3에서 모두 제대로 작동한다.

<br/><br/>

### Q. 표준 입력은 어떤가?
**A.** 파이썬 2와 파이썬 3에는 stdio.readLine()에 해당하는 기능이 있지만, stdio.readInt() 등의 함수는 제공하지 않는다. stdio 모듈을 사용하면 추가된 기능을 활용할 수 있을 뿐만 아니라 파이썬 2와 3에서 모두 작동한다.

<br/><br/>

### Q. 그래픽스와 사운드는 어떤가?
**A.** 파이썬에는 오디오 라이브러리가 내장되어 있지 않다. 그림을 생성하기 위해 Tkinter라는 그래픽스 라이브러리를 제공하지만 너무 느려서 이 책의 예제를 실행하기에 부적합하다. 이 책의 예제용 라이브러리에서 제공하는 stddraw와 stdaudio 모듈은 Pygame 라이브러리에 기반해 사용하기 쉬운 API를 제공한다.

<br/><br/>

### Q. stdio.writef() 함수에서 실수를 출력하기 위해 %2.4f 서식을 사용하면 소수점 앞에 두 자리, 소수점 뒤에는 네 자리 숫자가 출력되는가?
**A.** 아니, 그렇지 않다. 그 서식은 소수점 뒤에 네 자리가 출력되도록 만들 뿐이다. 소수점 앞에 오는 숫자는 전체 필드의 길이다. 소수점 앞에 두 자리, 소수점, 소수점 뒤에 네 자리, 총 7자리를 출력하려면 %7.4f 서식을 사용해야 한다.

<br/><br/>

### Q. stdio.wirtef() 함수에 사용할 수 있는 변환 코드에 또 다른 어떤 것들이 있는가?
**A.** 정수의 경우, o는 8진수, x는 16진수로 변환한다. 그리고 날짜와 시각을 지정하는 다양한 서식이 있다.

<br/><br/>

### Q. 표준 입력 스트림에서 이미 읽은 데이터를 다시 읽을 수 있나?
**A.** 아니다. 딱 한 번만 읽을 수 있다. 일단 stdio.writeln()을 호출하고 난 후에는 출력된 내용을 지울 수 없는 것과 마찬가지다.

<br/><br/>

### Q. 표준 입력 스트림에 더 이상 데이터가 없을 때 프로그램에서 데이터를 읽으려고 시도하면 어떤 일이 생기나?
**A.** 실행 시 파이썬이 EOFError 예외를 발생시킨다. 입력 데이터가 더 있는지 확인하기 위해 stdio.isEmpty()나 stdio.hasNextLine() 함수를 사용하면 이런 오류를 예방할 수 있다.

<br/><br/>

### Q. stddraw.square(x, y, r) 함수가 변의 길이가 r이 아닌 2r인 정사각형을 그리는 이유는?
**A.** 이것은 stddraw.circle(x, y, r) 함수가 지름이 아니라 반지름이 r인 원을 그리는 것과 일관성을 유지하기 위해서이다. stddraw.circle(x, y, r) 함수가 생성한 원은 stddraw.square(x, y, r) 함수가 생성한 정사각형 안에 들어가는 가장 큰 원이다.

<br/><br/>

### Q. 프로그램에서 stddraw.show(0) 함수를 호출하면 어떻게 되나?
**A.** 배경 캔버스에 있는 이미지를 표준 그래픽스 창으로 복사하고 나서 0밀리초 동안 기다리게 한다. 즉 전혀 기다리지 않고 다음으로 넘어가게 만든다. 컴퓨터에서 지원하는 가장 빠른 속도로 애니메이션을 수행하려면 이렇게 함수를 호출할 수도 있다.

<br/><br/>

### Q. stddraw로 원 외에 다른 곡선도 그릴 수 있는가?
**A.** 그림의 기본은 선분이므로 이 책에서 설명한 기본적인 도형만 지원된다. 연습문제에서 설명하는 것처럼 다른 모양은 점을 하나씩 찍어서 그릴 수 있지만, 이때 도형 내부를 채우는 기능은 지원되지 않는다.

<br/><br/>

### Q. playthattune.py용 입력 파일을 생성할 때 ‘라’음 밑으로 내려가는 음은 음수로 정의해야 하나?
**A.** 그렇다. ‘라’음을 0번 인덱스에 넣은 것은 우리가 임의로 선택한 방식이다. 악기 디지털 인터페이스(Musical Instrument Digital Interface, MIDI) 표준의 경우 ‘라’음에서 다섯 옥타브 아래의 ‘도’음(C)에서 시작하므로, ‘라’음의 번호는 69번이며, 음수를 사용할 필요가 없다.

<br/><br/>

### Q. 30,000헤르츠나 그 이상으로 사인 곡선을 소리로 만들 때 표준 오디오에서 이상한 소리가 나는 이유는 무엇인가?
**A.** 샘플링 주파수의 절반으로 정의되는 나이퀴스트 주파수(Nyquist frequency)는 재생할 수 있는 가장 높은 주파수를 나타낸다. 표준 오디오의 경우 샘플링 주파수가 44,100이므로 나이퀴스트 주파수는 22,050이다.

<br/><br/><br/><br/>

## 사례 연구: 랜덤 웹 서퍼
- 웹을 통한 소통은 이미 우리 일상생활에 깊숙이 자리 잡았다. 이렇게 소통하는 것은 웹 구조를 과학적으로 연구하는 과정에서 생겨났으며, 이 주제는 웹의 태생부터 활발히 연구되어 왔다. 이번 절에서는 특히 웹의 속성을 제대로 이해하게 해준 간단한 웹 모델을 살펴본다. 이 모델의 변형들이 널리 사용되고 있으며 웹 검색의 폭발적인 성공에 커다랗게 기여해왔다.

<br/>

- 랜덤 서퍼(random surfer) 모델로 알려진 이 모델은 간단하다. 웹은 페이지로 구성된 불변 집합, 각 페이지는 링크로 구성된 불변 집합, 각 링크는 다른 페이지를 참조한다고 가정한다. 우리는 주소창에 페이지 주소를 입력하거나 현재 페이지에 있는 링크를 눌러 무작위로 이 페이지 저 페이지를 돌아다니는 사람(랜덤 서퍼)에게 어떤 일이 생기는지 연구할 것이다.

<br/>

![image](https://user-images.githubusercontent.com/61584142/160226000-6807cdf4-de1e-49d4-bca0-1d1ad4c3b642.png)

<br/>

- 웹 모델의 기반에는 그래프(graph)라고 하는 수학적 모델이 있는데, 그래프에 대해서는 이 책의 뒷부분(4.5절)에서 자세히 살펴볼 것이다. 그때까지 그래프를 처리하는 방법에 대한 설명은 미룬다. 대신 여기에서는 랜덤 서퍼의 행동을 자연스럽고 정확히 설명하는 통계적 모델에 관련된 계산을 위주로 살펴볼 것이다.

<br/>

- 랜덤 서퍼 모델을 연구하려면 먼저 이 모델을 정확히 정의해야 한다. 모델의 핵심은 무작위로 이 페이지에서 저 페이지로 이동한다는 것이 무엇을 의미하는지 정의하는 것이다. 직관적으로 떠오르는 90-10 규칙은 새로운 페이지로 이동하는 방법을 모두 설명한다. 이 규칙은 랜덤 서퍼가 현재 페이지에 있는 링크(각 링크를 선택할 확률은 동일하다)를 무작위로 눌러 이동할 확률이 90%, 무작위로 페이지 주소를 입력(웹 전체에서 각 페이지를 선택할 확률은 동일하다)해 직접 이동할 확률이 10%라고 가정한다.

<br/>

- 이 모델은 잘못되었다는 생각이 바로 들 것이다. 실제 웹 서퍼의 행동이 그렇게 단순하지 않다는 것을 다음과 같은 경험으로 알고 있기 때문이다.
    - 링크나 페이지를 동일 확률로 선택하는 사람은 없다.
    - 각 페이지를 입력해 바로 찾아갈 가능성은 별로 없다.
    - 90대10(혹은 다른 비율이라도 마찬가지다)으로 이동 방법을 분할할 수 있다는 것은 그저 가정일 뿐이다.
    - 이 모델은 [돌아가기] 버튼이나 북마크는 고려하지 않는다.
    - 실제로 우리는 웹의 아주 작은 일부분만 돌아다닌다.

<br/>

- 이런 결함이 있음에도 불구하고 이 모델은 컴퓨터 과학자들이 연구해 웹의 속성에 대해 아주 많은 것을 알 수 있게 해주기에 충분하다. 이 모델을 알아보기 위해서 간단한 사례를 생각해보자. 랜덤 서퍼가 어느 페이지를 가장 많이 방문할까?

<br/>

- 웹을 사용하는 사람들은 랜덤 서퍼와 어느 정도 비슷하게 행동하므로 랜덤 서퍼의 운명을 이해하는 것은 웹 기반구조를 구축하고 웹 애플리케이션을 개발하는 사람들에게 뜨거운 관심사이다. 이 모델은 수십억 웹 사용자의 경험을 이해하는 도구이다. 기본적인 프로그래밍 도구를 이용해 이 모델과 이 모델이 미치는 영향에 대해 연구해보겠다.

<br/><br/>

### 입력 서식
- 우리는 하나뿐만 아니라 다양한 웹 모델에서 랜덤 서퍼의 행위를 연구할 수 있어야 한다. 따라서 데이터는 파일에 보관하고 표준 입력에서 데이터를 읽는 데이터 주도 코드(data-driven code)를 작성하려 한다. 데이터 주도 코드를 작성하려면 먼저 입력 파일에 들어갈 정보를 구조화하는 입력 서식을 정의해야 한다. 입력 서식은 사용하기 편한 형태면 어떠한 형태로도 정의할 수 있다.

![image](https://user-images.githubusercontent.com/61584142/160226042-96e0a8b6-f4e5-45d2-8dbe-09cbb7846987.png)

<br/>

- 여기에서는 0부터 n-1까지 웹 페이지 n개가 있다고 가정하고 링크를 이 숫자들의 순서쌍으로 표현한다. 이 순서쌍에서 첫 번째 숫자는 링크를 담고 있는 페이지, 두 번째 숫자는 링크가 가리키는 페이지를 나타낸다. 이렇게 관례를 정하고 난 다음에는 랜덤 서퍼 문제에 사용할 입력 서식은 페이지 수(n 값) 뒤에 일련의 정수 쌍(웹에 존재하는 모든 링크를 표현)으로 간단히 정의할 수 있다. stdio의 입력 함수들은 연속된 다양한 공백 문자를 하나의 공백으로 처리해주기 때문에, 입력 스트림의 한 줄에 링크 하나만 넣거나 아니면 여러 개를 함께 넣을 수도 있다.

<br/><br/>

### 변환 행렬
- 우리는 변환 행렬(transition matrix)이라고 하는 2차원 행렬을 이용해 랜덤 서퍼의 행위를 모두 표현할 수 있다. 웹 페이지가 n개 있을 때 n × n 행렬을 만들어 랜덤 서퍼가 i 페이지에서 j 페이지로 이동할 확률을 i행 j열 요소에 정의한다. 먼저 표준 입력에서 데이터를 읽어 이와 같은 변환 행렬을 만드는 코드를 작성해야 한다. 90-10 규칙을 적용하면 다음과 같이 3단계로 변환 행렬을 쉽게 계산할 수 있다.

<br/>

    - n을 읽고 linkCounts[][]와 outDegrees[]를 생성한다.
    - 링크를 읽고 i 페이지에서 j 페이지로 이동하는 링크 수의 합계를 linkCounts[i][j]에 저장하고, 페이지 i에 있는 링크 수의 합계를 outDegrees[i]에 저장한다.
    - 90-10 규칙을 이용해 확률을 계산한다.

<br/>

![image](https://user-images.githubusercontent.com/61584142/160226103-1f7c9dcb-d7d3-43ad-9a88-34488e37cbbe.png)

<br/>

- 앞의 두 단계는 상당히 간단하며, 마지막 단계도 그리 어렵지는 않다. 90-10 확률을 적용하므로, i에서 j 페이지로 이동하는 링크가 있는 경우 linkCounts[i][j]에 0.90 / outDegrees[i]를 곱하고, 모든 요소에 0.10 / n씩 더하면 된다. transition.py은 이 계산을 모두 수행한다. transition.py는 웹 모델에서의 링크 리스트를 변환 행렬로 바꾸는 일종의 필터로 볼 수 있다.

<br/><br/>

### 변환 행렬의 계산 (transition.py)

```
import stdarray 
import stdio
 
n = stdio.readInt()
 
linkCounts = stdarray.create2D(n, n, 0)
outDegrees = stdarray.create1D(n, 0)
 
while not stdio.isEmpty():
    # 링크 수 계산
    i = stdio.readInt()
    j = stdio.readInt()
    outDegrees[i] += 1
    linkCounts[i][j] += 1
 
stdio.writeln(str(n) + ' ' + str(n))
 
for i in range(n):
    # i 행에 대한 확률 분포 출력
    for j in range(n):
        # j 열의 확률 출력
        p = (0.90 * linkCounts[i][j] / outDegrees[i]) + (0.10 / n)
        stdio.writef('%8.5f', p)
    stdio.writeln()
```

<br/>

- 이 프로그램 표준 입력에서 링크를 읽고 이에 해당하는 변환 행렬을 표준 출력으로 내보내는 일종의 필터이다. 먼저 각 페이지에서 링크를 읽어 개수를 세고 나서, 90-10 규칙을 적용해 변환 행렬을 계산한다. 이 프로그램에서는 링크가 없는 페이지는 없다고 가정한다.

<br/>

![image](https://user-images.githubusercontent.com/61584142/160226131-42c6e5f3-6135-43b1-92a7-9bc46bed29de.png)
![image](https://user-images.githubusercontent.com/61584142/160226133-1f853c01-9f53-4e6b-aad8-16acbbb3478f.png)

<br/>

- 변환 행렬은 각 행이 이산 확률 분포(discrete probability distribution)를 나타낸다는 점에서 큰 의미가 있다. 각 행에 있는 요소들은 랜덤 서퍼가 이동할 페이지별 가능성을 모두 표현하며, 각 확률의 합은 1이다.

<br/>

- transition.py가 출력한 내용은 또 다른 파일 서식을 나타낸다. 먼저 행과 열 수가 나오고, 이어 행렬 요소들의 값이 출력된다. 이제 변환 행렬을 읽고 처리할 코드를 작성할 차례가 되었다.

<br/><br/>

### 시뮬레이션 
- 일단 변환 행렬이 주어지면 randomsurfer.py에서 보는 것처럼 아주 적은 코드로 랜덤 서퍼의 행동을 시뮬레이션할 수 있다. 이 프로그램은 변환 행렬을 읽고, 페이지 0에서 시작해 규칙에 따라 명령 줄 인수로 받은 이동 횟수만큼 웹 페이지를 이동한다. 이 프로그램은 랜덤 서퍼가 각 페이지를 방문하는 횟수를 기록한다. 이 횟수를 총 이동 횟수로 나누면 랜덤 서퍼가 해당 웹 페이지에 방문할 추정 확률이 된다. 이 추정 확률을 페이지의 랭크(rank)라고 하며, 결국 randomsurfer.py는 모든 페이지의 랭크를 계산하는 셈이다.

<br/>

#### 랜덤 서퍼 시뮬레이션(randomsurfer.py)

```
import random
import sys
import stdarray
import stdio
 
moves = int(sys.argv[1])
 
n = stdio.readInt()
stdio.readInt()      # 이 값은 앞의 n과 동일하므로 굳이 사용할 필요 없다.
p = stdarray.create2D(n, n, 0.0)
for i in range(n):
    for j in range(n):
        p[i][j] = stdio.readFloat()
 
hits = stdarray.create1D(n, 0)
page = 0      # 페이지 0에서 시작한다.
 
for i in range(moves):
    r = random.random()      # p[page] 행에 따라 무작위 페이지를 계산한다.
    total = 0.0              #
    for j in range(0, n):    #
        total += p[page][j]  #
        if r < total:        #
            page = j         #
            break            #
    hits[page] += 1
for v in hits:
    stdio.writef('%8.5f', 1.0 * v / moves)
stdio.writeln()
```

<br/>

- 이 프로그램은 변환 행렬을 이용해 랜덤 서퍼의 행위를 시뮬레이션한다. 총 이동 횟수를 명령 줄 인수로 받고, 변환 행렬을 읽고, 변환 행렬에 따라 총 이동 횟수만큼 이동한 후, 각 페이지를 방문한 상대적인 빈도를 출력한다. 이 계산의 핵심은 무작위로 다음 페이지로 이동하는 방법이다.

<br/>

![image](https://user-images.githubusercontent.com/61584142/160226218-aa2a13fb-062b-43c2-9a0c-cddf8135d6d4.png)
![image](https://user-images.githubusercontent.com/61584142/160226219-4849faa0-53a9-4332-bea6-999bac7379fb.png)

<br/>

#### 각각의 무작위 이동 
- 이 계산의 핵심은 변환 행렬에 정의된 무작위 이동이다. page 변수는 서퍼의 현재 위치를 담고 있다. p[page][j] 요소는 서퍼가 페이지 page에서 페이지 j로 이동할 확률이다. 즉, 우리가 할 일은 서퍼가 page에 있을 때 변환 행렬의 page 행에 정의된 분산에 따라 0과 n-1 사이의 난수를 생성하는 것이다(p[page]는 n-1개의 요소를 가진 배열이다). 어떻게 하면 이 난수를 생성할 수 있을까? random.random() 함수를 사용하면 0과 1 사이의 실수형 난수를 생성할 수 있지만, 이것을 이용해 어떻게 무작위로 다른 페이지로 이동할 수 있을까? 한 가지 가능한 방법은 (0, 1) 사이를 n개의 구간으로 나누고, 변환 행렬의 page 행에 있는 확률에 맞게 구간 길이를 설정하는 것이다. 그러면 난수 변수인 r은 확률만큼의 길이를 가진 각 구간 중 하나에 들어가게 된다. 이 방법을 코드로 표현하면 다음과 같다.

<br/>

```
total = 0.0
for j in range(0, n)
    total += p[page][j]
    if r < total:
        page = j
        break
```

<br/>

#### 변수 
- total은 p[page] 행에 정의된 구간들의 종점을 추적하며, for 루프는 해당 구간에 난수 r이 들어가는지 알아낸다. 예를 들어 이 예제에서 랜덤 서퍼가 페이지 4에 있다고 하자. 각 변환 확률이 0.47, 0.02, 0.47, 0.02, 0.02이므로, total은 0.0, 0.47, 0.49, 0.96, 0.98, 1.0의 값을 차례대로 취한다. total 값은 확률에 의해 다섯 개의 구간 (0, 0.47), (0.47, 0.49), (0.49, 0.96), (0.96, 0.98), (0.98, 1)을 정의하며, 각기 해당 페이지로 이동할 가능성을 나타낸다. 이제 random.random()이 0.71을 반환한다고 가정하자. j를 0에서 시작해, 1을 거치고, 2에서 멈춘다(그림 1.6.4). 0.71이 (0.49, 0.96) 범위에 있으므로 랜덤 서퍼를 3번째 페이지(즉, 페이지 2)로 보낸다. 그러고 나서 페이지 2에서 이 과정을 다시 반복한다. n이 큰 경우에는 이진 검색(binary search)을 이용해 계산 속도를 대폭 향상시킬 수 있다. 일반적으로 이런 상황에서는 검색 속도를 향상시킬 방법에 관심을 갖게 된다. 잠시 후에 살펴보겠지만, 무작위로 이동할 페이지가 아주 많기 때문이다.

![image](https://user-images.githubusercontent.com/61584142/160226243-3f432281-15b7-42b1-8430-44528f204da1.png)

<br/><br/>

### 마르코프 연쇄 
- 랜덤 서퍼의 행동을 설명하는 과정은 마르코프 연쇄(Markov chain)로 알려져 있다. 마르코프 연쇄는 20세기 초 이 개념을 개발한 러시아 수학자 안드레이 마르코프(Andrey Markov)의 이름을 따서 붙여졌으며, 다양한 분야에 적용할 수 있고, 연구가 많이 이루어졌으며, 유용한 성질을 많이 지니고 있다. 예를 들어 randomsurfer.py가 페이지 0이 아닌 무작위 페이지에서 시작하면 어떨까 하는 생각이 들 수 있다. 마르코프 연쇄의 기본 제약 이론에 따르면 랜덤 서퍼는 어디서든 시작할 수 있다. 랜덤 서퍼가 결국 어느 페이지에 도달할 확률은 어느 페이지에서 시작하든 똑같기 때문이다! 이 과정은 랜덤 서퍼가 어디에서 시작하든 더 많이 서핑해도 더 많은 정보를 제공하지 않는 상태에 마침내 도달한다. 이런 현상을 혼합(mixing)이라고 하는데, 처음에는 직관적으로 와 닿지 않을 수도 있지만 혼합은 혼란스러워 보이는 상황에서 일관된 행위를 설명해준다. 우리가 지금 알아보고 있는 예제에서 보면 혼합은 서퍼가 충분히 오래 서핑한 후 모든 사람에게 웹이 비슷해 보인다는 개념을 설명한다.

<br/>

- 마르코프 연쇄가 꼭 혼합 특성을 가지는 건 아니다. 예를 들어 우리 모델에서 URL을 직접 입력하지 못하게 하면 랜덤 서퍼에게 문제가 생기게 할 수 있는 웹 페이지를 만들 수 있다. 사실 웹 페이지 집합에는 거미 덫(spider trap)이라고 하는 페이지가 존재한다. 거미 덫은 자신에게 들어오도록 링크를 유도하지만 밖으로 나가는 링크를 가지고 있지 않다. URL을 직접 입력해 이동하지 않으면 랜덤 서퍼가 거미 덫에 빠질 수 있다. 90-10 규칙의 가장 큰 목적은 혼합을 보장하고 거미 덫 같은 문제를 제거하기 위한 것이다.

<br/><br/>

### 페이지 랭크 
- randomsurfer.py 시뮬레이션은 간단하다. 그래프를 따라 무작위로 지정한 이동 횟수만큼 이동하는 것이 전부이다. 혼합 현상 때문에 반복 횟수를 늘리면 랜덤 서퍼가 각 페이지에 도달할 추정 확률(페이지 랭크)에 더 가까워진다. 문제에 대해 처음에 들었던 생각과 시뮬레이션 결과를 비교해보면 어떤가? 페이지 4의 랭크가 가장 낮을 거라고는 생각했겠지만, 페이지 0과 1이 페이지 3보다 랭크가 높을 것이라고 예상했었는가? 어느 페이지의 랭크가 가장 높은지 알고 싶으면 정밀도와 정확성을 높여야 한다. randomsurfer.py 프로그램이 소수점 d자리까지 정확한 답을 구하려면 10d 횟수만큼 페이지를 이동해야 하며, 정확한 값에 안착하려면 훨씬 더 많이 이동해야 한다. 예를 들어 소수점 둘째 자리까지 정확한 값을 얻으려면 수만 번 이동해야 하면 소수점 셋째 자리까지 정확한 값을 얻으려면 수백만 번 이동해야 한다. 결론적으로 27.3퍼센트 대 26.6 퍼센트로 페이지 0이 페이지 1을 앞선다. 이렇게 작은 문제에서 이렇게 작은 차이가 나타날 수 있다는 것이 상당히 놀랍다. 페이지 0에 도달할 확률이 가장 높다고 예상했다면 운이 좋았던 것이다!

<br/>

- 웹 페이지의 정확한 페이지 랭크 예측은 여러 가지 이유로 중요한 작업이다. 먼저 웹 검색 결과에 따라 페이지들을 랭크 순서대로 나열하면 기존 다른 방법보다 사용자의 기대를 더욱 만족시켜줄 수 있다. 다음으로 신뢰성 있는 척도를 제공하므로 페이지 랭크에 기반한 웹 광고에 많은 돈을 투자하게 만든다. 우리 예제처럼 아주 작은 예에서도 페이지 랭크를 이용해 페이지 4보다 페이지 0에 광고를 넣으면 4배나 많은 광고비가 드는 이유를 광고주에게 설득시킬 수 있다. 페이지 랭크 계산은 수학 문제이자, 컴퓨터 과학에서 흥미를 갖게 만드는 문제로서, 커다란 사업 기회를 제공한다.

<br/><br/>

### 히스토그램 그리기 
- stddraw를 이용하면 랜덤 서퍼가 방문하는 빈도가 어떻게 페이지 링크에 가까워지는지 그림으로 잘 보여줄 수 있다. 표준 그래픽스 창의 x와 y축의 배율을 적절히 설정하고 다음 코드를 randomsurfer.py에 추가한 후, 랜덤 서퍼가 수백만 번 페이지를 이동하게 하면 히스토그램이 페이지 랭크에 가까워지는 것을 확인할 수 있다

```
if i % 1000 == 0:
    stddraw.clear()
    for k in range(n):
        stddraw.filledRectangle(k - 0.25, 0.0, 0.5, hits[k])
    stddraw.show(10)
```

<br/>

![image](https://user-images.githubusercontent.com/61584142/160226286-81ba79f5-682c-4e8a-979d-14cf035da756.png)

- 일단 이 도구를 한 번 사용해본 후에는, 다른 모델을 연구할 때도 늘 이와 같은 도구를 사용하고 싶을 것이다(처리할 데이터 모델이 크면 약간 변경해야 할 것이다).

<br/><br/>

### 다른 모델의 연구 
- 지금까지 살펴본 randomsurfer.py와 transition.py는 데이터 주도 프로그램이 어떤 것인지 잘 보여주는 훌륭한 사례이다. 정수 n으로 시작해 페이지 간의 연결을 나타내는 0에서 n-1 사이의 정수 쌍을 담은 tiny.txt 같은 파일을 만들면 데이터 모델을 쉽게 생성할 수 있다. 연습문제에 나오는 다양한 모델에 적용해봐도 좋고 여러분이 연구하고 있는 어떤 것의 모델을 만들어도 좋다. 어떻게 웹 페이지 랭크를 정하는지 궁금했던 적이 있다면 이 계산을 통해 어떤 페이지가 다른 페이지보다 랭크가 높은 이유를 더욱 실감할 수 있다. 어떤 페이지들이 랭크가 높은가? 다른 페이지에 대한 링크가 많은 페이지가 높을까? 아니면 링크가 적은 페이지의 랭크가 높을까? 이번 절 연습문제는 랜덤 서퍼의 행동을 연구할 수 있는 기회를 많이 제공한다. randomsurfer.py가 표준 입력을 사용하므로 대형 데이터 모델을 생성하는 프로그램을 만들고, 생성된 데이터 모델을 randomsurfer.py에 파이프로 연결해 대형 데이터 모델에서 랜덤 서퍼가 어떻게 움직이는지 연구해보길 권한다. 이처럼 융통성이 높으므로 표준 입력과 표준 출력을 많이 사용한다.

<br/>

웹의 구조를 이해하기 위해 랜덤 서퍼의 행동을 바로 시뮬레이션하고 싶은 생각이 들겠지만, 이 시뮬레이션은 한계가 있다. 다음과 같은 질문을 생각해보라. 이 시뮬레이션 방법으로 웹 페이지와 링크가 수백만 개가 되는 웹 모델에서의 페이지 랭크를 계산할 수 있을까? 얼핏 생각해도 대답은 아니다. 이렇게 페이지가 많으면 변환 행렬조차도 저장할 수 없기 때문이다. 페이지가 백만이면 변환 행렬의 요소 수만 1조이다. 컴퓨터에 이만한 데이터를 저장할 공간이 있나? 수천 페이지 정도 되는 더 작은 모델에는 randomsurfer.py를 이용해 페이지 랭크를 알아낼 수 있을까? 이 질문에 답하려면 여러 시뮬레이션을 아주 많이 시도해 결과를 기록한 후 실험 결과를 분석해야 할 것이다. 과학 문제를 해결할 때는 이렇게 접근하지만(도박꾼의 파산 문제가 대표적인 예이다.), 원하는 정확도에 도달하려면 실험을 아주 많이 해야 하므로 시간이 아주 오래 걸릴 수 있다. 이번 절에서 사용한 아주 작은 모델에 대해서는 소수점 서너 자리까지 정확한 결과가 나오려면 시뮬레이션을 수백만 번 실행해야 한다. 모델이 더 크면 추정 확률에 이만큼 접근하기 위해 시뮬레이션을 정말 많이 실행해야 한다.

<br/><br/>

### 마르코프 연쇄의 혼합 
- 페이지 랭크는 웹 모델의 특성이지 랭크를 계산하는 어떤 특정 기법이 아니라는 점에 주의하라. 즉 randomsurfer.py는 페이지 랭크를 계산하는 하나의 방법일 뿐이다. 다행히 수학에서 많은 연구가 이루어진 분야에 기반한 간단한 계산 모델을 이용해 페이지 랭크를 계산하는 문제를 시뮬레이션하지 않고도 훨씬 더 효율적으로 계산할 수 있다. 그 모델은 2차원 행렬 기본 연산을 사용한다.

<br/>

![image](https://user-images.githubusercontent.com/61584142/160226334-c5531248-8317-4a92-85a2-864996d26193.png)

<br/>

- 랜덤 서퍼가 두 번 움직여 페이지 i에서 페이지 j로 이동할 확률은 얼마일까? 먼저 중간 페이지 k로 이동하므로 모든 k에 대해 i에서 k로 이동하고 나서 k에서 j로 이동할 확률을 구해 모두 더한다. 예를 들어 두 번 움직여 1에서 2로 이동할 확률은, 1에서 0으로 이동하고 난 후 2로 이동(이제부터 간단히 ‘1-0-2 이동’이라고 설명하겠다)할 확률(0.02 × 0.02), 1-1-2 이동 확률(0.02 × 0.38), 1-2-2 이동 확률(0.38 × 0.02), 1-3-2 이동 확률(0.38 × 0.02), 1-4-2 이동 확률(0.20 × 0.47)을 모두 더한 값 0.1172이다. 다른 페이지로 이동하는 것도 동일한 과정으로 계산할 수 있다. 이렇게 곱해서 더하는 계산은 이미 앞에서 보았다. 행렬 A와 행렬 B를 곱해 행렬 C를 계산할 때, C의 i행 j열 요소는 A의 i행과 B의 j열의 스칼라곱이다. 즉 p[][] 행렬에 자기 자신을 곱하면 랜덤 서퍼가 두 번 움직여 i에서 j로 이동할 확률을 가진 행렬이 된다. 우리 모델에서 두 번 이동해 움직일 확률 행렬을 차분히 살펴보면 랜덤 서퍼의 행동을 더 많이 이해할 수 있다. 예를 들어 제곱 행렬에서 2행 0열 요소의 값이 가장 큰데, 페이지 2에는 페이지 3으로 가는 링크가 하나만 있고, 페이지 3에는 페이지 0으로 가는 링크 하나만 있음을 잘 반영한다. 따라서 페이지 2에서 시작한 랜덤 서퍼가 두 번 움직여 페이지 0에 도착할 확률이 가장 크다. 두 번 움직이는 다른 경우는 가지 수는 많고 확률은 낮다. 여기에서 주의할 점은 추정 확률을 계산하기 위해 아주 많이 반복해 시뮬레이션하는 randomsurfer.py와 달리, 이 값들은 (파이썬의 실수 정밀도 한계 내에서) 확률을 곱해 정확히 계산된 값이라는 점이다.

<br/>

#### 제곱 기법 
- 제곱 행렬에 p[][]를 한 번 더 곱하면 세 번 움직여 이동할 확률, 여기에 한 번 더 p[][]를 곱하면 네 번 움직여 이동할 확률을 계산할 수 있다. 그러나 행렬의 곱셈은 비싼 연산이며, 실제 우리가 알고자 하는 것은 벡터-행렬 계산이다. 예를 들어 랜덤 서퍼가 페이지 0에서 시작하는 경우를 생각해보자. 각 페이지로 이동할 확률은 다음 벡터와 같다.

```
[1.0 0.0 0.0 0.0 0.0]
```

<br/>

- 이 벡터에 변환 행렬을 곱하면 다음의 벡터가 생성되며, 이 벡터는 랜덤 서퍼가 한 번 움직여 각 페이지로 이동할 확률을 나타낸다.

```
[.02 .92 .02 .02 .02]
```

<br/>

- 이 벡터에 변환 행렬을 한 번 더 곱하면 다음의 벡터가 되며, 이 벡터는 랜덤 서퍼가 페이지 0에서 두 번 움직여 각 페이지로 이동할 확률을 나타낸다.

```
[.05 .04 .36 .37 .19]
```

<br/>

- 예를 들어 랜덤 서퍼가 두 번 움직여 페이지 0에서 페이지 2로 이동할 확률은 0-0-2 이동 확률(0.02 × 0.02), 0-1-2 이동 확률(0.92 × 0.38), 0-2-2 이동 확률(0.02 × 0.02), 0-3-2로 이동 확률(0.02 × 0.02), 0-4-2 이동 확률(0.02 × 0.47)을 모두 더한 0.36이 된다. 이렇게 계산하는 과정을 보면 패턴을 명확히 알 수 있다. 랜덤 서퍼가 t번 이동해 각 페이지에 도달할 확률은 초기 이동 확률 벡터에 변환 행렬을 t-1번 곱한 것과 같다. 마르코프 연쇄의 기본 제약 정리에 따르면 이 과정을 아주 많이 반복하면 랜덤 서퍼의 시작 위치에 상관없이 동일한 벡터에 수렴한다. 즉 랜덤 서퍼가 여러 번 충분히 이동하면 시작 위치에 상관없이 각 페이지에 도달할 확률은 일정하다.

<br/>

![image](https://user-images.githubusercontent.com/61584142/160226381-8db9f335-7d13-4c16-b14f-7c8fe597fcde.png)

<br/><br/>

- markov.py을 이용하면 우리 모델의 확률이 수렴하는 것을 확인할 수 있다. 예를 들어 randomsurfer.py로 수만 번 반복할 필요 없이 행렬-벡터 곱셈을 20번만 수행하면 동일한 결과(소수점 둘째 자리까지 일치하는 페이지 랭크)에 도달한다. 여기에 행렬-벡터 곱셈을 20번 더 수행하면 소수점 셋째 자리까지 일치하는 페이지 랭크를 구할 수 있는데, randomsurfer.py는 연산을 수백만 번 반복해야 이런 정밀도에 도달한다. 그리고 행렬-벡터 곱셈을 몇 번 더 하면 완전히 정확한 결과에 도달한다

<br/>

#### 마르코프 연쇄의 혼합(markov.py)
```
import sys
import stdarray
import stdio
 
moves = int(sys.argv[1])
n = stdio.readInt()
stdio.readInt()
 
p = stdarray.create2D(n, n, 0.0)
for i in range(n):
    for j in range(n):
        p[i][j] = stdio.readFloat()
 
ranks = stdarray.create1D(n, 0.0)
ranks[0] = 1.0
for i in range(moves):
    newRanks = stdarray.create1D(n, 0.0)
    for j in range(n):
        for k in range(n):
            newRanks[j] += ranks[k] * p[k][j]
    ranks = newRanks
 
for i in range(n):
    stdio.writef('%8.5f', ranks[i])
stdio.writeln()
```

<br/>

- 이 프로그램은 명령 줄 인수로 정수 moves를 받고 표준 입력에서 변환 행렬을 입력받는다. 랜덤 서퍼가 moves만큼 이동한 후 각 페이지에 도달할 확률(페이지 랭크)을 계산하기 위해 행렬-벡터 곱셈을 moves만큼 수행하고 표준 출력 장치에 출력한다.

<br/>

![image](https://user-images.githubusercontent.com/61584142/160226448-349bc323-3803-4164-aa21-47064b424b8a.png)
![image](https://user-images.githubusercontent.com/61584142/160226451-0435c8de-24f7-4d91-8906-046c8ed6b705.png)

<br/>

- 마르코프 연쇄에 대해 많은 연구가 수행되었지만, 1998년에 세르게이 브린(Sergey Brin)과 로렌스 페이지(Lawrence Page), 두 명의 대학원생이 마르코프 연쇄를 만들어 랜덤 서퍼가 전 세계 웹의 모든 페이지에 방문할 확률을 계산해낸 후에야 웹에 영향을 미치기 시작했다. 이들의 연구는 웹 검색의 혁명을 이끌었고, 이들이 설립한 구글에서 이 페이지 랭킹 기법을 사용해 커다란 성공을 거두었다. 구글은 랜덤 서퍼가 각 페이지에 도달할 확률을 주기적으로 다시 계산한다. 그러고 나서 사용자가 검색할 때 검색 키워드에 관련된 페이지 목록을 랭크 순서로 나열한다. 이 페이지 랭크는 웹 검색으로 찾으려는 관련 웹 페이지를 신뢰성 있게 찾아내어 전형적인 웹 사용자의 기대에 부응하므로 상당히 뛰어난 결과를 만들어낸다. 웹에 존재하는 웹 페이지가 어마어마하게 많으므로 이 계산에는 시간이 아주 많이 소요되지만, 검색 결과의 수익성이 뛰어나므로 이 비용을 지불할 가치가 있게 만든다. markov.py에서 사용한 기법은 랜덤 서퍼의 행동을 시뮬레이션하는 것보다 훨씬 더 효율적이지만, 웹에 있는 모든 페이지를 담은 거대한 행렬의 확률을 계산하기에는 너무 느리다. 페이지 랭크를 더욱 효율적으로 계산하려면 그래프를 처리하기 위한 더 나은 데이터 구조가 필요하다.

<br/>

#### 더 큰 모델의 페이지 랭크 히스토그램

![image](https://user-images.githubusercontent.com/61584142/160226465-43cf1851-d21f-4304-b74f-d2328bff0371.png)

<br/><br/>

- 랜덤 서퍼 모델에 대한 모든 내용을 담을 수는 없다. 랜덤 서퍼 모델 자체보다는 지금까지 구체적인 개념을 설명하기 위해 사용해왔던 짧은 코드들보다 약간 더 많은 계산이 필요한 애플리케이션을 보여주기 위해 페이지 랭크 사례를 살펴보았다. 이 사례 연구에서 어떤 교훈을 얻을 수 있을까?

<br/>

#### 이미 계산 모델은 갖추어져 있다 
- 내장 데이터 타입에 조건문, 반복문, 배열, 표준 입출력을 결합하면 다양하고 흥미로운 문제를 모두 해결할 수 있다. 사실 이 모델이 일반적인 컴퓨터에서 수행할 수 있는 계산이라고 판단하는 것은 컴퓨터 과학 이론이다..

<br/>

#### 데이터 주도 코드가 대세다 
- 표준 입력과 표준 출력 스트림을 사용하고 데이터를 파일에 저장하는 것은 아주 강력한 개념이다. 우리는 하나의 데이터를 다른 데이터로 변환하는 필터, 연구를 위해 아주 커다란 데이터 파일을 생성하는 제너레이터, 다양한 모델을 처리할 수 있는 프로그램을 작성한다. 데이터를 나중에 사용하기 위해 저장할 수 있으며, 과학 실험 장치나 아주 멀리 떨어져 있는 웹사이트 등 다른 데이터 소스에서 유도된 데이터를 처리해 파일에 저장할 수도 있다. 데이터 주도 코드의 개념은 이런 활동을 쉽고 융통성 있게 지원한다.

<br/>

#### 정확한 답에 도달하기 힘들다 
- 프로그램에서 소수점 이하 여러 자리까지 정확한 숫자를 출력할 수 있다고 해서 프로그램이 정확한 답을 구한다고 단정할 수는 없다. 우리가 정확한 답을 갖고 있다고 보장하는 것이 아주 어려울 때가 종종 있다.

<br/>

#### 균등 분포 난수는 단지 시작일 뿐이다 
- 우리가 흔히 무작위 행동이라고 할 때는 random.random() 함수가 생성하는 ‘모두가 동일한 가능성’보다는 약간 더 복잡한 것을 의미하곤 한다. 우리가 생각할 문제들은 randomsurfer.py처럼 균일하지 않게 분포된 난수를 사용해야 하는 경우들이 종종 있다.

<br/>

#### 효율이 중요하다 
- 우리 컴퓨터가 어떠한 계산도 수행할 수 있을 만큼 빠르다고 생각하는 것은 실수다. 어떤 계산은 다른 계산보다 더 많은 노력이 들어간다. 4장에서는 우리가 작성하는 프로그램의 성능을 평가하는 방법을 자세히 설명한다. 계산 효율에 대한 문제는 4장에서야 다루지만, 프로그램이 어느 정도의 성능을 내야 하는지에 대해서는 늘 주의를 기울여야 한다.

---

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

---

# 1장 변수
## 핵심키워드
### 프로그램
- '데이터'를 입력받아 연산,처리한 후 다시 '데이터'를 출력한다.
### 메모리
- 입력받은 데이터가 저장되는 공간이다.
### 변수
- 메모리에서의 데이터 위치를 나타낸다.

<br/><br/><br/>

## 메모리 미리보기
- 컴퓨터는 1과 0으로 이루어진 데이터를 처리한다. <br/>이때 1과 0을 표현할 수 있는 데이터 단위를 비트(bit)라고 부른다. <br/>1비트는 0혹은 1이다.<br/>
비트가 8개 보이면 바이트(byte)라고 부른다. <br/>1바이트는 01011010과 같이 0과 1이 총 8개로 구성되어 있다.<br/><br/>
- 컴퓨터를 살 때 램(RAM)의 크기에 대해 이야기하는 걸 들어본 적이 있을 것이다. <br/> 기가바이트(GB)는 1,024x1,024x1,024 = 1,073,741,824 바이트를 의미한다. <br/>정말 많은 데이터를 저장할 수 있다.<br/><br/>
- 요즘은 64비트 컴퓨터가 대부분이라 램으로 12GB나 16GB를 사용할 수 있지만, 32비트 컴퓨터를 사용했을 때는 4GB가 넘는 램을 추가로 설치해도 실제 사용할 수 있는 램은 4GB 뿐이다.

<br/>

### 32비트와 64비트의 의미
- 컴퓨터는 데이터 단위로 비트를 사용한다.<br/><br/>
- 한 번에 보낼 수 있는 데이터 개수가 32비트면 32비트 컴퓨터고, 64비트면 64비트 컴퓨터이다. <br/>또한, 32비트 컴퓨터는 메모리 주소를 32비트로 표현하고, 64비트 컴퓨터는 64비트로 표현한다.<br/><br/>

<br/>

### 메모리에 우편번호를 매긴다
- 컴퓨터는 0과 1밖에 모르므로 컴퓨터에 주소를 알려 주려면 주소도 2진수로 나타내야 한다. <br/>메모리 주소 한 개는 메모리에서 1바이크를 가리킨다. <br/>우편번호 한 개가 일정 구역 한 곳을 가리키듯이 말이다.<br/><br/>
- 한 개 동을 나타내는 우편번호가 각각 있듯이 1바이트 메모리를 나타내는 메모리 주소가 각각 있다.<br/><br/>
- 32비트 컴퓨터라면 주소 하나를 나타내는 데 2진수 서른 두 자릿수를 사용한다. <br/>그러므로 32비트에서 나타낼 수 있는 주소 개수는 2<sup>32</sup>개 이다.<br/><br/>
- 메모리 주소 한 개는 1바이트를 가리키므로 32비트로는 2<sup>32</sup>바이트를 표현할 수 있다. <br/>다시 4,294,967,296바이트는 4×1,024×1,024×1,024바이트로 풀어 쓸 수 있다. <br/>1,024바이트는 1KB, 1,024×1,024바이트는 1MB, 1,024×1,024×1,024바이트는 1GB이다.<br/><br/>
- 즉, 32비트로는 총 4GB 메모리를 가리킬 수 있다. <br/>이것이 바로 32비트 컴퓨터에서 4GB보다 큰 메모리가 무용지물인 이유이다.<br/><br/>
- 64비트 컴퓨터는 이론으로만 보면 2<sup>64</sup>바이트를 가리킬 수 있으므로 크기가 훨씬 큰 램을 설치해도 모두 사용할 수 있다.

<br/><br/><br/>

## 변수의 의미
- 변수(variable)란 데이터를 저장할 수 있는 메모리 공간을 의미한다. <br/>여기서 중요한 점은 변수가 단순한 이름이 아니라 메모리 공간 자체를 의미한다는 점이다. <br/>변수는 숫자와 문자뿐만 아니라 객체, 심지어 함수까지도 담을 수 있다. <br/>변수에 담긴 값이나 가리키는 대상은 언제라도 변경될 수 있다. <br/>변경될 수 있으므로 변수이다.<br/><br/>
- 단, 다른 언어에서 말하는 변수와 파이썬에서 말하는 변수는 약간 차이가 난다.
<pre><code>int num = 5;</code></pre>
- 위의 C언어에서 말하는 변수는 num이라는 '변수'에 5라는 '값'이 담겨 있다. <br/>직관적으로 알 수 있는 변수의 모습이다. <br/>하지만 파이썬에서 말하는 변수는 이 모습과 약간 다르다.

<br/><br/><br/>

## 파이썬에서의 변수: 이름과 값 객체
- 파이썬에서 쓰는 변수는 이름과 값 객체로 나눠진다. <br/>우리가 파이썬에서 변수라고 부르는 것은 사실 '이름'이다.
<pre><code>num = 5</code></pre>
- num이라는 '이름'은 5라는 '값 객체'를 가리킨다. <br/>num은 5라는 값을 담고 있는 메모리 공간을 의미하지 않는다. <br/>값 객체는 다른 메모리 공간에 있다.<br/><br/>
- 따라서 type(num)을 하게 되면 num이라는 변수의 타입이 상수가 아니라 int라는 클래스의 인스턴스(객체)라는 것을 알려준다.

---

<br/><br/><br/><br/>

# 2장 정수
- 수(number)는 컴퓨터가 다루는 데이터 종류(자료형)중 가장 중요하다. <br/>컴퓨터는 0과 1만 인식하므로 사람과 다른 방식으로 수를 표현한다.

<br/><br/><br/>

## 컴퓨터에서 수를 표현하는 방법
- 수를 표현하는 방법을 기수법(numeral system)이라고 한다. <br/>밑수를 정하면 밑수 개수만큼의 숫자(digit)를 사용해 수를 나타낼 수 있다. <br/>예를 들어 우리가 일상생활에서 사용하는 10진수는 밑수가 10이고 총 열 개의 숫자로 수를 표현한다.

<br/>

### 10진수
- 10진수는  수를 표현하는 데 숫자를 총 열 개 사용한다. 이때 밑수는 10이고 0부터 9까지 총 열 개의 숫자로 모든 수를 표현한다. 

<br/>

### 2진수
- 2진수는 수를 표현하는 데 숫자 0과 1만 사용한다. 컴퓨터가 인식할 수 있는 표현 방법이다.

<br/>

### 16진수
- 16진수는 수를 표현하는 데 숫자를 총 열여섯 개 사용한다. 숫자를 열여섯 개 사용하기 때문에 9 이후의 숫자는 알파벳 a~f로 표현한다. <br/><br/>
- 즉, 16진수는 `0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f`로 구성된다.

<br/><br/><br/>

## 10진수를 2진수로
<pre><code>bin(Number)</code></pre>
<pre><code>bin(25) # 0b11001</code></pre>
- bin() 함수는 정수를 2진수로 표현하는 함수이다. 결과 값 앞에 나오는 0b는 2진수를 의미하는 binary이다. <br/>변환된 2진수를 보면 앞에서 직접 변환한 값과 같다.<br/><br/>
- 16진수는 0x(hexadecimal)를 앞에 붙여 준다.

<br/><br/><br/>

## 코딩으로 확인하는 진수 변환
<pre><code>a=0xa
bin(a) # 0b1010

b=0xb
bin(b) # 0b1011

c=0xc
bin(c) # 0b1100

d=0xd
bin(d) # 0b1101

e=0xe
bin(e) # 0b1110

f=0xf
bin(f) # 0b1111</code></pre>

<br/>

- 8비트 컴퓨터의 메모리 주소가 2진수로 0010 1101이라면 2진수 네 자릿수를 16진수 한 자릿수로 표현할 수 있으므로 0x2d로 나타낼 수 있다.
<pre><code>address_8bit = 0b00101101
hex(address_8bit) # 0x2d</code></pre>

<br/>

- hex() 함수는 정수를 16진수로 표현한다. <br/>2진수로 표현하면 8비트를 표ㅎ현하는 데 여덟 자릿수가 필요하지만, 16진수로 표현하면 두 자릿수로 간단히 나타낼 수 있어 가독성을 높일 수 있다. <br/>이러한 이유로 메모리 주소를 나타낼 때는 16진수를 사용한다. <br/><br/>
- 32비트 컴퓨터는 서른두 자릿수의 2진수 수가 아닌 여덟 자릿수의 16진수 수를 이용해 표현한다.
<pre><code>address_32비트 = 0x1234abcd
bin(address_32비트) #'0b10010001101001010101111001101'</code></pre>

<br/><br/><br/>

## 양의 정수
- 컴퓨터는 정수(integer)를 1바이트, 2바이트, 4바이트, 8바이트 등 다양한 크기로 저장한다. <br/><br/>
- 정수에는 음수와 양수가 있으므로 부호를 나타내는 데 1비트를 사용한다. <br/>맨 앞의 비트가 0이면 양수, 1이면 음수이다.<br/><br/>
- 예를 들어 25를 메모리에 저장할 때 맨 앞의 비트는 양수이므로 0이 된다. <br/>10진수 25를 2진수로 변환하면 11001이므로 나머지 비트를 0으로 채우면 메모리에 00011001로 저장된다.<br/><br/>
- 맨 앞의 비트가 부호를 나타낸다는 사실만 알고 있다면 10진수를 2진수로 변환한 것과 같다.

<br/>

### 1바이트로 나타낼 수 있는 수의 크기는?
- 언뜻 생각했을 때 8비트를 사용하므로 2<sup>8</sup> 즉, 0 ~ 255일 것 같지만, 정수에는 음수가 포함되고 맨 앞의 비트를 부호로 사용하므로 표현할 수 있는 양수의 범위는 절반으로 줄어든다. <br/>즉, 1바이트로 나타낼 수 있는 수의 범위는 -128 ~ 127이다(음수를 취급하지 않아 0~255를 나타낼 수 있는 정수 자료형도 있다). <br/>하지만 음의 정수를 표현할 때는 방식이 많이 달라진다.

<br/><br/><br/>

## 음의 정수
- 컴퓨터가 음수를 보수(complement) 형태로 저장하므로 음의 정수가 어떻게 저장되는지 이해하려면 보수의 개념을 반드시 알아야 한다.

<br/>

### 보수의 개념
- 보수란 쉽게 말해 '보충해 주는 수'이다. <br/><br/>
- 예를 들어 10진수에서 9의 보수를 구한다고 가정하자. <br/>3의 9의 보수는 3을 더해 9가 되는 수인 6이다. <br/>26의 9의 보수는 73이다. <br/>즉, 어떤 수의 각 자릿수 수를 9에서 빼면 9의 보수를 구할 수 있다. <br/><br/>
- 10의 보수도 구해보자. <br/>3의 10의 보수는 9의 9의 보수인 6에 1을 더한 값인 7이다. <br/>26의 10의 보수는 9의 보수인 73에 1을 더한 값인 74이다.

<br/>

### 2의 보수
- 2진수 1010의 1의 보수는 0101이다. <br/>각 자릿수 수의 1과 0을 반전한 결과이다. <br/><br/>
- 이제 1010의 2의 보수를 구해보자. <br/>1010의 1의 보수가 0101이므로 여기에 1을 더하면 된다. <br/>즉, 1010의 2의 보수는 0110이다. <br/><br/>
- 2의 보수가 중요한 이유는 컴퓨터가 음수를 표현할 때 2의 보수를 사용하기 때문이다.

<br/>

### 음수의 표현
- 컴퓨터는 음수를 2의 보수로 표현한다. <br/><br/>
- 음수인 -4를 1111 1100으로 표현된다. <br/>4를 2진수(0000 0100)로 변환하고 1의 보수를 구한다. <br/>1에서 각 자릿수 수를 빼면(모든 비트를 반전하면) 1의 보수인 1111 1011을 구할 수 있다. <br/>이 수에 1을 더해 2의 보수를 구하면 최종 결과는 1111 1100이다.<br/><br/>

<pre><code>(-4).to_bytes(1, byteorder=‘little’, signed = True) # b’\xfc’</code></pre>
- 위의 코드는 -4라는 '정수'를 컴퓨터 메모리에 저장되는 '바이트'형태로 표현하는 코드이다. <br/>첫 번째 인자는 몇 바이트로 나타낼지 지정한다. <br/>두 번째 인자는 바이트 오더(byteorder)이다. <br/>마지막 인자인 signed는 양수와 음수를 모두 표현할지 아니면 양수만 표현할지 정하는 인수이다. <br/><br/>
- 출력 값은 16진수로 표현된다. 16진수 0xFC를 2진수로 변환하면 1111 1100이다. <br/> -4의 2의 보수와 같다. <br/>이로써 컴퓨터는 음수를 2의 보수를 이용해 저장한다는 것을 알 수 있다. <br/><br/>

- 바이트 오더는 빅 엔디언인지 아니면 리틀 엔디언인지 정하는 인자이다. 

<br/>

### 2의 보수로 표현하는 이유
1. 양수와 음수를 모두 양수처럼 저장한다고 가정해 보자. <br/>0000 0000과 1000 0000은 +0과 -0이 된다. <br/>즉, 0을 표현하는 두 가지 방법이 존재하게 된다. <br/>이렇게 되면 컴퓨터 입장에서는 수 하나를 더 표현할 수 있는데 비트 하나를 낭비하는 셈이다. <br/>또한 두 수를 비교할 때 CPU에서 뺄셈을 하는데 +0과 -0을 비교하면 결과 값이 예상과 다르게 나온다. <br/><br/>
2. 컴퓨터에서 정수의 뺄셈 과정을 살펴보자. <br/>덧셈은 단순히 두 수를 더하면 되지만, 뺄셈은 2의 보수 개념을 활용한다. <br/>9-4를 계산할 때 9에서 4를 빼는 게 아니라 9와 -4를 더한다. <br/><br/>

![image](https://user-images.githubusercontent.com/61584142/156593117-f9732024-70f0-4d31-9a93-19f7821db419.png)

- 10진수 9를 2진수로 표현한 0000 1001에서 10진수 -4를 2의 보수로 표현한 1111 1100을 더한다. <br/>계산 결과를 보면 받아올림(carrying)이 발생하여 1 0000 0101이 나오는데 이때 받아올림 수(맨 앞 의 1)는 버리면 된다. <br/>최종 결과는 0000 0101로 5가 된다. <br/>즉, 9-4가 잘 계산되었음을 알 수 있다. <br/>이와 같은 컴퓨터의 연산 방식을 알면 음수를 왜 2의 보수로 저장하는 지 이해할 수 있다.

---

<br/><br/><br/><br/>

# 3장 실수
## 실수 
<pre><code>a = 0.01
result = 0.0
for i in range(100):
  result += a
  result # 1.0000000000000007</code></pre>
- 이 코드를 보면 a가 0.01이고 이를 100번 더했으니 당연히 1이 나오기를 기대한다. 하지만 결과를 확인해 보면 예상과 다르다. <br/>1에 매우 가까운 수라고는 해도 1은 아니다. 

<br/>

<pre><code>a = 0.015625
a # 0.015625

result = 0.0

for i in range(100):
  result += a

result # 1.5625</code></pre>
- 이번에는 0.01을 100번 더하는 게 아니라 0.015625를 100번 더한다. <br/>컴퓨터가 실수를 표현하는 방법인 부동소수점으로 결과가 정확하게 나온다.

<br/><br/><br/>

## 부동소수점
- 컴퓨터는 IEEE(Institute of Electrical and Electronics Enginerrs, 전기전자기술자협회)까 1985년에 제정한 ANSI/IEEE 754-1985라는 표준에 따라 실수(real number)를 표현한다. <br/>이 표준에 따른 표현법을 부동소수점(floating-point)이라고 부르는데 여기서 '부'는 부표를 말할 때 쓰는 '부'로 둥둥 떠다닌다는 의미이다. <br/>소수점 위치를 보면 앞에 있기도 하고 뒤에 있기도 하다. <br/>마치 소수점이 떠다니는 것처럼 보인다고 해서 이러한 실수 표현 방식을 부동소수점이라고 부른다.

<br/><br/><br/>

## 단정도와 배정도
- 부동소수점에는 단정도 부동소수점과 배정도 부동소수점이 있다. <br/>단정도(single-precision)는 실수를 32비트(4바이트)로 표현하며 부호 1비트, 지수부 8비트, 가수부 23비트로 구성된다. <br/>배정도(double-precision)는 실수를 64비트(8바이트)로 표현하며 부호 1비트, 지수부 11비트, 가수부 52비트로 구성된다. <br/>실수를 표현하는 데 사용하는 비트 수가 단정도보다 두 배 많은 만큼 정밀도가 높다. <br/><br/>

- 파이썬은 배정도를 사용한다.

<pre><code>import sys
sys.float_info
# sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)</code></pre>
- sys라는 모듈을 임포트한 다음 float_info를 입력하면 최댓값, 최솟값, 정밀도 등을 확인할 수 있다.
<pre><code>sys.float_info.max # 1.7976931348623157e+308</code></pre>
<pre><code>sys.float_info.min # 2.2250738585072014e-308</code></pre>

<br/><br/><br/>

## 1바이트 실수 자료형 설계하기
- ± 1.man × 2<sup>exp - bias</sup>
- 1.man은 가수(mantissa/fraction), 2는 밑수, exp-bias는 지수(exponent)를 의미한다.

<br/>

### 10진수 실수를 2진수 실수로 바꾸기
- 7.75 = 4 + 2 + 1 + 0.5 + 0.25 <br/>= 2<sup>2</sup> + 2<sup>1</sup> + 2<sup>0</sup> + 2<sup>-1></sup> + 2<sup>-2</sup> <br/>= 111.11

<br/>

### 정규화
- 정규화(normalization)란 소수점 왼쪽에 위치한 가수 부분을 밑수보다 작은 자연수가 되도록 만드는 것이다. <br/>예를 들어 10진수 567.89를 정규화하면 소수점 왼쪽에 위치한 가수 부분이 밑수 10보다 작은 자연수 5가 되어 5.6789x10<sup>2</sup>이 된다. <br/><br/>
- 2진수의 밑수는 2이므로 2보다 작은 자연수는 1밖에 없다. <br/>따라서 소수점 왼쪽의 가수 부분은 항상 1이 된다. <br/>111.11을 정규화하면 다음과 같다. <br/>111.11 = 1.1111 x 2<sup>2</sup>

<br/>

### 메모리 구조
- 정규화된 부동소수점 수 1.1111 x 2<sup>2</sup>을 앞의 수식과 비교해 보면 man은 1111이고 exp -bias는 2이다. <br/>이제 1바이트의 메모리 구조를 정하고 man과 exp 값만 저장하면 설계가 끝난다. <br/>이때 지수부와 가수부에 할당하는 비트 수에 따라 표현 범위와 정밀도가 결정된다. <br/>0 0000 000 > 부호, 지수부, 가수부 <br/><br/>
- 실수 역시 정수와 마찬가지로 첫 번째 비트는 부호를 나타낸다. <br/>0이면 양수고 1이면 음수이다. <br/>가운데 4비트는 지수부로 exp 값, 맨 뒤 3비트는 가수부로 man 값을 저장한다. <br/><br/>
- bias는 지수의 부호를 결정하는 데 쓴다. <br/>부동소수점의 지수부에는 부호 비트가 없으며 0~15의 양수만 나타낼 수 있다. <br/>하지만 음수 지수도 필요하다. <br/>음수를 사용하려면 bias를 7로 두고 지수부(exp)에서 bias를 뺀 값을 실제 지수로 사용한다. <br/>bias는 2<sup>n-1</sup>-1 식에 지수부의 비트 수인 4를 대입하면 구할 수 있다. <br/><br/>
- 정규화된 수 1.1111x2<sup>2</sup>에서 실제 지수는 2이다. <br/>실제 지수가 2라는 의미는 exp-bias가 2라는 것이다. <br/>지수부의 비트 수 4를 식(2<sup>n-1</sup>-1)에 대입해 얻은 bias 값이 7이므로 실제로 부동소수점의 지수부에 나타나는 값 exp는 9가 된다.

<br/>

- 부호 -> 0
- 지수부 -> 1001
- 가수부 -> 1111

<br/>

- 가수부는 3비트만 할당되는 데 가진 값은 1111일 경우, 뒷자리 1을 생략한다. <br/>즉, 가수부는 111이 된다. <br/><br/>
- 0 1001 111 = 0100 1111 = 0x4f <br/>즉, 실수 7.75를 1바이트 부동소수점으로 나타내면 0x4f이다.

<br/>

### 1바이트 부동소수점의 표현 범위

![image](https://user-images.githubusercontent.com/61584142/158999639-746107e9-bca5-4b5d-95d5-2c5148e6a499.png)

- 단, 지수부 비트가 모두 0일 때 (2<sup>-7</sup>)와 모두 1일 때(2<sup>8</sup>)는 0.0, 정규화 불가능, 무한대, NaN(Not a Number, 숫자가 아님) 같은 특별한 상황을 나타내므로 제외한다. <br/><br/>
- 1바티으지만 굉장히 작은 수부터 큰 수까지 폭넓게 표현할 수 있다는 것을 알 수 있다.

<br/><br/><br/>

### 1바이트 부동소수점의 정밀도
- 1바이트 부동소수점 설계를 마쳤는데 석연치 않은 점이 하나 있다. <br/>변환 과정에서 가수부를 담을 공간이 부족해 가수부에 들어갈 데이터인 1111에서 맨 뒤에 있는 1을 누락했는데, 이렇게 되면 0x4f는 7.75라는 실수를 완벽하게 표현하지 못한다. <br/><br/>
- 1.111 x 2<sup>2</sup> = 1 x 2<sup>2</sup> 1 x 2<sup>1</sup> + 1 x 2<sup>0</sup> + 1 x 2<sup>-1</sup> = 7.5 <br/>0.25만큼 차이가 나므로 정밀도가 그만큼 떨어진다. 

<br/><br/><br/>

## 정밀도에 대한 고찰
### 엡실론
- 실수 자료형에서 엡실론(epsilon)이란 1.0과 그 다음으로 표현 가능한 수(representable float) 사이의 차이를 말한다.
<pre><code>import sys
sys.float_info.epsilon # 2.220446049250313e-16</code></pre>
- 위 코드는 sys 모듈의 float_info에 있는 epsilon을 출력한 결과이다. <br/><br/>
- 파이썬이 사용하는 배정도(double)의 가수부가 52비트라고 했다. <br/>1.0을 배정도에 맞춰 표현하면 다음과 같다. <br/>1.0000 …… 0000(0: 52개) × 2<sup>0</sup> <br/><br/>
- 배정도에서 1.0 다음으로 표현할 수 있는 수(representable float)는 다음과 같다. <br/>1.0000 …… 0001(0: 51개, 1: 마지막 비트) × 2<sup>0</sup> <br/><br/>
- 따라서 두 수의 차이는 다음과 같다. <br/>0.0000 …… 0001(0: 51개, 1: 마지막 비트) × 2<sup>0</sup>
- 이 수를 10진수로 바꾸면 엡실론 값이 나온다. <br/>2.220446049250313 × 10<sup>-16</sup>

<br/>

### 엡실론과 정밀도
- 어떤 실수가 있을 때 엡실론을 이용하면 그 실수 다음에 표현할 수 있는 수를 알아낼 수 있다. <br/>예를 들어, 배정도 실수 9.25를 부동소수점 방식으로 표현하면 1.00101 x 2<sup>3</sup>이다. <br/>이 식에서 지수 부분만 떼어 내 엡실론을 곱하면 이 실수와 다음 표현 가능한 수 사이의 차이를 구할 수 있다.
<pre><code>import sys
ep = sys.float_info.epsilon
a = 9.25
diff = (2**3)*ep  #1
diff # 1.7763568394002505e-15

b = a + diff      #2
b # 9.250000000000002</code></pre>
- #1에서 diff는 지수 부분인 2<sup>3</sup>에 엡실론을 곱한 값으로 9.25와 그 다음 표현 가능한 수 사이의 차이이다. <br/>#2에서 b는 a에 diff를 더했으므로 9.25 다음에 표현 가능한 수를 나타낸다.

<br/>

#### 9.25에 diff보다 작은 값을 더하면 어떻게 될까?
<pre><code>a # 9.25

half_diff = diff/2                  #1
half_diff # 8.881784197001252e-16   #2

c = a + half_diff                   #3
a = = c # True                      #4</code></pre>
- half_diff는 diff 값의 반절이다(#1). <br/>half_diff 역시 실수를 나눠서 얻은 값이니 실수이다(#2). <br/>a와 half_diff를 더해 c에 대입한다(#3). <br/>실수와 실수를 더했으므로 c는 반드시 a보다 커야 한다. <br/>그런데 a값과 c값이 같다고 나온다(#4). <br/><br/>
- a 값과 c 값이 같은 이유는 c에 더한 half_diff 값이 diff보다 작기 때문이다. <br/>diff는 9.25와 그 다음 표현 가능한 수 사이의 차이이므로 9.25에 diff보다 작은 값을 더한 수를 부동소수점 방식에서는 표현할 수 없다. <br/>달리 표현하면 정밀도가 떨어진다는 말이다.

<br/>

#### 부동소수점의 정밀도에 관한 예
<pre><code>a = (2.0)**53
a # 9007199254740992.0

b = a + 1.0
a = = b # True</code></pre>
- a는 1.0000 …… 0000(0: 52개) × 2<sup>53</sup>이다. <br/>a와 a 다음에 표현 가능한 수 사이의 차이는 2<sup>53</sup>에 엡실론을 곱해 구할 수 있으며 그 값은 2.0이다. <br/>그러므로 a에 1.0을 더한 b는 원래 의도한 값을 표현하지 못하고 a와 같은 값을 갖게 된다. <br/>1.0의 차이조차 표현할 수 없는 정밀도이다.

<br/>

> - 0.01을 100번 더했을 때 정확하게 1이 나오지 않는 이유를 알 수 있다. <br/>
> - 부동소수점은 지수부에 따라 아주 작은 수와 아주 큰 수를 표현할 수 있지만, 어떤 상황에서는 16과 17같이 큰 단위의 정수조차 제대로 표현할 수 없을 때도 있다. <br/>'표현 범위는 넓지만 정밀도는 낮다'는 말의 의미를 정확하게 이해할 수 있다.

---

<br/><br/><br/><br/>

# 4장 문자와 문자열
- 수와 함께 가장 많이 사용되는 기본 자료형은 문자와 문자열이다. <br/>프로그래밍을 하다 보면 문자열을 다룰 일이 많다.

<br/><br/><br/>

## 아스키코드
- 문자 인코딩(character encoding)은 문자 집합을 메모리에 저장하거나 통신하는 데 사용하기 위해 부호화하는 방식을 말한다. <br/>대표적인 예로 모스 부호를 들 수 있다. <br/><br/>
- 문자 집합(character set)은 문자(character)를 모아 둔 것이다. <br/>예를 들면 라틴 문자가 있다. <br/>주목할 점은 다양한 언어(영어, 프랑스어, 독일어 등)가 라틴 문자를 사용한다는 점이다. <br/><br/>
- 0과 1밖에 모르는 컴퓨터에 문자를 인식시키려면 문자를 0과 1로 이루어진 2진수로 나타내야 한다. <br/>문자 하나에 정수 하나를 매핑해 두면 이 정수는 특정 문자를 표현하게 된다. <br/>이렇게 매핑된 정수를 코드 포인트(code point)라고 하고, 문자와 문자에 매핑된 코드 포인트를 모아 놓은 집합을 부호화횐 문자 집합(Coded Character Set, CCS)이라고 한다.

<br/>

- 아스키(American Standard Code for Information Interchange, 미국정보교환표준부호)는 대표적인 문자 인코딩 방식이다. <br/>비트 일곱 개로 문자를 표현하므로 문자를 총 128개까지 표현할 수 있다. <br/>당연히 코드 포인트 수도 128개이다.

![image](https://user-images.githubusercontent.com/61584142/159110367-3ab3974d-d35e-40ba-823d-2e9c87ac19cd.png)

- 0부터 127까지 총 128개 코드 포인트에 128개 문자가 매핑된 것을 확인할 수 있다. <br/>처음에 보이는 네 개의 열(Decimal, Hexadecimal, Binary, Octal)은 코드 포인트를 진수별로 변환한 것이고 마지막 열(Char)은 해당 코드 포인트에 매핑된 문자이다.

<br/>

- 예를 들어 대문자 'A'는 10진수로는 65고 16진수로는 0x41이다. <br/>소문자 'a'는 10진수로는 97이고 16진수로는 0x61이다. <br/>숫자 문자인 '0'은 10진수로는 48이고 16진수로는 0x30이다.
<pre><code>ch = 'A'
bch = ch.encode()
bch # b'A'

bch[0] # 65</code></pre>
- 마지막 출력 값을 보면 대문자 'A'가 정수 65와 매핑되었음을 알 수 있다. 

<br/>

<pre><code>ch_0 = '0'
bch_0 = ch_0.encode()
bch_0 # b'0'

bch_0[0] # 48</code></pre>
- 숫자 문자 '0'은 정수 48과 매핑되었음을 알 수 있다. <br/>

<br/>

- 아스키코드를 보면 정수 0부터 127까지 문자와 매핑되어 있다. <br/>2진수로 0000 0000(0)부터 0111 1111(127)까지이므로 표현하는 데 최대 7비트가 필요하다. <br/>정수를 나타내는 데 쓰는 자료형은 바이트 수에 따라 다양한데, int형이 가장 많이 쓰인다. <br/>int형은 32비트 컴퓨터에서 일반적으로 4바이트(32비트)이다. <br/>이보다 작은 short형은 2바이트(16비트)이다. <br/>아스키코드를 표현하는 데 7비트면 충분하므로 int형이나 short형을 쓰면 메모리가 낭비된다. <br/>그래서 문자를 표현하기 위해 char형이라는 새로운 정수 자료형을 만들었다. <br/>char형은 문자를 담기 위해 만들어진 자료형이지만 정수 자료형이므로 작은 수를 표현하는 데 사용하기도 한다.

<br/><br/><br/>

## 유니코드
- 아스키코드를 보면 알파벳만 있고 한글이 없다. <br/>아스키코드만 보면 우리는 컴퓨터에서 한글을 사용할 수 없을 것 같다. <br/>하지만 우리는 컴퓨터에서 한글을 쓰고 있다. <br/>한글은 아스키코드의 범위를 벗어나는데 우리는 어떻게 한글을 쓰고 있는 걸까? <br/><br/>
- 전 세계적으로 컴퓨터가 보급되고 인터넷을 통해 세계 각국의 사람들이 커뮤니케이션을 하면서 컴퓨터에서 쓸 수 있는 언어가 좀 더 많이 필요해졌다. <br/>이때 나온 해결 방법이 7비트로 표현한 문자를 16비트로 확장하는 것이었다. <br/>7비트일 때는 128개 문자를 표현할 수 있지만 16비트로 확장하면 65,536개 문자를 표현할 수 있다. <br/>여기에 더해 수 하나에 다시 문자 하나를 일대일로 대응한 새로운 표를 만들었는데, 이 테이블이 바로 유니코드이다. <br/><br/>
- 이에 처음부터 새로 대응한 것은 아니고 아스키코드인 0x0000부터 0x007F(2진수 0000 0000 0000 0000 ~ 0000 0000 0111 1111 즉, 기존 아스키코드 앞에 0으로 채워진 8비트를 붙인 것)까지는 그대로 유지하고 이후부터 숫자 하나에 문자 하나씩을 대응하였다. <br/>문자에는 한글, 중국어, 일본어 같은 언어 대부분이 포함되어있다. <br/><br/>
- 유니코드를 만든 사람은 여기서 한발 더 나아갔다. <br/>아스키코드를 만들었을 때 문자를 표현할 숫자가 모자라는 상황을 예측하지 못했듯이, 이번에도 2바티으면 충분할 것 같지만 미래는 알 수 없는 일이기 때문이다. <br/>언어 대부분이 포함된 이 첫 번째 테이블을 기본 다구어 평면(Basic Multilingual Plane, BMP)이라 이름 짓고, 이러한 테이블을 총 열일곱 개나 준비해 두었다(이 평면 중 대부분은 아직 정의되지 않았다). <br/><br/>
- 유니코드를 알게 되었으니 우리의 관심사는 한글이다. <br/>한글을 기본 다국어 평면 어디부터 어디까지에 위치해 있을까? <br/>한글은 U+AC00부터 U+D7AF까지에 자리 잡고 있다. <br/>U+는 유니코드라는 의미고 2바이트 수인 AC00은 한글 '가'를 의미한다.

<br/>

![image](https://user-images.githubusercontent.com/61584142/159110864-c2dacb43-4159-41b2-adee-6cc3aff155f0.png)

- 유니코드는 어떻게 읽을까? <br/>왼쪽에 위치한 숫자 AC00을 보면 해당하는 열에서 0을 더한 숫자 AC00이 '가'를 의미한다. <br/>AC00에 1을 더한 AC01은 '각'을 의미한다.

![image](https://user-images.githubusercontent.com/61584142/159110895-782a6525-4dd9-4a03-9eee-9ed9862561a8.png)

<br/>

- 파이썬에서도 유니코드 문자를 확인할 수 있다.
<pre><code>'\uAC00' # '가'
'\uAC01' # '각'</code></pre>

<br/><br/><br/>

## 유니코드 인코딩 방식
- 코드 유닛(code unit)은 코드 포인트를 특정한 방법으로 인코딩했을 때 변환되어 얻어지는 비트의 나열을 말한다. <br/><br/>
- 문자 인코딩 방식(Character Encoding Scheme, CES)은 코드 유닛을 옥텟으로 나열하여 변환하는 방법이다. <br/>옥텟(octet)은 데이터의 단위로 8비트를 의미한다. <br/>지금은 1바이트를 당연히 8비트라고 생각하지만, 예전에는 1바이트가 반드시 8비트는 아니었으므로 옥텟이라는 용어를 따로 사용했다. <br/>현재 컴퓨터는 모두 8비트 단위를 사용하므로 코드 유닛을 옥텟으로 변환해도 실제로 비트가 바뀌지는 않는다. <br/><br/>
- 유니코든느 2바이트로 숫자 하나에 문자 하나를 대응하여 문자를 표현한다. <br/>기본 다구그어 평면을 포함해 평면이 열일곱 개 있으므로 모든 문자를 표현하려면 3바이트가 필요하다. <br/>언뜻 생각하면 코드 유닛의 크기를 3바이트로 하고 코드 포인트를 그대로 저장하면 될 것 같지만 그렇게 쉽게 결정할 문제가 아니다. <br/><br/>
- 만약 1바이트 정수만 저장할 수 있는 시스템이라면 3바이트짜리 정수는 저장할 수 없으므로 이 시스템에서는 한글을 표현할 수 없다. <br/>그러므로 다양한 코드 유닛을 갖는 인코딩 방식을 두어 유연하게 대처해야 한다. <br/>유니코드 인코딩 방식에도 다양한 종류가 있지만 여기서는 UTF-8, UTF-16, UTF-32에 대해서만 다루겠다. 

<br/>

#### 인코딩 방식에 따른 자료형 C++ 코드
<pre><code>char * str1 = u8"가";
char16_t * str2 = u"가";
char32_t * str3 = U"가";</code></pre>

<br/>

### encode() 함수
- 파이썬에서 encode() 함수는 문자를 주어진 유니코드 인코딩 방식에 따라 코드 유닛을 나열하는 방식으로 변환하는 함수이다. <br/>
- 다음은 한글 '가'(유니코드 코드 포인트: U+AC00)를 각 인코딩 방식으로 변환한 결과이다.
<pre><code>ch = '가'
ch.encode() # b'\xea\xb0\x80'

ch.encode('UTF-8')  # b'\xea\xb0\x80'
ch.encode('UTF-16') # b'\xff\xfe\x00\xac'
ch.encode('UTF-32') # b'\xff\xfe\x00\x00\x00\xac\x00\x00'</code></pre>
- encode() 함수의 인자 중 하나인 인코딩 방식을 각각 다르게 적용하면 결과 값과 크기가 모두 다르게 나타나는 것을 확인할 수 있다. <br/>encode() 함수의 인자에 아무것도 전달하지 않으면 'UTF-8'이 인자일 때와 값이 같으므로 파이썬에서는 기본값이 UTF-8이라는 것도 알 수 있다.

<br/>

### UTF-8
- UTF-8(Universal Coded Character Set Transformation Format-8 bit)은 유니코드 인코딩 방식 중 하나로 유니코드 문자 하나를 1바이트에서 4바이트 사이에서 표현한다. <br/>유니코드 코드 포인트가 U+0000 ~ U+007F는 1바이트, U+0080 ~ U+07FF는 2바이트, U+0800 ~ U+FFFF는 3바이트, 나머지는 4바이트로 표현한다. <br/>문자에 따라 바이트 수가 달라지므로 가변 길이 인코딩 방식이라고 부른다.
<pre><code>char * str1 = u8"가";</code></pre>
- 문자열 "가" 앞에 붙은 u8은 UTF-8을 의미한다. <br/>str1은 UTF-8로 인코딩된 문자열 "가"가 저장된 메모리 공간을 가리킨다. <br/>주목해야 할 점은 유니코드인데도 1바이트짜리 char 자료형에 데이터를 담는다는 점이다. <br/>문자 '가'의 코드 포인트 U+AC00은 U+0800 ~ U+FFFF 사이의 수이므로 3바이트로 표현될 것이다. <br/><br/>

![image](https://user-images.githubusercontent.com/61584142/159111173-143e1dd1-efac-4aa0-bfee-41a246df62d9.png)
- UTF-8로 인코딩된 문자 '가'가 실제 메모리에 어떻게 저장되어 있는지 보여준다. <br/>예상대로 3바이트로 표현되어 있다(메모리 주소는 큰 의미가 없다).

<br/>

#### U+AC00은 어떻게 0xEAB080으로 변환되었을까?
- UTF-8에서 코드 포인트가 U+0800에서 U+FFFF 사이인 문자는 다음과 같은 포맷으로 변환된다.

![image](https://user-images.githubusercontent.com/61584142/159111308-9cddf23b-bb97-450b-978d-59fc355cfa15.png)

<br/>

- 포맷을 천천히 살펴보자. <br/>이 포맷에서 맨 앞에 있는 111은 바이트 수를 나타낸다. <br/>1바이트로 표현되면 1, 2바이트로 표현되면 11, 3바이트로 표현되면 111이다. <br/>X로 표시된 부분은 문자의 코드 포인트를 2진수로 변환한 후 차례대로 채운다. <br/><br/>

- 문자 ‘가’의 코드 포인트 U+AC00을 2진수로 표현하면 다음과 같다.

![image](https://user-images.githubusercontent.com/61584142/159111334-6f3b7675-d23d-4d89-9b8d-1c101df8fb33.png)

<br/>

- 포맷의 X를 보면 첫번째 등장하는 X는 4자리, 그 다음은 6자리, 마지막은 6자리이다. <br/>이 자리수에 맞춰 변환해 둔 2진수 수(문자 ‘가’의 코드 포인트)를 표현해 보자.

![image](https://user-images.githubusercontent.com/61584142/159111350-ff9a2090-6e08-4b00-95d4-ea9bdb20d8a1.png)

<br/>

- 이제 포맷의 X를 이 수로 채운다.

![image](https://user-images.githubusercontent.com/61584142/159111357-314ce5fb-9df8-47e2-a86d-2071368c9533.png)
- 이를 16진수로 변환하면 0xEAB080 이다.

<br/><br/>

### UTF-16
- UTF-16도 유니코드 인코딩 방식 중 하나로 2바이트 단위로 문자를 표현한다. <br/>해당 문자가 기본 다국어 평면에 있으면 2바이트로 인코딩되고, 그렇지 않으면 4바이트로 인코딩된다. <br/>코드 유닛의 크기는 16바이트이다.
<pre><code>char16_t * str2 = u"가";</code></pre>
- 문자열 "가" 앞에 붙은 소문자 u는 UTF-16으로 인코딩하겠다는 의미이다. <br/>char16_t는 C++ 언어에서 UTF-16 인코딩 방식으로 변환된 데이터를 담기 위해 만들어진 자료형으로 2바이트이다. <br/>그러면 문자 ‘가’는 메모리에 어떻게 저장되어 있을까?

<br/>

#### 문자 ‘가’가 UTF-16으로 인코딩되어 메모리에 담긴 모습이다.
![image](https://user-images.githubusercontent.com/61584142/159111426-727cf80f-77ca-4745-8877-dda2fad7dee8.png)
- 값이 매우 낯익다. <br/>문자 '가'의 코드 포인트인 AC00을 바이트 단위로 순서만 바꾸었다. <br/>문자 '가'는 기본 다국어 평면에 있으므로 2바이트로 표현된다.

<br/><br/>

### UTF-32
- 유니코드 인코딩 방식의 하나로 모든 문자를 4바이트로 표현한다. <br/>코드 유닛의 크기는 32비트이다.
<pre><code>char32_t * str3 = U"가";</code></pre>
- UTF-32는 모든 문자를 4바이트 단위로 인코딩하므로 기본 다국어 평면의 문자뿐만 아니라 모든 평면에 있는 문자를 한 개 단위로 담을 수 있다. <br/> char32_t는 4바이트 자료형으로 UTF-32로 인코딩된 데이터를 담기 위해 만들어졌다. <br/><br/>

<br/>

#### 문자 ‘가’가 UTF-32로 인코딩되어 메모리에 담긴 모습이다.
![image](https://user-images.githubusercontent.com/61584142/159111474-8ccd4f8b-a52c-45d0-965a-107e0b199a97.png)
- 모든 문자가 4바이트로 표현되므로 문자 '가'도 4바이트로 표현된다.

<br/><br/><br/>

## 파이썬 문자열의 특징
- C/C++에서는 문자열을 변수로 만들면 요소인 문자를 변경할 수 있고, 문자열을 상수로 만들면 요소를 변경할 수 없다. <br/>즉, 프로그래머가 변경 가능성을 선택할 수 있다. <br/><br/>
- 하지만 파이썬의 문자열은 요소를 변경할 수 없다. <br/>변경을 시도하는 순간 오류가 발생한다.
<pre><code>string = 'abcde'
string[2] = 'a'</code></pre>

```
Traceback (most recent call last):
    File "<pyshell#3>", line 1, in <module>
       string[2] = 'a'
TypeError: 'str' object does not support item assignment
```

<br/>

- 문자열 string에서 가운데 위치한 c를 x로 변경하고 싶다면, 문자열 슬라이싱(slicing)을 사용해 요소를 변경한다. <br/>주의해야 할 점은 string의 요소를 직접 변경하지 않았다는 점이다.
<pre><code>new_string = string[:2] + 'x' + string[3:]
new_string # 'abxde'</code></pre>

<br/>

- 파이썬에서 문자열을 변경하는 다른 방법도 있다. <br/>내장함수(Built-in function)중 하나인 replace() 함수를 사용하여 변경하는 방법이다. <br/>replace() 함수 인자에 기존 문자열과 바꿀 문자열을 전달하면 바뀐 문자열을 반환한다. <br/>하지만 이번에도 string의 요소를 직접 변경하지 않았다.
<pre><code>string = 'abcde'
new_string = string.replace(‘c’, ‘x’)
new_string # ‘abxde’

string # ‘abcde’</code></pre>

<br/>

> 프로그래밍을 하다 보면 텍스트 파일을 열었을 때 문자가 깨지는 현상과 같은 문자 인코딩 문제를 종종 만나니다. <br/>이때 문자에 대한 지식이 부족하면 문제가 왜 발생했는지 파악하느라 오랜 시간을 보낼 수 있다. <br/>문자 인코딩에 대해 정확한 지식을 갖춰 두면 이럴 때 문제를 빠르게 파악할 수 있어 매우 유용하다.

---

<br/><br/><br/><br/>

# 5장 함수
- 프로그래밍에서는 함수의 작동 방식을 정확히 이해하는 것이 매우 중요하다. <br/>그러려면 전역 변수와 지역 변수와 스택 프레임을 먼저 알아야 한다. <br/>그런 다음에는 함수를 호출할 때 인자를 전달하는 방식에 따라 실행 결과가 어떻게 달라지는지 이해해야 한다.

<br/><br/><br/>

## 함수를 시작하기 전에
### 자료 구조 미리 엿보기
- 함수의 작동 원리를 이해하려면 스택의 개념을 반드시 알아야 한다. <br/>스택은 접시 쌓기라고 생각하면 된다. <br/>데이터를 저장할 때 접시처럼 차곡차곡 쌓아 올리고, 데이터를 꺼낼 때는 접시처럼 맨 위부터 차례차례 내린다. <br/>즉, 마지막에 들어온 데이터가 가장 먼저 나간다. 

<br/>

### 전역 변수와 지역 변수
#### 전역 변수
- 전역 변수(global variable)는 전체 영역에서 접근할 수 있는 변수이다. <br/>따라서 함수 안에서도 접근할 수 있어야 한다.
<pre><code>g_var = 10         #1

def func():
    print("g_var = {}".format(g_var))

if __name__ = = "__main__":
    func()</code></pre>

`g_var = 10`

- g_var은 전역 변수이다(#1). <br/>함수 안에서 전역 변수에 접근했고, 실행 결과를 보면 접근이 가능하다는 것을 알 수 있다.

<br/>

- 이번에는 함수 안에서 전역 변수의 변경을 시도해 보자.
<pre><code>g_var = 10       #1

def func():
    g_var = 20   #2
    print("g_var = {} in function".format(g_var))  #3

if __name__ = = "__main__":
    func()
    print("g_var = {} in main".format(g_var))      #4</code></pre>
```
g_var = 20 in function
g_var = 10 in main
```
- 전역 변수 g_var을 선언했고(#1) 함수 안에서 g_var 값의 변경을 시도한다(#2). <br/>전역 변수가 함수 안에서 변경되었는지 출력하여 확인해 보자(#3). <br/>또한 함수 바깥 즉, 함수를 호출한 쪽에서 변경되었는지도 출력해 확인해 보자(#4).<br/><br/>
- 실행 결과를 보면 당혹스럽다. <br/>분명 함수 안에서는 g_var 값이 20으로 변경되었는데 함수 바깥에서 확인해 보니 바뀌지 않았다. <br/>왜 이런 결과가 나온걸까? <br/>그 이유는 함수 안에서 전역 변수 g_var 값의 변경을 시도하기 위해 선언한 #2는 전역 변수를 변경하는 것이 아니라 함수 안에서 새로운 지역 변수 g_var을 생성한 것이기 때문이다.

<br/>

#### 지역 변수
- 지역 변수(local variable)는 전역 변수와 반대 개념이다. <br/>말 그대로 특정 지역에서만 접근할 수 있는 변수이다. <br/>특정 지역은 함수 내부를 의미한다. <br/>따라서 함수 안에서 선언한 변수가 지역 변수이다. <br/>지역 변수는 함수 바깥에서는 접근할 수 없고 함수가 호출될 때 생성되었다가 호출이 끝나면 가라진다. <br/><br/>
- 함수 안에서 변수를 선언하는 #2는 지역 변수를 생성하는 코드이다. <br/>함수 안에서 전역 변수를 변경하려면 특별한 문법이 필요하다.
<pre><code>g_var = 10            #1

def func():
    global g_var      #2
    g_var = 20        #3

if _ _name__ = = "__main__":
    print("g_var : {} before".format(g_var))
    func()
    print("g_var : {} after".format(g_var))</code></pre>

```
g_var = 20 in function
g_var = 10 in main
```
- 코드를 보면 #1에서 선언한 전역 변수를 #3에서 변경하였다. <br/>실행 결과를 보면 잘 변경된 것을 확인할 수 있는데 그 이유는 #2에서 global 키워드를 이용해 전역 변수 g_var을 함수 안에서 사용하겠다고 명시했기 때문이다. <br/>따라서 #3은 지역 변수를 따로 생성한 것이 아니라 전역 변수 g_var을 변경하는 것을 의미한다. <br/><br/>

##### 전역 변수에 대한 접근과 변경에 대해 알아보았으니 지역 변수의 특징에 대해서도 알아보자.
#### nonlocal 키워드
- 함수 안에서 전역 변수를 변경할 수 있다는 것을 알았다. <br/><br/>
- 함수를 정의할 때 함수 내부에서 다른 함수를 정의할 수 있다.
<pre><code>def outer():
    a = 10          #1

    def inner():
        b = 20      #2</code></pre>
- 코드에서 outer() 함수에 지역 변수 a가 선언되었고(#1), 중첩된 함수 inner() 함수에 지역 변수 b가 선언되었다(#2). <br/>한 가지 생각해 볼 문제는 inner() 함수에서 outer() 함수의 지역 변수인 a를 변경할 수 있는지이다. <br/>변수 a는 outer() 함수 입장에서는 지역 변수지만 inner() 함수 입장에서는 지역 변수가 아니다. <br/>inner() 함수의 지역 변수는 b이다.

<br/>

<pre><code>a = 1

def outer():
    b = 2
    c = 3
    print(a, b, c)
    def inner():
        d = 4
        e = 5
        print(a, b, c, d, e)        #1
    inner()

if __name__ = = "__main__":
    outer()</code></pre>
    
```
1 2 3
1 2 3 4 5
```
- 코드를 보면 outer() 함수의 공간에 b와 c가 있고 중첩된 inner() 함수의 공간에는 d와 e가 있다. <br/>inner() 함수에서는 전역 변수뿐만 아니라 outer() 함수의 공간에 있는 지역 변수에도 접근할 수 있다(#1). <br/>하지만 전역 변수 예제에서 살펴본 것처럼 inner() 함수 안에서 b와 c를 바꾸려고 시도하면 outer() 함수 공간에 접근하는 것이 아니라 inner() 함수 공간 안에 b와 c라는 지역 변수를 생성한다. <br/>b나 c는 전역 변수가 아니니 global 키워드를 사용할 수도 없다. <br/>inner() 함수 안에서 b와 c를 변경하려면 nonlocal 키워드를 사용하면 된다.

<br/>

<pre><code>def outer():
    a = 2           #1
    b = 3

    def inner():
        nonlocal a  #2
        a = 100     #3
    inner()

    print(
    "locals in outer : a = {}, b = {}".format(a, b))
if __name__ = = "__main__":
    outer()</code></pre>

```
locals in outer : a = 100, b = 3
```
- 코드를 보면 #1에서 선언한 outer() 함수의 지역 변수 a를 #3에서 변경하였다. <br/>실행 결과를 보면 잘 바뀌었다. <br/>#2에서 nonlocal 키워드로 inner() 함수 안에서 outer() 함수의 지역 변수 a를 사용할 것이라고 선언했기 때문이다.

<br/><br/><br/>

## 인자 전달 방식에 따른 분류
- 이번에는 함수의 작동 원리를 알아보자. <br/>함수는 인자(argument) 전달 방식에 따라 크게 값에 의한 전달(call by value)과 참조에 의한 전달(call by reference)로 나누어진다. <br/>프로그래밍을 공부할 때 꼭 한 번은 거쳐야 하는 개념이다. <br/>파이썬은 값에 의한 전달과 참조에 의한 전달 방식을 이용하지 않으므로 두 가지 전달 방식을 파이썬으로 설명하기는 어렵다.

<br/><br/>

### 값에 의한 전달
```
#include <iostream>
using namespace std;

void change_value(int x, int value) // #1
{
    x = value;                      // #2
    cout << “x : “ << x << ” in change_value” << endl;
}

int main(void)
{
    int x = 10;                     // #3
    change_value(x, 20);            // #4
    cout << “x : “ << x << ” in main” << endl;

<span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
}
```

#### 실행결과

```
x : 20 in change_value
x : 10 in main
```

<br/>

#### 코드를 읽는 데 필요한 C++ 문법 요약
- #include나 using 부분은 신경 쓰지 않아도 된다. <br/>주목해야 할 곳은 #1의 함수 정의 부분이다. <br/>파이썬은 변수를 선언할 때 자료형을 명시하지 않지만, C++에서는 컴파일러에 알려 줘야 하므로 반드시 명시해야 한다. <br/>같은 이유로 함수에서도 함수 정의 맨 앞에 반환형을 명시해야 한다. <br/>파이썬에서는 구현부를 보지 않으면 반환형을 알 수 없는 것과 대비된다.

<br/>

- 인자 전달 부분은 자료형이 명시되어 있는 것만 빼면 파이썬과 유사하다. <br/>함수 정의에서 등장하는 { } 기호는 스코프라고 하며 영역을 의미한다. <br/>우리는 전역 변수와 지역 변수를 공부했기 때문에 영역의 의미를 알고 있다. <br/>파이썬은 명시적인 { } 기호가 없는 대신에 들여쓰기(indentation)로 영역을 나타낸다. <br/>몇 가지 차이점만 빼면 파이썬과 C++의 문법은 비슷하다.

<br/>

- 코드에서 change_value() 함수는 인자 x와 value를 받아 x에 value를 대입한다. <br/>main() 함수에서 지역 변수 x에 10을 대입한 다음 change_value() 함수를 호출하면서 value 인자로 20을 전달했으므로 지역 변수 x 값은 20으로 바뀔 것 같지만, 실행 결과를 보면 예상과 다른 값이 출력된다.

<br/>

- 함수 안에서는 값이 변경되었지만 함수를 호출한 쪽에서는 값이 변경되지 않았다. <br/>지역 변수 x가 변경되지 않은 이유는 함수에 x가 전달될 때 값에 의한 전달 방식으로 전달되었기 때문이다. 

<br/>

- 함수가 호출될 때 메모리에는 '스택 프레임'이 생긴다. 스택프레임은 함수의 메모리 공간 즉, 지역 변수가 존재하는 영역이다.
- 간단한 함수를 정의하고 함수가 호출될 때 스택 프레임의 모습을 살펴보자(function/stack.cpp)
```
#include <iostream>
using namespace std;

int test(int a, int b);

int main(void)
{
    int a = 10, b = 5;     // #4
    int res = test(a, b);  // #5
    cout << “result of test : “ << res << endl;
    return 0;
}

int test(int a, int b)     // #1
{
    int c = a + b;         // #2
    int d = a - b;         // #3
    return c + d;
}
```
- test() 함수는 인자로 a와 b를 받고(#1), 지역 변수로 c와 d를 선언한다(#2, #2). 함수를 호출하면(#5) 아래 그림과 같은 스택 프레임이 메모리에 생긴다. 

![image](https://user-images.githubusercontent.com/61584142/160632521-7d1a15f5-1f82-4a2d-9292-5238ddef0f7b.png)

- 위의 그림은 test() 함수가 호출될 때 생기는 스택 프레임이다. 스택 프레임에는 함수를 호출한 다음 복귀할 주소 값 등 지역 변수 이외의 정보도 담고 있지만, 현재는 지역 변수에 초점을 맞추겠다. #1~#3에 있는 변수 a, b, c, d가 스택 프레임에 쌓여 있다.
- 그림을 좀 더 확장해보면, main() 함수도 함수이므로 스택 프레임을 갖는다. 
- main() 함수의 스택 프레임을 살펴보자.

<br/>

- 아래의 그림은 스택 프레임을 test() 함수를 호출한 main() 함수까지 확장한 모습이다.

![image](https://user-images.githubusercontent.com/61584142/160632996-d5b9ed24-976f-4549-b490-849c081cb3f0.png)

- 스택 프레임은 스택 메모리 공간에 생기는데 이 공간 역시 스택 자료 구조의 작동 원리를 따른다. main() 함수가 먼저 실행되므로 스택 프레임이 먼저 쌓이고 main() 함수 안에서 호출한 test() 함수의 스택 프레임은 그 위에 쌓인다. test() 함수가 모두 실행되면 test() 함수의 스택 프레임이 먼저 사라지고 이후에 프로그램이 종료되면 main() 함수의 스택 프레임이 사라진다.

<br/>

- 지금부터 이번 절에서 가장 중요한 이야기를 하겠다. 그림을 보면 main() 함수의 스택 프레임 공간에도 a와 b가 있고 test() 함수의 스택 프레임 공간에도 a와 b가 있다. 이 공간은 서로 독립된 공간이다. 코드의 #5에서 인자를 전달할 때 main() 함수 스택 프레임의 지역 변수인 a와 b를 전달한 것 같지만, 실제로는 test() 함수 스택 프레임의 지역 변수 a와 b에 값만 ‘복사’한 것이다. 이처럼 인자를 전달할 때 값을 복사해 전달하는 경우를 값에 의한 전달(call by value)이라고 한다. 말 그대로 값을 복사할 뿐이다.

<br/>

- 이번에는 코드의 #4에서 change_value() 함수를 호출할 때의 스택 프레임을 그려보고, main() 함수의 지역 변수 x가 변경되지 않는 이유를 알아보겠다.
- 아래의 그림은 코드의 #2가 실행되기 직전에 본 스택 프레임 모습이다.

![image](https://user-images.githubusercontent.com/61584142/160633396-217190a6-894b-4107-b455-47f134e1b83e.png)

<br/>

- change_value() 함수 스택 프레임의 x와 main() 함수 스택 프레임의 x는 서로 다른 메모리 공간에 존재하는 서로 다른 변수다. 값만 10으로 같을 뿐이다.
- #2 코드가 실행된 다음에 스택 프레임이 어떻게 변했는지 살펴보면 아래의 그림과 같다.

![image](https://user-images.githubusercontent.com/61584142/160633522-672dc5fd-34bd-4026-9d15-28056ffa3f93.png)

<br/>

- x에 value 값을 대입했으므로 x 값은 20이다. 주목할 점은 서로 다른 변수이므로 main() 함수의 지역 변수 x 값은 변하지 않았다는 점이다. change_value() 함수는 change_value 스택 프레임의 지역 변수 x 값인 20을 출력하고, 실행이 끝나면 스택 프레임은 사라진다.
- 아래의 그림은 change_value() 함수의 호출을 완료한 다음에 살펴본 스택 프레임 모습이다.

![image](https://user-images.githubusercontent.com/61584142/160633744-f89e57f2-c8bf-48bb-b08c-1c688a07b5e4.png)

<br/>

- 이 상태에서 x 값을 출력하면 10이 출력된다. 이제 우리는 왜 코드에서 main() 함수 안의 지역 변수 x가 change_value() 함수 호출 후에도 값이 변경되지 않았는지 알았다. 인자를 값에 의한 전달 방식으로 전달했기 때문이다. 그렇다면 함수 호출로 x 값을 바꿀 수 있는 방법은 없을까? 참조에 의한 전달 방식으로 인자를 전달하면 된다. 다음 절에서 참조에 의한 전달 방식을 알아보고 코드를 수정해 x 값을 변경해 보자.

<br/><br/>

### 참조에 의한 전달

---

<br/><br/><br/><br/>

# 6장

---

<br/><br/><br/><br/>

# 7장

---

<br/><br/><br/><br/>

# 8장

---

<br/><br/><br/><br/>

# 9장

---

<br/><br/><br/><br/>

# 10장

---

<br/><br/><br/><br/>

# 11장

---

<br/><br/><br/><br/>

# 12장

---

<br/><br/><br/><br/>

# 13장

---

<br/><br/><br/><br/>

# 14장

---

<br/><br/><br/><br/>

# 15장

---

<br/><br/><br/><br/>
