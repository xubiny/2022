**컨테이너 인프라 환경 구축을 위한 쿠버네티스/도커**

<br/>

# 1. 새로운 인프라 환경이 온다
- IT만큼 빠르게 변화하는 분야가 없다. 엔지니어가 개발 환경을 만들어 제공하면 사용자(주로 개발자)는 그에 맞는 도구를 모두 설치해야 했던 온프레미스(on-premises) 환경은 이제 고전적인 인프라 환경이 됐다. 이제는 돈을 넣으면 자판기에서 미리 준비된 상품이 나오듯 이미 구성된 환경을 사용자가 필요에 따라 선택하고 조합해서 사용할 수 있게 제공되는 **서비스로서의 인프라 환경(IaaS, Infrastructure as a Service)** 이 됐다.

<br/>

- 인프라 환경이 빠르게 갖춰지는 만큼 소프트웨어도 빠르게 개발하고 적용되길 고대했다. 그래서 대두된 개발 방법론이 **애자일(agile)** 이다. 기존 개발 방법론인 폭포수(waterfall) 방법론은 계획 단계에서 설계와 환경을 완전히 구비한 후 예정된 목표를 달성해 나가지만, 애자일은 일정 주기를 정한 다음에 해당 주기에 맞춰 요구 사항을 만족하는 프로토타입을 만들고 이를 개선해 나가며 최종 목표에 점진적으로 접근한다.

<br/>

- 이런 애자일 방법론의 시대에 맞춰 인프라는 또 한 번 변화하고 있다. 사용자가 요구하는 인프라를 즉각 제공하는 주요 기능은 유지하면서, 사용자마다 독립적인 환경에서 개발해도 모두 동일한 결과를 얻을 수 있고 개발된 소프트웨어의 성능을 보장하며 인프라의 가용 리소스를 최대한 확보할 수 있는 그런 인프라 환경으로 말이다.

<br/><br/><br/><br/>

## 1.1 컨테이너 인프라 환경이란
- 컨테이너 인프라 환경은 컨테이너를 중심으로 구성된 인프라 환경이다. 여기서 **컨테이너(container)** 는 하나의 운영 체제 커널에서 다른 프로세스에 영향을 받지 않고 독립적으로 실행되는 프로세스 상태를 의미한다. 이렇게 구현된 컨테이너는 가상화 상태에서 동작하는 프로세스보다 가볍고 빠르게 동작한다.

<br/><br/>

### 1.1.1 모놀로식 아키텍처
- 모놀리식 아키텍처(monolithic architecture)는 하나의 큰 목적이 있는 서비스 또는 애플리케이션에 여러 기능이 통합돼 있는 구조를 의미한다. 모놀리식 아키텍처에서는 소프트웨어가 하나의 결합된 코드가 구성되기 때문에 초기 단계에서 설계하기 용이하며 개발이 좀 더 단순하고 코드 관리가 간편하다. 그러나 서비스를 운영하는 과정에서 수정이 많을 경우, 어떤 서비스에서 이뤄진 수정이 연관된 다른 서비스에 영향을 미칠 가능성이 커진다. 또한 서비스가 점점 성장해 기능이 추가될수록 처음에는 단순했던 서비스 간의 관계가 매우 복잡해질 수 있다.

<br/>

#### 모놀리식 아키텍처의 구성 예시
![image](https://user-images.githubusercontent.com/61584142/160961425-faa054df-ade3-4b18-a671-de9fd74b396b.png)

<br/>

- 그림처럼 뉴스, 카페, 웹툰, 결제 등의 서비스가 하나의 애플리케이션 안에 포함된 경우를 생각해보자. 보안이나 데이터베이스 접속과 같은 설정을 공통으로 사용하면서 서비스를 구현한다면 개발 속도는 매우 빠를 것이다. 하지만 웹툰 서비스의 사용량이 폭발적으로 증가해 서버를 증설해야 한다고 가정해 보자. IaaS 덕분에 사용량 증가에 따라 인프라를 증설하는 것은 어렵지 않다. 그렇지만 웹툰 서비스의 사용량이 늘었따고 해서 뉴스, 블로그 등의 다른 서비스가 포함된 애플리케이션까지 확장하는 것은 상당히 비효율적이다. 게다가 특정 서비스를 수정하는 과정에서 예기지 못한 에러가 발생한다면 해당 서비스 외에 전체 서비스를 이용할 수 없는 상황이 생길 수도 있다. 그래서 이러한 문제를 해결하는 방안으로 마이크로서비스 아키텍처가 등장했다.

<br/><br/>

### 1.1.2 마이크로서비스 아키텍처
- 마이크로서비스 아키텍처(MSA, Microservices Architecture)는 시스템 전체가 하나의 목적을 지향하는 바는 모놀리식 아키텍처와 동일하다. 하지만 개별 기능을 하는 작은 서비스를 각각 개발해 연결하는 데서 그 차이를 보인다. 보안, 인증 등과 관련된 기능이 독립된 서비스를 구성하고 있으며 다른 서비스들도 독립적으로 동작할 수 있는 완결된 구조이다.

<br/>

- 이런 구조는 개발된 서비스를 재사용하기 쉽고, 향후 서비스가 변경됐을 때 다른 서비스에 영향을 미칠 가능성이 줄어들며 사용량의 변화에 따라 특정 서비스만 확장할 수 있다. 따라서 사용자의 요구 사항에 따라 가용성을 즉각적으로 확보해야 하는 IaaS 환경에 적합하다. 하지만 마이크로서비스 아키텍처는 모놀리식 아키텍처보다 복잡도가 높으며 각 서비스가 서로 유기적으로 통신하는 구조로 설계되기 때문에 네트워크를 통한 호출 횟수가 증가해 성능에 영향을 줄 수 있다.

<br/>

#### 마이크로서비스 아키텍처의 구성 예시

![image](https://user-images.githubusercontent.com/61584142/160963444-e6747b83-159c-4de4-96a4-4a9e6fe429b6.png)

<br/>

- 하나의 애플리케이션 안에 포함돼 있던 뉴스, 블로그, 웹툰 서비스가 각 서비스와 관련된 기능과 데이터베이스를 독립적으로 가지는 구조로 표현됐다. 각 서비스는 API 게이트웨이와 REST(REpresentational State Transfer) API를 이용한 통신 방식으로 사용자(외부)의 요청을 전달한다. 서비스 개수는 고정된 것이 아니기 때문에 어떤 서비스가 등록돼 있는지 파악하기 위해 서비스 디스커버리를 사용한다. 또한 수많은 서비스의 내부 통신을 이벤트로 일원화하고 이를 효과적으로 관리하기 위해 별도로 이벤트 버스를 서비스로 구성한다.

<br/>

- 이런 구조 덕분에 각 서비스는 필요한 기능이 특화된 데이터베이스를 선택해 개별 서비스에 할당할 수 있다. 고객의 요구 사항에 따라 분석 서비스를 새로 추가해야 할 때도 기존에 있는 이벤트 버스에 바로 연결하며 되므로 매우 유연하게 대응할 수 있다. 각 서비스는 독립적으로 동작할 수 있는 완결된 구조라서 이미 개발된 기능이 다른 서비스에 필요하다면 바로 재사용할 수 있다.

<br/><br/>

### 1.1.3 컨테이너 인프라 환경에 적합한 아키텍처
- 그러면 컨테이너 인프라 환경에서는 어떤 아키텍처를 사용해야 좋을까? IT 세계에서는 대부분 정해진 답이 없다. 주어진 상황에 적합한 기술이 있을 뿐이다. 모놀리식 아키텍처로 구현을 시작했지만, 시스셈이 성장하고 기능이 늘어나면 마이크로서비스 아키텍처로 전환할 수도 있다.

<br/>

- 예전에는 기존 시스템을 확장하는 것은 시간과 비용이 많이 들어가는 복잡한 작업이자 변경된 시스템을 잘못 배포했을 때 전체 시스템 중단을 초래할 수 있는 위험한 작업이었다. 그러나 현재는 작은 단위로 빠르게 배포할 수 있으며 시스템 확장에 유연하게 대처할 수 있는 기반 기술이 충분히 마련돼 있다. 보통 중소기업에서 진행하는 소규모 프로젝트는 구현할 서비스 종류가 많지 않거나 규모가 크지 않아 모놀리식 아키텍처를 선호하는 경향이 있다. 하지만 소규모 프로젝트라도 마이크로서비스 아키텍처로 설계하면 기능에 집중한 안정적인 서비스를 구현할 수 있고 구현된 서비스를 재사용할 수 있으며, 해당 서비스를 다른 서비스와 연결해 구조화하기 때문에 장기적으로 볼 때 유지보수 측면에서 매우 유리하다.

<br/>

- 우리가 공부할 컨테이너 인프라 환경은 특히 마이크로서비스 아키텍처로 구현하기에 적합하다. 컨테이너 인프라 환경에서는 컨테이너를 서비스 단위로 포장해 손쉽게 배포하고 확장할 수 있다. 컨테이너 인프라 환경에서 제공하는 컨테이너는 마이크로서비스 아키텍처의 서비스와 1:1로 완벽하게 대응하며, 이후 소개할 도구들을 이용하면 도입, 설계, 운용 비용이 감소하고 생산성이 향상된다.

<br/>

#### 서비스와 1:1로 결합되는 컨테이너

![image](https://user-images.githubusercontent.com/61584142/160964050-3031867f-d54f-4329-95fa-428ae2507070.png)

<br/>

**그렇다면 컨테이너 인프라 환경을 지원하는 도구 중 현업에서 자주 사용하는 몇 가지를 간략하게 살펴보자.

<br/><br/><br/><br/>

## 1.2 컨테이너 인프라 환경을 지원하는 도구
- 컨테이너 인프라 환경은 크게 **컨테이너, 컨테이너 관리, 개발 환경 구성 및 배포 자동화, 모니터링** 으로 구성된다. 이를 지원하는 도구 가운데 업계에서 가장 많이 사용하는 도구 몇 가지를 알아보자.

<br/><br/>

### 1.2.1 도커
- 도커(Docker)는 컨테이너 환경에서 독립적으로 애플리케이션을 실행할 수 있도록 컨테이너를 만들고 관리하는 것을 도와주는 컨테이너 도구이다. 도커로 애플리케이션을 실행하면 운영체제 환경에 관계없이 독립적인 환경에서 일관된 결과를 보장한다. 컨테이너 도구는 도커외에도 컨테이너디(Containerd), 크라이오(CRI-O), 파드맨(Podman) 등이 있지만, 현업에서 가장 많이 사용하는 소프트웨어는 도커이다.

<br/><br/>

### 1.2.2 쿠버네티스
- 쿠버네티스(Kubernetes)는 다수의 컨테이너를 관리하는 데 사용한다. 컨테이너의 자동 배포와 배포된 컨테이너에 대한 동작 보증, 부하에 따른 동적 확장 등의 기능을 제공한다. 처음에는 다수의 컨테이너만 관리하는 도구였지만, 지금은 컨테이너 인프라 필요한 기능을 통합하고 관리하는 솔루션으로 발전했다. 쿠버네티스는 컨테이너 인프라를 기반으로 '1.1.2 마이크로 서비스 아키텍처'에서 설명한 API 게이트웨이, 서비스 디스커버리, 이벤트 버스, 인증 및 결제 등의 다양한 서비스를 효율적으로 관리할 수 있는 환경을 제공하고 이를 내외부와 유연하게 연결해 준다. 컨테이너 관리 도구는 도커 스웜(Docker Swarm), 메소스(Mesos), 노마드(Nomad) 등도 있지만, 오직 쿠버네티스만이 급격한 상승세를 보이고 있다.

<br/><br/>

### 1.2.3 젠킨스
- 젠킨스(Jenkins)는 지속적 통합(CI, Continuous Integrationg)과 지속적 배포(CD, Continuous Deployment)를 지원한다. 지속적 통합과 지속적 배포는 개발한 프로그램의 빌드, 테스트, 패키지화, 배포 단계를 모두 자동화해 개발 단계를 표준화한다. 아울러 개발된 코드의 빠른 적용과 효과적인 관리를 통해 개발 생산성을 높이는 데 초점이 맞춰져 있다. 즉 컨테이너 인프라 환경처럼 단일 기능을 빠르게 개발해 적용해야 하는 환경에 매우 적합한 도구이다. 지속적 통합과 배포를 위한 도구는 뱀부(Bamboo), 깃허브 액션(Github Action), 팀시티(Teamcity) 등도 있지만, 젠킨스가 가장 유명하고 대표적이다.

<br/><br/>

### 1.2.4 프로메테우스와 그라파나
- 프로메테우스(Prometheus)와 그라파나(Grafana)는 모니터링을 위한 도구이다. 프로메테우스는 상태 데이터를 수집하고, 그라파나는 프로메테우스로 수집한 데이터를 관리자가 보기 좋게 시각화한다. 컨테이너 인프라 환경에서는 많은 종류의 소규모 기능이 각각 나누어 개발되기 때문에 중앙 모니터링이 필요하다. 이때 효율적으로 모니터링하는 방법 중 하나가 프로메테우스와 그라파나의 조합이다. 프로메테우스와 그라파나는 컨테이너로 패키징돼 동작하며 최소한의 자원으로 쿠버네티스 클러스터의 상태를 시작적으로 표현한다.

<br/>

- 모니터링 데이터 수집 도구는 프로메테우스 외에도 데이터독(DataDog), 인플럭스DB(InfluxDB), 뉴 렐릭(New Relic) 등이 있지만, 오픈 소스를 활용하는 기업은 프로메테우스 외에 다른 선택지가 없을 정도로 가장 탁월한 효율을 자랑한다.

<br/>

- 데이터를 시각화하는 도구는 그라파나 외에도 키바나(Kibana), 크로노그래프(Chronograf) 등이 있으나 업계에서는 그라파나와 키바나가 시장을 양분한 상태이다. 하지만 키바나는 프로메테우스와 연결 구성이 복잡하므로 프로메테우스를 사용할 때는 간결하게 구성할 수 있는 그라파나를 더 선호한다.

<br/><br/><br/><br/>

## 1.3 새로운 인프라 환경의 시작
- 소규모로 빠르게 각 기능을 개발하는 마이크로서비스 아키텍처의 의미와 이를 효과적으로 지원하는 컨테이너 인프라 환경이 어떤 것인지 살펴봤다. 그리고 컨테이너 인프라 환경을 지원하는 도커, 쿠버네티스, 젠킨스, 프로메테우스, 그라파나 등의 도구도 소개했다.

<br/>

![image](https://user-images.githubusercontent.com/61584142/160972055-88661ab4-a0c1-4b21-a5a7-d55f32362c1a.png)

---

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

---

# 2. 테스트 환경 구성하기
- 먼저 2장에서는 가상 환경을 구성하는 데 사용하는 도구를 살펴본 다음, 직접 가상 환경을 구축해보자. 이떄 일관성 있는 결과를 얻으려면 프로젝트 환경이 가능한 한 일정하게 생성되고 유지돼야 한다. 그래서 여기서는 코드형 인프라로 인프라 환경을 일정하게 유지하고 구성한다. 코드형 인프라(IaC, Infrastructure as Code)란 쉽게 말해 코드로 하드웨어를 설정하고, 운영 체제를 설치하고, 네트워크를 구성하고, 개발 환경을 구축하는 것이다. 즉, 코드로 인프라를 소프트웨어처럼 다룰 수 있다.

<br/>

- 이렇게 설치된 환경은 사용자가 모두 동일한 환경에서 테스트할 수 있고, 문제가 발생했을 때 몇 번의 명령 실행만으로 환경을 다시 새것처럼 구성할 수 있다는 장점이 있다.

![image](https://user-images.githubusercontent.com/61584142/160975026-e5ae46c7-82a4-43bc-8049-8fea5357ebf1.png)

<br/><br/><br/><br/>

## 2.1 테스트 환경을 자동으로 구성하는 도구
- 코드로 인프라를 생성할 수 있게 지원하는 소프트웨어는 여러 개이지만, 교육용 및 소규모 환경에서는 베이그런트(Vagrant)가 가장 배우기 쉽고 사용 방법도 간단하다. 베이그런트는 가상화 소프트웨어인 버추얼박스(VirtualBox)와도 호환성이 매우 좋다.

<br/><br/>

### 2.1.1 버추얼박스 설치하기
- 버추얼박스는 이노테크(InnoTek)에서 개발한 가상화 소프트웨어로 오라클에서 배포한다. 버추얼박스는 현존하는 대부분의 운영 체제를 게스트 운영 체제로 사용할 수 있으며, 확장팩을 제외하면 아무런 제한 없이 소프트웨어의 모든 기능을 무료로 이용할 수 있다. 또한 다른 가상화 소프트웨어보다 기능이 강력하고 안정적이다.

<br/>

1. 웹 브라우저를 열고 버추얼박스 다운로드 페이지(https://www.virtualbox.org/wiki/Downloads)에 접속한다. 사용하는 운영 체제에 맞는 버전을 내려받는다.
2. 윈도용 버추얼박스 설치 파일에는 설치 마법사가 포함돼 있어 쉽게 설치할 수 있다. 내려받은 버추얼박스 설치 파일을 찾아 실행하고 설치 환영 메시지가 나오면 Next 버튼을 클릭한다.
3. 설치 경로를 포함한 여러 옵션이 나온다. 기본으로 설치하는 것이 가장 무난하므로 기본 상태 그대로 두고 Next 버튼을 클릭한다.
4. 버추얼박스를 바탕 화면에서 바로 실행할 수 있는 바로가기 아이콘을 만드는 화면이 나온다. 기본 옵션으로 진행하므로 마찬가지로 Next 버튼을 클릭한다.
5. 버추얼박스에서 사용할 네트워크 인터페이스를 위해 잠시 네트워크가 중단된다는 경고문이 뜬다. 다른 중요한 파일을 내려받고 있지 않다면 신경 쓰지 말고 Yes 버튼을 클릭한다.
6. 이제 설치할 준비가 다 됐으니 Install 버튼을 클릭한다. 시스템에 따라 설치 허용 여부를 묻는 경우가 있는데, 이런 경우 예 버튼을 클릭한다. 설치 도중에 시스템에 따라 추가 드라이버가 설치될 수도 있다.
7. 설치가 완료되면 화면에 체크 상태를 그대로 두고 Finish 버튼을 클릭해 설치 프로그램을 종료하고 버추얼박스를 실행한다.
8. 실행된 버추얼박스는 어떤 가상 머신도 없이 깨끗한 상태이다. 이제 베이그런트로 가상 머신을 생성해 보자.

<br/><br/>

### 2.1.2 베이그런트 설치하기
- 베이그런트는 사용자의 요구에 맞게 시스템 자원을 할당, 배치, 배포해 두었다가 필요할 때 시스템을 사용할 수 있는 상태로 만들어 준다. 이를 프로비저닝(provisioning)이라고 하는데, 프로비저닝을 하면 필요할 때 환경을 매우 쉽고 간단하게 구현할 수 있다. 베이그런트를 설치하는 방법은 다음과 같다.

<br/>

1. 웹 브라우저를 열고 베이그런트 다운로드 페이지(https://www.vagrantup.com/downloads.html)에 접속한다. 사용자 환경에 따라 자동으로 다운로드 페이지가 설정되므로 각자의 운영 체제에 맞는 설치 파일이 표시된다. 바로 내려받기(Download) 버튼을 눌러 베이그런트 설치 파일을 내려받는다. 윈도용 베이그런트 설치 파일에는 설치 마법사가 포함돼 있어 쉽게 설치할 수 있다.
2. 내려받은 베이그런트 설치 파일을 찾아 실행하고 설치 환영 메시지가 나오면 Next 버튼을 클릭한다.
3. 라이선스 동의에 체크하고, Next 버튼을 클릭한다.
4. 베이그런트의 설치 경로가 나온다. Change... 버튼을 눌러 원하는 폴더로 변경할 수 있지만, 여기서는 기본 설정 값 그대로 설치하므로 Next 버튼을 클릭한다.
5. 설치할 준비가 끝났으니 Install 버튼을 클릭해 설치를 시작한다. 시스템에 따라 설치 허용 여부를 묻는 경우가 있는데, 이런 경우 예 버튼을 클릭한다.
6. 설치가 완료되면 Finish 버튼을 클릭해 설치 프로그램을 종료한다.
7. 팝업 창이 뜨면 Yes 버튼을 눌러 시스템을 다시 시작해 변경 사항을 적용한다.

<br/><br/>

### 2.1.3 베이그런트 구성하고 테스트하기
- 테스트 환경을 구성하기 전에 설치된 도구가 정상적으로 작동하는지 확인해 본다. 먼저 프로비저닝을 위한 코드를 작성하고, 이를 베이그런트에서 불러온 후 버추얼박스에 운영체제를 설치한다.

<br/>

- 베이그런트의 프로비저닝 코드를 개인이 원하는 위치에 구현해 사용할 수 있으나 실습할 때 혼동하지 않도록 베이그런트 설치 디렉터리(C:\HashiCorp)에 프로비저닝에 필요한 모든 코드를 작성한다.

<br/>

1. 명령 프롬프트를 실행하고 베이그런트 설치 디렉터리로 이동한다. vagrant init(베이그런트 초기화) 명령을 실행해 프로비저닝에 필요한 기본 코드를 생성한다.
2. 베이그런트 초기화 명령으로 생성된 c:\HashiCorp 폴더의 Vagrantfile(베이그런트 스크립트 파일)을 에디터 프로그램(메모장 같은 문서 에디터, notepad++, VS Code 같은 코드 에디터 등 아무거나 상관없다)으로 열고 파일에서 config.vm.box = "base"라는 내용이 있는지 확인한다.

![image](https://user-images.githubusercontent.com/61584142/160975916-3f300a37-b85a-418a-bd90-3a6a3c077c75.png)

3. 아무것도 변경하지 않은 채 파일을 닫고 명령 프롬프트에서 vagrant up을 바로 실행한다. 그러면 다음과 같은 에러가 발생한다. 설치하려는 이미지가 'base'로 명시돼 있으나 베이그런트가 해당 이미지를 찾지 못해 발생하는 에러이다.
4. 에러가 발생하지 않게 설치할 운영 체제 이미지를 선택해 보자. 먼저 사용할 가상 머신의 이미지를 선택하고 필요에 맞게 이미지를 수정하는 과정이 필요한데, 이 과정이 복잡하고 험난하다. 가상 이미지는 베이그런트 클라우드(https://app.vagrantup.com/boxes/search)에 접속해 내려받는다. 검색창에 sysnet4admin을 입력하면 올려 둔 파일들이 보인다. 이 가운데 sysnet4admin/CentOS-k8s를 확인한다. 참고로 CetnOS-k8s에는 쿠버네티스 실습에 필요한 설정 변경 사항이 포함돼 있다. 자세한 내용은 https://app.vagrantup.com/sysnet4admin/boxes/CentOS-k8s를 참고한다.

![image](https://user-images.githubusercontent.com/61584142/160976057-e5294264-f040-4476-b93c-0198bd4d5f91.png)

5. 앞에서 확인한 Vagrantfile을 다시 열어 config.vm.box = "base"를 config.vm.box = "sysnet4admin/ CentOS-k8s"로 변경하고 저장한다.

![image](https://user-images.githubusercontent.com/61584142/160976093-cce3699b-c58d-403c-ac0e-fe8e9c785e3d.png)

6. 다시 한 번 vagrant up을 실행하고 해당 가상 머신 이미지를 내려받는지 확인한다.
7. 설치가 끝나면 버추얼박스를 실행해 가상 머신이 제대로 생성됐는지 확인한다.
8. 명령 프롬프트로 돌아와 vagrant ssh 명령을 실행해 설치된 CentOS에 접속한다.
9. 설치가 정상적으로 이루어졌는지 CentOS의 실행 시간(uptime)과 운영 체제의 종류(cat /etc/redhat-release)를 확인한다.
10. CentOS가 베이그런트로 버추얼박스에 아주 간단하게 설치됐다. 설치 테스트를 해봤으니 본격적으로 실습하기 위해 설치한 가상 머신을 삭제한다. 먼저 접속한 가상 머신을 exit로 빠져나온 다음 명령 프롬프트에서 vagrant destroy- f를 실행한다. 설치된 가상 머신이 삭제되는데, 여기서 -f는 가상 머신을 강제 종료하는 옵션이다.

<br/>

#### 자주 사용하는 베이그런트 명령
![image](https://user-images.githubusercontent.com/61584142/160975862-cc1c7e1f-f601-48f2-92af-e30dbae4ac88.png)

<br/><br/><br/><br/>

## 2.2 베이그런트로 테스트 환경 구축하기
- 베이그런트로 버추얼박스에 가상 머신을 설치하는 방법을 알아봤다. 이번에는 Vagrantfile을 수정해 원하는 구성이 자동으로 CentOS에 입력되도록 해 보자.

<br/><br/>

### 2.2.1 가상 머신에 필요한 설정 자동으로 구성하기
- 앞에서는 Vagrantfile에 기존에 있던 이미지 파일을 추가해 가상 머신을 생성했다. 이번에는 원하는 구성을 자동으로 생성할 수 있도록 Vagrantfile을 새롭게 작성해 보자. 베이그런트 코드는 루비(Ruby)라는 언어로 작성한다.

<br/>

#### 베이그런트로 구성되는 테스트 환경 구성도
![image](https://user-images.githubusercontent.com/61584142/160977465-2eaf5859-cefa-4cf7-87af-24fd9e9bc401.png)

<br/>

#### 코드 입력
- 앞에서 열어본 Vagrantfile을 다음과 같은 내용으로 수정한 후 저장한다.
<pre><code># -*- mode: ruby -*-
# vi: set ft=ruby :
Vagrant.configure("2") do |config|
  config.vm.define "m-k8s" do |cfg|
    cfg.vm.box = "sysnet4admin/CentOS-k8s"
    cfg.vm.provider "virtualbox" do |vb|
      vb.name = "m-k8s(github_SysNet4Admin)"
      vb.cpus = 2
      vb.memory = 2048
      vb.customize ["modifyvm", :id, "--groups", "/k8s-SM(github_SysNet4Admin)"]
    end
    cfg.vm.host_name = "m-k8s"
    cfg.vm.network "private_network", ip: "192.168.1.10"
    cfg.vm.network "forwarded_port", guest: 22, host: 60010, auto_correct: true, id: "ssh"
    cfg.vm.synced_folder "../data", "/vagrant", disabled: true
  end
end</code></pre>





