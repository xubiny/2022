# SQL 코딩의 기술
### SQL, 데이터베이스에 맞게 효율적으로 사용하라!
#### SQL 제대로 알고 쓰자
- SQL은 DBMS마다 조금씩 다른데, 약간의 차이만 알면 서로 다른 DBMS에서도 쉽게 변형해 사용할 수 있다. 대표적인 DBMS인 오라클, SQL Server, MySQL, PostgreSQL, 액세스에서 SQL을 사용하는 방법을 비교해 보여준다. 또한, 더 나은 데이터 모델을 설계하는 방법, 쿼리 성능을 향상시키는 인덱스 구현, 유연한 서브쿼리 작성법, 계층적 데이터 모델링처럼 SQL을 제대로 쓰는 방법도 알려준다.

<br/>

#### 더 나은 코딩 노하우를 배우자
다양한 팁과 기술을 현실성 있고 검증된 코드 예제와 함께 61가지 Better way에 수록했다. 해야 할 것과 피해야 할 것, 작업 효율을 높이는 법, 왜 이것이 최선의 선택인지 조언하며 SQL을 더 효과적으로 작성할 수 있게 해준다.

---

<br/><br/><br/><br/><br/><br/><br/><br/>

---

# 1. 데이터 모델 설계
- 데이터 모델을 잘못 설계하면 ‘효율적’인 SQL 작성은 시작도 할 수 없다. 데이터 모델이 제대로 된 정규화를 거쳐 올바른 관계로 정의되어 있지 않으면 SQL로 데이터에서 의미 있는 정보를 뽑아내기가 (가능하다고 해도) 어렵다. 이 장은 좋은 관계형 모델을 설계하는 기초 내용을 다룬다. 여러분이 설계한 데이터베이스가 여기서 다루는 규칙 중 어느 하나라도 위반한다면 잘못된 점을 찾아 수정해야 한다.

<br/>

데이터 모델 설계를 손댈 수 없다면 적어도 의미 있는 정보를 추출하기가 왜 어려운지 그 이유라도 이해해서 설계 담당자에게 가능한 해결책을 제시할 수 있어야 한다. 이 장에서 알려 준 정보를 활용하면 필요한 정보를 추출할 SQL을 작성하는 것이 왜 어렵거나 불가능한지 설명할 수 있을 것이다. 

<br/>

이 장에서는 데이터베이스 설계와 관련된 미묘한 내용까지 모두 다루기보다는 기본 내용만 다룬다.

<br/><br/><br/><br/>

## Better Way 1 - 모든 테이블에 기본키가 있는지 확인하자.
- 모든 테이블에는 하나 또는 일련의 컬럼으로 구성된 기본키가 있어야 한다.
- 키가 아닌 컬럼에 중복 값이 들어갈까 봐 걱정이 된다면, 해당 컬럼에 유일 인덱스를 정의해 무결성을 확보할 수 있다.
- 형태가 가능한 간단하고 값을 갱신할 필요가 없는 컬럼을 키로 사용한다.

<br/><br/>


### 복합 기본키(Compound Primary Key)는 다음 두 가지 이유에서 효율성이 떨어지므로 사용하지 않는 것이 좋다.

1.  기본키를 정의할 때 대부분의 데이터베이스 시스템은 해당 컬럼에 유일 인덱스를 같이 만든다. 컬럼 두 개 이상에 유일 인덱스를 만들면 데이터베이스 시스템이 할 일만 더 많아진다.

<br/>

2.  일반적으로 기본키로 조인을 수행하는데, 기본키가 여러 컬럼으로 구성되어 있으면 쿼리가 좀 더 복잡하고 느려진다.

<br/><br/>

관계형 모델을 따르려면 데이터베이스 시스템이 한 테이블에 있는 특정 로우와 나머지 로우를 구별할 수 있어야 하므로, 모든 테이블에는 컬럼 한 개 이상으로 구성된 기본키(Primary Key)가 있어야 한다.

<br/>

기본키는 로우마다 유일해야 하며 널(Null) 값을 가질 수 없다.

<br/>

안정적인 값이어야 한다(즉, 값을 갱신할 필요가 없다).

<br/>

가능한 한 간단한 형태여야 한다(예를 들어 문자나 부동소수점보다는 정수형이 낫고, 여러 컬럼보다는 단일 컬럼이 낫다).

<br/><br/><br/><br/>

## Better Way 2 - 중복으로 저장된 데이터 항목을 제거하자.
- 데이터베이스 정규화의 목표는 중복 데이터를 제거해 처리할 때 사용되는 자원을 최소화하는 것이다.
- 중복 데이터를 제거하면 비정상적인 삽입, 갱신, 삭제를 막을 수 있다.
- 중복 데이터를 제거하면 일관성 없는 데이터 발생을 최소화할 수 있다.

<br/><br/><br/><br/>

## Better Way 3 - 반복 그룹을 제거하자
- 데이터베이스 정규화의 목표는 데이터의 반복 그룹을 제거하고 스키마 변경을 최소화하는 것이다.
- 데이터의 반복 그룹을 제거하면 인덱싱을 사용해 데이터 중복을 방지할 수 있고 쿼리도 간소화할 수 있다.
- 데이터의 반복 그룹을 제거하면 테이블 설계가 더 유연해진다. 새로운 그룹을 추가할 때 테이블 설계를 바꿔서 새 컬럼을 추가하는 것이 아니라 단순히 또 다른 로우만 추가하면 되기 때문이다.

<br/><br/><br/><br/>

## Better Way 4 - 컬럼당 하나의 특성만 저장하자
- 올바른 테이블 설계는 개별 특성을 자체 컬럼에 할당한다. 한 컬럼에 여러 특성이 포함되어 있으면 검색이나 그루핑 작업이 가능하다고 해도 어렵기 때문이다.
- 일부 애플리케이션에서는 주소나 전화번호 같은 컬럼의 데이터 일부를 걸러 내려면 최소 수준의 데이터 조각으로 분할해야 한다.
- 보고서나 목록을 뽑으려고 특성들을 재결합할 때는 SQL의 문자열 연결 기능을 사용한다.

<br/><br/><br/><br/>

## Better Way 5 - 왜 계산 데이터를 저장하면 좋지 않은지 이해하자
- 많은 시스템에서 테이블을 정의할 때 계산 컬럼을 정의할 수 있지만 성능을 고려해야 한다. 특히 비결정적 표현식이나 함수를 사용할 때는 더욱 그렇다.
- 트리거를 사용해 계산 컬럼을 일반 컬럼처럼 정의할 수 있지만 작성해야 할 코드가 복잡하다.
- 계산 컬럼은 데이터베이스 시스템에 추가적인 부하를 일으키므로 계산 컬럼으로 얻는 혜택이 부하를 일으키는 비용보다 클 때만 사용한다.
- 대부분의 경우 저장 공간이 증가하고 데이터 갱신이 느린 대신 일부 혜택을 보려고 계산 컬럼에 인덱스를 만들고 싶을 것이다.
- 인덱스 적용이 어려울 때는 테이블에 계산 결과를 저장해 놓는 방법 대신 뷰를 이용해 수행할 계산을 정의하는 방법을 종종 사용한다.

<br/><br/><br/><br/>

## Better Way 6 - 참조 무결성을 보호하려면 외래키를 정의하자
- 명시적으로 외래키를 만들면 부모 테이블에 없는 로우를 가리키는 자식 테이블 로우가 없음을 보장할 수 있으므로 관련된 테이블 간에 데이터 무결성을 확인하는 데 좋다.
- 이미 데이터가 있는 테이블에  FOREIGN KEY  제약 조건을 추가할 때 이 제약 조건을 위반하는 데이터가 있다면 제약 조건을 생성하는 작업은 실패할 것이다.
- 일부 시스템에서는  FOREIGN KEY  제약 조건을 정의하면 자동으로 인덱스를 만들어 주므로 조인 성능이 향상될 수 있다. 다른 시스템은  FOREIGN KEY  제약 조건이 걸린 컬럼에서 수동으로 인덱스를 만들어야 한다. 일부 시스템은 인덱스 없이도 옵티마이저가 해당 컬럼을 특별 취급해 더 나은 쿼리 실행 계획을 세우기도 한다.

<br/><br/>

### 선언적 참조 무결성(Declarative Referential Integrity, DRI)을 정의했기 때문에 데이터베이스 시스템은 테이블 간의 관계를 알고 있다. 이런 관계를 정의하는 목적은 두 가지다.

1.  그래픽 쿼리 디자이너를 사용하면 데이터베이스에서 새로운 뷰나 저장 프로시저를 생성할 때 쿼리 디자이너가  JOIN  절을 올바르게 만들 수 있도록 도와준다.

<br/>

2.  일대다 관계에서 ‘다’에 해당하는 테이블에 데이터를 입력하고 변경하거나 ‘일’에 해당하는 테이블의 데이터를 변경하고 삭제할 때 데이터베이스 시스템이 데이터 무결성을 강화하는 데 도움을 준다.

<br/><br/><br/><br/>

## Better Way 7 - 테이블 간 관계를 명확히 하자
- 컬럼이 비슷한 테이블을 서로 병합해 관계를 간소화하는 것이 정말 타당한지 면밀히 검토한다.
- 데이터 타입이 일치한다면(또는 묵시적 타입 변환이 가능하다면) 두 테이블에 있는 컬럼 간 조인을 생성할 수 있는데, 이 관계는 해당 컬럼이 같은 도메인에 있을 때만 성립한다. 하지만 조인에 사용되는 두 컬럼의 데이터 타입은 동일한 것이 가장 좋다.
- 데이터 모델에서 실제로 정형 데이터를 다루고 있는지 확인한다. 다루는 데이터가 반정형이라면 필요한 대응책을 마련한다.
- 일반적으로 데이터 모델의 목표를 명확히 식별하면, 주어진 설계의 간소화와 데이터 모델을 사용하는 애플리케이션의 설계에 기인한 복잡성이나 이상 동작을 정당화하는지 판단하는 데 도움이 된다.

<br/><br/><br/><br/>

## Better Way 8 - 제3정규화로도 부족하다면 더 정규화하자
- 대부분의 데이터 모델에는 이미 더 높은 정규화가 적용되어 있을 가능성이 높다. 따라서 더 높은 정규화 형식을 명확히 위반하는지 면밀히 관찰해야 한다. 특히 복합키를 사용하거나 여러 다대다 관계에 참여하는 테이블일 때는 더욱 그렇다.
- 한 엔터티에서 관계가 없는 두 속성으로 가능한 모든 조합을 해당 엔터티에 열거해야 하는 특수한 경우에는 제4정규화를 위반할 수 있다.
- 제5정규화는 후보키가 모든 조인 의존성을 함축하는지 확인하는 것이다. 즉, 개별 요소에 근거해 후보키에 유효한 값이 무엇인지 제약할 수 있어야 한다는 말이다. 이것은 키가 복합키일 때만 발생한다.
- 제6정규화는 일반적으로 관계를 키가 아닌 속성 하나로만 줄이는 것이다. 따라서 테이블 개수가 급격히 늘어나지만 널 허용 컬럼을 정의할 필요가 없다.
- 무손실 분할 테스트는 해당 테이블이 더 높은 정규화 형식을 위반하는지 감지하는 효과적인 도구가 될 수 있다.

<br/><br/><br/><br/>

## Better Way 9 - 데이터 웨어하우스에는 역정규화를 사용하자
- 중복으로 저장할 데이터와 그 이유를 정한다.
- 데이터를 일치된 상태로 유지할 계획을 세운다.
- 역정규화된 필드를 사용하도록 쿼리를 리팩토링한다.

<br/><br/>

### 팩트 테이블의 유형을 다음 세 가지로 분류한다.

**1.  트랜잭션 팩트 테이블**  : 단일 시점에 측정된 데이터를 담은 테이블

<br/>

**2.  주기적 스냅샷 팩트 테이블**  : 재무 보고 기간처럼 미리 정의된 시간 동안 또는 그 마지막 시점의 데이터를 요약한 테이블

<br/>

**3.  누적 스냅샷 팩트 테이블**  : 주문 처리, 클레임 처리, 서비스 콜 처리, 대학 입학 등 시작과 끝 시점이 잘 정의된 예측 가능한 프로세스 데이터를 담은 테이블

---

<br/><br/><br/><br/><br/><br/><br/><br/>

---

# 2. 인덱스 설계와 프로그램적 처리
- 논리적으로 데이터 모델을 잘 설계했다는 이유만으로 효율적인 SQL을 작성할 수 있다고 여기면 안 된다. 물리적으로도 적절한 방식으로 설계를 구현해야 하며, 그렇지 않으면 SQL로 데이터에서 의미 있는 정보를 효율적으로 추출하기가 어렵다.

<br/>

테이블에 적절한 인덱스를 만들었는지 여부는 SQL 쿼리가 잘 수행되는지 확인하는 핵심 요소 중 하나다. 이 장은 올바르게 설계된 데이터 모델을 구현할 때 종종 간과하기 쉬운 내용을 이해하는 데 초점을 맞추었다. 테이블과 인덱스 생성은 데이터베이스 관리자(DBA)의 몫이지만, 인덱스 생성은 개발자가 수행하는 것이 최선이다. 데이터베이스 관리자는 스토리지 시스템 구성과 하드웨어 설정에 풍부한 지식이 있다. 그렇지만 인덱스를 적절히 만드는 문제는 수행되는 쿼리와 대상 데이터에 지식이 필요하다. 보통 데이터베이스 관리자나 외부 컨설턴트는 이런 지식을 습득하기가 힘들지만, 애플리케이션 개발자는 쉽게 알 수 있다. 이 장에서는 인덱스의 중요성을 이해하고, 인덱스를 적절히 구현하는 방법을 이해할 것이다.

<br/><br/><br/><br/>

## Better Way 11 - 인덱스와 데이터 스캔을 최소화하도록 인덱스는 신중히 만들자
- 적절한 인덱스를 만들도록 데이터를 분석해 성능을 향상한다.
- 생성한 인덱스가 실제로 잘 사용되는지 확인한다.

<br/><br/>

### 비클러스터 인덱스는 클러스터 인덱스와 구조가 같지만 다음 두 가지 면에서 다르다.

-  비클러스터 인덱스는 테이블 데이터가 쌓인 물리적인 순서와 다르게 정렬될 수 있다.

<br/>

-  비클러스터 인덱스의 리프 노드는 데이터를 포함하지 않고 인덱스 키와 데이터를 가리키는 북마크로 구성된다.

<br/><br/>

테이블 스캔보다 비클러스터 인덱스 스캔이 더 나은 성능을 발휘하는지 여부는 테이블 크기, 로우의 저장 패턴, 로우의 길이, 쿼리가 반환하는 로우의 비율에 따라 다르다. 흔히 전체 로우 중 최소 10%의 로우가 반환될 때 테이블 스캔이 비클러스터 인덱스보다 나은 성능을 보이기 시작한다. 클러스터 인덱스는 보통 반환되는 로우의 비율이 높을수록 테이블 스캔보다 나은 성능을 발휘한다.

<br/>

또 다른 중요한 고려 사항은 데이터에 접근하는 방식이다. 보통  WHERE  절에서 사용되지 않는 컬럼을 인덱스로 만들면 큰 혜택을 볼 수 없다. 앞에서 설명했듯이 컬럼의 카디널리티가 낮으면(인덱스 값의 다수가 같은 값일 때) 인덱스의 효과가 미미하다. 인덱스를 사용했지만 테이블에서 최소 비율 이하의 데이터만 읽게 된다면 데이터베이스 엔진은 인덱스를 사용하지 않을 것이다.

<br/>

게다가 인덱스는 테이블이 클 때만 사용하는 것이 좋다. 데이터베이스 엔진은 대부분 테이블이 작으면 그 데이터를 메모리에 올려놓는다. 데이터가 일단 메모리에 올라오면 여러분이 무슨 작업을 하든 빠르게 데이터를 탐색한다. 여기서 ‘작다’는 기준은 로우의 개수, 개별 로우의 크기, 페이지에 로드되는 방식과 데이터베이스 서버의 가용 메모리 용량에 의존함을 의미한다.

<br/><br/><br/><br/>

## Better Way 12 - 인덱스를 단순 필터링 이상의 목적으로 사용하자
- WHERE  절에 사용된 컬럼의 인덱스 유무는 쿼리 성능에 영향을 미친다.
- SELECT  절에 사용된 컬럼의 인덱스 유무 역시 쿼리 성능에 영향을 미칠 수 있다.
- 조인 조건에 사용된 컬럼의 인덱스 유무는 테이블 간 조인 성능에 영향을 미칠 수 있다.
- 인덱스는  ORDER BY  절의 효율에도 영향을 미칠 수 있다.
- 인덱스의 개수는 쓰기 작업에 영향을 미칠 수 있다.

<br/><br/><br/><br/>

## Better Way 13 - 트리거를 남발하지 말자
- 테이블을 생성할 때는 내장 기능으로 계산 컬럼과 제약 조건을 사용한 DRI 구현이 더 나은 성능을 보이므로, 제약 조건이나 계산 컬럼용 내장 기능을 사용하는 방법을 추천한다.
- 일반적으로 트리거는 이식성이 좋지 않다. 한 DBMS에서 생성한 트리거를 다른 DBMS에서 수정하지 않으면 제대로 동작하지 않는다.
- 트리거는 필요할 때만 사용한다. 가능하면 트리거가 멱등성(Idempotence)(한 번 적용한 결과나 두 번 반복해 적용한 결과나 모두 같음)이 있는지 확인한다.

<br/><br/>

### 트리거를 사용하는 것이 적절할 때.

**중복 또는 파생 데이터의 관리**  : 역정규화된 데이터베이스는 일반적으로 데이터를 중복으로 저장한다. 트리거로 이런 데이터를 동기화할 수 있다.

<br/>

**복잡한 컬럼 제약 조건**  : 컬럼의 제약 조건이 동일한 테이블의 다른 로우 또는 다른 테이블의 로우에 의존한다면, 트리거가 이 컬럼의 제약 조건을 유지하는 최상의 방법이다.

<br/>

**복잡한 기본 값**  : 다른 컬럼, 로우, 테이블에 있는 데이터를 기준으로 기본 값을 생성하는 데 트리거를 사용할 수 있다.

<br/>

**데이터베이스 간 참조 무결성**  : 관련 테이블을 두 데이터베이스에 나누었다면 트리거로 데이터베이스 간 참조 무결성을 확보할 수 있다.

<br/><br/><br/><br/>

## Better Way 14 - 데이터의 부분 집합을 포함하거나 제외하려면 필터링된 인덱스를 사용하자
- 필터링된 인덱스는 적은 비율의 로우에 인덱스를 사용할 때 저장 용량을 절약할 수 있어 유용하다.
- 필터링된 인덱스는 로우의 하위 집합에서 유일한 제약 조건을 구현하는 데 사용할 수 있다(예를 들어  WHERE active = 'Y'를 만족하는 로우).
- 필터링된 인덱스는 정렬 연산을 피하는 데 사용할 수 있다.
- 테이블 파티셔닝이 다른 인덱스 관리의 오버헤드 없이 필터링된 인덱스와 비슷한 혜택을 줄 수 있는지 고려한다.

<br/><br/><br/><br/>

## Better Way 15 - 프로그래밍으로 검사하는 대신 선언적 제약 조건을 사용하자
- 제약 조건 사용을 검토해 데이터 무결성을 강화한다.
- 쿼리 옵티마이저는 고성능 쿼리 실행 계획을 만드는 데 제약 조건을 사용할 수 있다.

<br/><br/>

SQL은 테이블 데이터 규칙을 명시하는 방식으로 제약 조건을 제공한다. INSERT, DELETE, UPDATE 작업이 일어날 때 모든 제약 조건이 검사된다. 이런 제약 조건을 위반하면 해당 작업은 진행되지 않는다.

<br/>

### 다음은 여섯 가지 제약 조건이다.

**1.  NOT NULL**  : 기본적으로 테이블 컬럼은  NULL을 가질 수 있다.  NOT  NULL  제약 조건을 달면 이 컬럼에는  NULL이 아닌 값만 입력된다.

<br/>

**2.  UNIQUE**  :  UNIQUE  제약 조건은 특정 필드에 중복 값이 입력되는 것을 방지한다.  UNIQUE  제약 조건을 사용하면 기본키가 아닌 특정 컬럼에 중복 값이 들어오는 것을 막는다.  PRIMARY  KEY  제약 조건과는 달리  UNIQUE  제약 조건은  NULL을 허용한다.

<br/>

**3.  PRIMARY  KEY**  :  UNIQUE  제약 조건과 유사한  PRIMARY  KEY  제약 조건은 테이블에 있는 각 레코드를 유일하게 식별한다. 유일한 값만 입력되게 할 뿐 아니라  NULL이 입력되는 것을 방지한다. 한 테이블에  UNIQUE  제약 조건을 여러 개 만들 수 있는 반면,  PRIMARY  KEY  제약 조건은 한 개만 만들 수 있다.

<br/>

**4.  FOREIGN  KEY**  : 한 테이블에 있는 외래키는 다른 테이블에 있는 기본키가 된다.

<br/>

**5.  CHECK**  :  CHECK  제약 조건은 한 테이블이나 필드에 정의할 수 있다, 단일 필드에  CHECK  제약 조건을 정의하면 이 필드에는 특정 값만 입력될 수 있다. 테이블에 정의하면 특정 필드 값이 동일한 로우의 다른 필드 값을 기준으로 제한된다.

<br/>

**6.  DEFAULT**  :  DEFAULT  절은 한 필드의 기본 값을 정의하는 데 사용된다. 새로운 로우를 입력할 때 해당 필드에 값을 입력하지 않으면 데이터베이스는 기본 값을 입력한다.

<br/><br/><br/><br/>

## Better Way 16 - 자신이 사용하고 작성하는 SQL의 종류를 파악하자
- SQL 문이 SQL 표준을 따르더라도 DBMS에 따라 그 동작이 다를 수 있다.
- DBMS별로 SQL 구현 내용이 다르므로 동일한 SQL 문이라도 성능은 다르다.
- 사용하는 DBMS 문서를 참고하는 습관을 들인다.
- SQL 차이점이 궁금하다면  [http://troels.arvin.dk/db/rdbms/](http://troels.arvin.dk/db/rdbms/)를 참고한다.

<br/><br/><br/><br/>

## Better Way 17 - 인덱스에서 계산 결과를 사용할 시기를 파악하자
- 인덱스를 과다하게 만들지 않는다.
- 예상되는 데이터베이스 사용 실태를 분석해 필터링된 인덱스를 적합하게 사용하는지 확인한다.


<br/><br/>

### SQL Server는 2000 버전부터 계산 컬럼을 인덱스로 만들 수 있는데, 다음 조건을 만족해야 한다.

**소유권 요구 사항**  : 계산 컬럼에 사용된 모든 함수의 소유자는 테이블 소유자와 같아야 한다.

<br/>

**결정성 요구 사항**  : 계산 컬럼은 결정적이어야 한다

<br/>

**정밀도 요구 사항**  : 함수에서는  float나  real  데이터 타입의 표현식을 사용할 수 없고, 함수를 정의할 때도  float나  real  데이터 타입을 사용할 수 없다.

<br/>

**데이터 타입 요구 사항**  :  text,  ntext,  image  타입을 사용할 수 없다.

<br/>

**SET 옵션 요구 사항**  : 계산 컬럼의 계산이 수행되는 내용을 정의하는  CREATE TABLE  문이나  ALTER TABLE  문이 실행될 때  ANSI_NULLS  연결 수준 옵션이  ON으로 설정되어야 한다.

---

<br/><br/><br/><br/><br/><br/><br/><br/>

---

# 3. 데이터 모델 설계를 변경할 수 없는 경우
- 적절한 논리적 데이터 모델을 갖추려고 상당한 시간을 들이며, 이를 적합한 물리적인 모델로 구현하려고 열심히 작업했다고 하자. 불행히도 데이터의 일부는 여러분이 손댈 수 없는 소스에서 가져와야 한다고 하자.

<br/>

상황이 이렇다고 해서 여러분이 작성한 SQL 쿼리가 잘 수행되지 않는다는 말은 아니다. 이 장에서는 부적절하게 설계된 다른 소스에서 가져온 데이터로 작업을 할 때 손봐야 하는 부분을 설명할 것이다. 이런 데이터에 여러분이 작성한 쿼리 일부를 변형해서 수행하는 방법과 객체를 생성하는 식으로 데이터 자체를 변형하는 방법을 알아볼 것이다.

<br/>

외부 데이터의 제어권이 없으므로 데이터베이스 설계 내용을 변경할 수 없다. 하지만 이 장 내용을 참고하면 DBA와 협업해서 효율적인 SQL을 작성할 수 있을 것이다.

<br/><br/><br/><br/>

## Better Way 18 - 설계를 변경할 수 없을 때는 뷰로 데이터를 간소화하자
- 사용자에게 직관적인 데이터를 제공하려면 뷰를 사용한다.
- 사용자가 정확히 필요한 데이터를 보거나(종종 수정하거나) 더는 필요 없는 데이터를 보지 않게 제한하려면 뷰를 사용한다. 필요하면  WITH CHECK OPTION을 사용한다.
- 복잡한 쿼리를 숨기고 재사용하려면 뷰를 사용한다.
- 여러 테이블에 있는 데이터를 취합해 보고용 데이터를 만들 때는 뷰를 사용한다.
- 뷰를 사용하면 코딩 규칙이나 명명법을 강화할 수 있다. 특히 기존 데이터베이스 설계를 변경해서 작업할 때 특히 유용하다.

<br/><br/>

### 뷰를 사용하는 이유를 정리하면 다음과 같다.
**특정 데이터에 집중**  : 뷰로 특정 작업에 사용하는 특정 데이터에 집중할 수 있다. 이런 뷰는 하나 이상의 테이블에 있는 모든 로우나  WHERE  절로 걸러 낸 로우를 반환한다. 또 하나 이상의 테이블에 있는 컬럼의 일부 집합만 반환할 수도 있다.

<br/>

**컬럼 이름을 간소화 또는 명료화**  : 뷰를 사용하면 원래 컬럼 이름 대신 별칭을 사용해 좀 더 의미 있는 이름을 부여할 수 있다.

<br/>

**여러 테이블에 있는 데이터를 한눈에 보기**  : 뷰로 여러 테이블 데이터를 결합해 논리적인 단일 레코드로 통합해서 볼 수 있다.

<br/>

**데이터 조작 간소화**  : 뷰는 사용자가 데이터로 작업하는 방식을 간소하게 만들 수 있다. 예를 들어 보고서용으로 복잡한 쿼리를 작성한다고 하자. 사용자별로 서브쿼리, 외부 조인, 일련의 테이블 그룹에서 데이터를 추출해서 집계하는 대신 뷰를 만들어 사용할 수 있다. 이렇게 하면 데이터 접근을 간단하게 할 수 있을 뿐만 아니라(보고서 데이터를 생성할 때마다 주요 쿼리를 작성할 필요가 없으므로), 각 사용자가 해당 쿼리를 생성하도록 강제하지 않고도 데이터의 일관성을 유지할 수 있다. 또 매개변수가 있는 뷰나  WHERE  절의 조건에 매개변수를 가진 뷰 또는 복잡한 쿼리의 일부분으로 논리적으로 동작하는 인라인 사용자 정의 함수도 만들 수 있다. 여기서 말하는 인라인 함수는 스칼라 함수와는 다르다는 점에 유의하자!

<br/>

**중요 데이터 보호**  : 테이블에 민감하고 중요한 데이터가 저장되어 있을 때 이 데이터를 뷰로 만들어 뺄 수 있다. 예를 들어 고객의 신용 카드 정보를 노출하는 대신 신용 카드 숫자를 변형해서 실제 숫자는 숨긴 채 기능을 수행하는 함수를 사용하는 뷰를 만들 수 있다. DBMS에 따라 다르지만, 이런 뷰를 특정 사용자만 볼 수 있게 할 수 있어 주요 테이블을 직접 노출하지 않을 수 있다. 또 뷰는 컬럼이나 로우 수준의 보안 기능을 제공한다.  WITH CHECK OPTION  절로 사용자가 뷰에 걸린 제약 조건을 위반하는 데이터 삭제나 갱신 작업을 수행하는 것을 차단할 수 있다.

<br/>

**하위 호환성 제공**  : 하나 이상의 테이블 스키마를 변경해야 할 때 기존 테이블의 스키마와 동일한 뷰를 만들어 처리할 수 있다. 이렇게 하면 기존 애플리케이션은 원래 테이블 데이터를 조회하는 쿼리를 수정 없이 사용할 수 있다. 심지어 해당 애플리케이션에서 데이터를 조작할 때라도  INSTEAD OF  트리거를 사용하면 주요 테이블의 뷰로  INSERT,  UPDATE,  DELETE  작업을 할 수 있다.

<br/>

**데이터 커스터마이징**  : 뷰를 만들면 여느 사용자가 다른 방식으로 동일한 데이터를, 심지어 똑같은 시간에 다른 방식으로 보게 할 수 있다. 예를 들어 사용자의 로그인 ID 값에 따라 특정 사용자와 관련된 고객 정보를 조회하는 뷰를 만들어 사용할 수 있다.

<br/>

**요약 데이터 제공**  : 집계 함수(SUM(),  AVERAGE()  등)를 사용한 뷰로 데이터 일부분의 계산 결과 값만 볼 수 있다.

<br/>

**데이터 가져오기와 내보내기**  : 뷰를 이용하면 다른 애플리케이션에 데이터를 내보낼 수 있다. 원하는 데이터를 제공하는 뷰를 생성한 후 적당한 유틸리티를 이용하면 해당 데이터를 내보낼 수 있다. 또 가져오기용 뷰를 만들면 주요 테이블에 있는 모든 컬럼이 아닌 필요한 컬럼 데이터만 가져와 사용할 수도 있다.

<br/><br/><br/><br/>

## Better Way 19 - 비관계형 데이터를 정보성 데이터로 변환할 때는 ETL을 사용하자
- ETL 도구를 사용하면 비관계형 데이터를 적은 노력으로도 데이터베이스로 가져올 수 있다.
- ETL 도구로 데이터 형태를 변경하고 재배열해서 정보성 데이터로 탈바꿈할 수 있다.
- 대부분의 데이터베이스 시스템은 상용 도구를 포함해 여러 수준의 ETL 도구를 제공한다.

<br/><br/>

**추출(Extract), 변환(Transform), 로드(Load)** 를 의미하는 ETL은 외부 소스에 있는 데이터를 추출한 후 관계형 설계 규칙이나 다른 요구 사항에 맞게 변환하고, 분석이나 다른 목적으로 사용하려고 데이터베이스에 로드하는 일련의 절차나 도구를 의미한다. 거의 모든 데이터베이스 시스템은 이런 처리를 지원하는 다양한 유틸리티를 제공한다. 이런 유틸리티는 꽤 빠르게 원시 데이터를 정보성 데이터로 변환해 준다.

<br/><br/><br/><br/>

## Better Way 20 - 요약 테이블을 만들어 관리하자
- 요약 데이터를 저장하면 집계에 필요한 처리를 최소화할 수 있다.
- 요약 데이터를 저장해 놓은 테이블을 사용하면 집계 작업을 할 때 좀 더 효율적으로 집계된 데이터가 포함된 필드에 인덱스를 만들 수 있다.
- 요약 작업은 다소 정적인 테이블에 적합하다. 원천 테이블이 빈번히 변경된다면 요약 작업의 부하는 무시할 수 없을 정도로 커진다.
- 요약 작업을 수행하는 데 트리거를 사용할 수 있지만, 요약 테이블 데이터를 지우고 다시 생성하는 식으로 수행한다면 저장 프로시저를 사용하는 편이 더 낫다.

<br/><br/>

### 요약 테이블에도 몇 가지 단점이 있는데, 그 내용은 다음과 같다.

- 요약 테이블은 별도의 데이터를 저장하므로 저장 공간을 차지한다.

<br/>

- 원본 테이블과 요약 테이블 간 데이터를 일관되게 유지하려면 관리 작업(트리거, 제약 조건, 저장 프로시저 등)이 필요하다.

<br/>

- 사용자에게 필요한 집계 값을 미리 계산하고 요약 테이블에 담아 놓으려면 그 데이터가 무엇인지 미리 파악해 두어야 한다.

<br/>

- 그루핑 조건이나 필터 조건이 다를 때는 요약 테이블이 여러 개 필요하다.

<br/>

- 스케줄을 만들어 요약 테이블 데이터를 갱신하도록 한다.

<br/>

- SQL을 사용해 요약 테이블 데이터를 주기적으로 관리해야 한다. 예를 들어 요약 테이블에서 지난 12개월간 데이터를 보여 주려면 이 테이블에서 1년 이상 지난 데이터는 제거하는 로직이 필요하다.

<br/><br/><br/><br/>

## Better Way 21 - 비정규화된 데이터를 '언피벗'하려면 UNION 문을 사용하자
- UNION  쿼리에서 각  SELECT  문은 컬럼의 개수가 동일해야 한다.
- 각  SELECT  문에서 사용하는 컬럼 이름이 달라도 문제는 없지만, 각 컬럼의 데이터 타입은 서로 호환되어야 한다.
- 데이터의 정렬 순서를 조정하려면 마지막  SELECT  문에  ORDER BY  절을 추가한다.
- 중복 로우를 제거할 필요가 없거나 중복 로우를 제거해서 일어난 성능 문제를 없애려면  UNION  대신  UNION ALL을 사용한다.

<br/><br/>

### UNION  쿼리를 사용할 때 적용되는 세 가지 기본 규칙은 다음과 같다.

1.  UNION  쿼리를 구성하는 각 쿼리는 컬럼의 개수가 동일해야 한다.

<br/>

2.  각 쿼리의 컬럼 순서도 일치해야 한다.

<br/>

3.  각 쿼리에서 사용된 컬럼의 데이터 타입도 일치하거나 서로 호환해야 한다.

---

<br/><br/><br/><br/><br/><br/><br/><br/>

---

# 4. 데이터 필터링과 검색
## Better Way 22-29
**Better Way 22** - 관계 대수와 이를 SQL로 구현하는 방법을 이해하자
**Better Way 23** - 일치하지 않거나 누락된 레코드를 찾아내자
**Better Way 24** - CASE로 문제를 해결해야 할 때를 파악하자
**BETTER WAY 25** - 다중 조건 문제를 해결하는 기법을 파악하자
**BETTER WAY 26** - 완전히 일치하는 데이터가 필요할 때는 데이터를 분할하자
**BETTER WAY 27** - 날짜와 시간을 모두 포함하는 컬럼에서 날짜 범위를 올바르게 검색하는 방법을 알아 두자
**BETTER WAY 28** - 데이터베이스 엔진이 인덱스를 사용하도록 사거블 쿼리를 작성하자
**BETTER WAY 29** - LEFT 조인의 오른쪽 데이터를 올바르게 걸러 내자

---

<br/><br/><br/><br/><br/><br/><br/><br/>

---

# 5. 집계
## Better Way 30-39
**BETTER WAY 30** - GROUP BY 절의 작동 원리를 이해하자
**BETTER WAY 31** - GROUP BY 절은 간단하게 만들자
**BETTER WAY 32** - 복잡한 문제를 해결하려면 GROUP BY나 HAVING 절을 사용하자
**BETTER WAY 33** - GROUP BY 절 없이 최댓값, 최솟값을 찾자
**BETTER WAY 34** - OUTER JOIN에서는 잘못된 결과를 내는 COUNT( ) 함수를 사용하지 말자
**BETTER WAY 35** - ‘HAVING COUNT(x) < 숫자’를 검사할 때는 제로 값을 가진 로우를 포함하자
**BETTER WAY 36** - 겹치지 않는 개수를 얻으려면 DISTINCT를 사용하자
**BETTER WAY 37** - 윈도우 함수 사용법을 알아 두자
**BETTER WAY 38** - 로우 번호를 만들어 다른 로우 대비 순위를 매기자
**BETTER WAY 39** - 이동 집계를 만들자

---

<br/><br/><br/><br/><br/><br/><br/><br/>

---

# 6. 서브쿼리
## Better Way 40-43
**BETTER WAY 40** - 서브쿼리를 어디에 사용할 수 있는지 알아 두자
**BETTER WAY 41** - 연관성 있는 서브쿼리와 연관성 없는 서브쿼리의 차이점을 파악하자
**BETTER WAY 42** - 가능하면 서브쿼리 대신 공통 테이블 표현식을 사용하자
**BETTER WAY 43** - 서브쿼리 대신 조인을 사용해 더 효율적인 쿼리를 작성하자

---

<br/><br/><br/><br/><br/><br/><br/><br/>

---

# 7. 메타데이터 획득 및 분석
## Better Way 44-46
**BETTER WAY 44** - 사용 중인 시스템의 쿼리 분석기 사용법을 파악하자
**BETTER WAY 45** - 데이터베이스 관련 메타데이터를 수집하는 방법을 배우자
**BETTER WAY 46** - 실행 계획의 작동 원리를 이해하자

---

<br/><br/><br/><br/><br/><br/><br/><br/>

---

# 8. 카티전 곱
## Better Way 47-50
**BETTER WAY 47** - 두 테이블에서 로우 조합을 만들어 한 테이블과 간접적으로 관련된 다른 테이블 로우에 표시를 남기자
**BETTER WAY 48** - 등분위로 로우 순위를 매기는 방법을 이해하자
**BETTER WAY 49** - 한 테이블에서 각 로우와 다른 모든 로우를 쌍으로 만드는 방법을 알아 두자
**BETTER WAY 50** - 카테고리별 목록을 만들어 첫 번째, 두 번째, 세 번째 순위의 정보를 참조하는 방법을 파악하자

---

<br/><br/><br/><br/><br/><br/><br/><br/>

---

# 9. 탤리 테이블
## Better Way 51-57
**BETTER WAY 51** - 매개변수를 기준으로 널 로우를 만들려면 탤리 테이블을 사용하자
**BETTER WAY 52** - 순번을 생성할 때는 탤리 테이블과 윈도우 함수를 사용하자
**BETTER WAY 53** - 탤리 테이블에 있는 범위 값을 기준으로 여러 로우를 만들자
**BETTER WAY 54** - 탤리 테이블에 있는 값 범위를 기준으로 한 테이블에 있는 값을 변환하자
**BETTER WAY 55** - 날짜 계산을 쉽게 하려면 날짜 테이블을 사용하자
**BETTER WAY 56** - 특정 범위에 있는 모든 날짜를 나열한 일정 달력을 만들자
**BETTER WAY 57** - 탤리 테이블로 데이터를 피벗하자

---

<br/><br/><br/><br/><br/><br/><br/><br/>

---

# 10. 계층형 데이터 모델링
## Better Way 58-61
**BETTER WAY 58** - 인접 리스트 모델을 시작점으로 사용하자
**BETTER WAY 59** - 자주 갱신되지 않는 데이터의 쿼리 성능을 빠르게 하려면 중첩 집합을 사용하자
**BETTER WAY 60** - 제한된 검색과 간단한 설정에는 구체화된 경로를 사용하자
**BETTER WAY 61** - 복잡한 검색에는 계통 순회 폐쇄 구조를 사용하자
