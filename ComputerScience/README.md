# 기본 IT 지식
## 프로그래밍 언어 & 운영체제(OS)

<br/>

### 인간과 컴퓨터 사이에는 '컴파일러'가 있어서 인간의 요구를 컴퓨터에게 전달해준다.
- 개발자는 컴파일러에게 문서로 일을 시키는 사람이다.
- Java, Python, Ruby, Swift 등 영어로 되어 있는 프로그래밍 언어를 사용해 컴파일러에게 명령을 전달하면, 컴파일러가 그 명령어를 기계어인 0과 1로 변환해 컴퓨터에게 전달을 하는 방식이다.

<br/><br/>

### 개발자는 컴퓨가 해야 하는 일에 대한 문서를 작성한다.
- 프로그래밍 언어로 문서 작업 하는 행동을 '프로그래밍' 혹은 '코딩'이라고 한다.
- 컴파일러는 코딩한 문서를 0과 1로 바꿔서 컴퓨터에게 전달하고, 컴퓨터는 그대로 행동한다.
- 개발자들의 작업을 도와주는 기능들이 들어가 있는 프로그램들을 IDE(Integrated Development Environment). 즉, 통합 개발 환경이라고 부른다.
- 쉽게 말해 개발을 하기 위한 모든 것들을 제공해주는 환경이다.
<pre>IDE(통합 개발 환경)

Android Studio - 안드로이드 애플리케이션 개발 용도
Xcode - 애플 운영 체제 위의 애플리케이션 개발 용도
Eclipse - C/C++ 개발, 자바 개발, 웹 개발 용도
PyCharm - 파이썬 개발용도</pre>

<br/><br/>

### 프로그래밍언어를 구분하는 기준, '저수준'과 '고수준'
- 저수준 > 컴퓨터 친화적인 언어
- 고수준 > 인간 친화적인 언어

<br/><br/>

### 컴퓨터 구성 요소
- CPU, 메모리(RAM), 보조기억장치(HDD, SDD), 메인보드 +@

<br/><br/>

### 운영체제 > 우리 대신 하드웨어를 관리해준다.
- Windows
- MacOS
- iOS
- Android

---

<br/>

## 네트워크, 클라이언트, 서버

<br/>

### 컴퓨터 연결
- 컴퓨터가 연결된 작은 지역을 LAN(Local Area Network)이라고 표현한다.
- 사람들은 도시의 여러 LAN을 하나로 연결해 MAN(Metropolitan Area Network)을 만들었다.
- 그리고 도시와 도시, 나라와 나라를 모두 연결해서 WAN(Wide Area Network)을 만들었다.

<br/><br/>

### 서버와 클라이언트
- 파일을 달라고 계속 보채는 컴퓨터를 '클라이언트'
- 파일을 주는 컴퓨터를 '서버'

<br/><br/>

### 우분투란?
- 리눅스의 유명한 버전 중 하나 Ubuntu

<br/><br/>

### 서버 - 호스팅
- 개인이 서버를 운영하면 여러가지 리스크가 발생하게 된다.
- 그래서 이 모든 일들을 대신해주는 서비스가 나타나기 시작했는데 이런 서비스를 제공하는 업체를 '호스팅 업체'라고 부른다.
- 국내에는 대표적으로 Cafe24, 가비아 등의 회사가 있다.

---

<br/>

## API와 JSON

<br/>

### 클라이언트는 서버에게 요청을 보낸다.
- 그럼 서버는 요청에 따라 적합한 처리를 해서 응답을 준다. 하지만 컴퓨터는 한글을 모른다. > 어떤 요청이 '메시지를 달라'는 요청인지, '로그인 시켜줘'라는 요청인지 알 수 없다.
- 요청을 구분할 수 있도록 하는 '체계'가 필요하다. > 그 체계가 바로 API이다.


<br/><br/>

### API
- API는 클라이언트, 서버와 같은 서로 다른 프로그램에서 요청과 응답을 주고받을 수 있게 만든 체계이다.
- API는 서버 개발자가 개발하고, 클라이언트 개발자는 그 API를 사용한다.
- API를 만들 때는 데이터를 주고 받는 기능도 함께 넣는다.

<br/><br/>

### CRUD 요청
- Create > POST
- Read > GET
- Update > PUT(전체) / PATCH(일부)
- Delete > DELETE

<br/><br/>

### CRUD가 체계적으로 나뉘지 않을 수도 있다.
- 그럼 그 몇몇 API들이 문제를 일으키고 버그가 생긴다.
- 따라서 사람들은 좀 더 체계적으로 API를 관리하고 싶어 했고 그 영향으로 조금 더 체계적인 API라는 사회 운동이 만들어진다.
- 그런 API를 REST(Representational State Transfer)한 API 즉, RESTful API라고 부른다.

<br/><br/>

### 컴퓨터는 코딩된 대로 생각하고 응답을 보낸다.
- 200 > 잘 됐어
- 400번대 코드 > 클라이언트의 요청에서 문제가 있는 경우 
- 500 > 서버에 문제가 있는 경우

<br/><br/>

### 더불어 응답에는 데이터가 필요할 수 있다.
- 예를 들어, 내 정보를 수정할 때는 먼저 내 정보를 불러와야 한다.
- 그럼 '내 정보를 불러와 줘!'라는 요청을 보내고, 응답으로 정보를 받아야 한다.
- 응답의 영어는 'Response'. 요청(Request)과 마찬가지로 응답(Response)도 데이터를 담을 수 있다.
- 이렇게 요청와 응답에 데이터를 담아 주고받음으로써 API 요청이 완성된다.

<br/><br/>

### 정리하면 API는 소프트웨어가 다른 소프트웨어의 기능을 쓰기 위해 중간에 필요한 체계이다.
- 기능을 사용하기 위해 주소로 요청을 보내면 응답을 해주는 소프트웨어끼리의 체계라고 이해하면 된다.
<pre>한 컴퓨터에 여러 소프트웨어가 함께 있는 경우

- 서로 다른 시스템의 기능을 사용하기 위해서는 API가 필요하다.
> 'ㅁㅁ 소프트웨어'는 API를 사용하여 정해진 방법대로 '다른 소프트웨어'에 요청을 보낸다.
> '다른 소프트웨어'는 요청대로 작업을 수행하고, 응답을 준다.
>> 물론 API는 응답을 보내는 쪽에서 만들고, 요청을 보내는 쪽은 활용할뿐이다.
>>> 즉, 해당 API를 미리 만들어놓지 않았다면 쓸 수 없다.

이때 새로운 용어 SDK가 등장한다.
> API를 제공해주는 '다른 소프트웨어'를 SDK(Software Development Kit)라고 부른다.
> 소프트웨어를 개발하기 위한 도구이다.
>> 즉, 'ㅁㅁ 소프트웨어'를 개발할 때 '다른 소프트웨어'이다. </pre>

<br/><br/>

### 요청과 응답을 주고받을 때의 형식 JSON
- JSON은 중괄호로 시작한다.
- 키(Key)와 값(Value)으로 이루어져 있다. 키와 값은 '콜론(:)'으로 구분한다.
- 클라이언트와 서버는 요청과 응답을 주고받고, 그때 필요한 데이터들을 JSON 형식으로 주고받는다.

---

<br/>

## 애플리케이션과 웹

<br/>

### 애플리케이션
- 운영체제 위에 올라가는 프로그램, 설치해야 하는 프로그램, 응용프로그램, 애플리케이션, 어플, 앱, 모두 같은 그룹이다. = 통칭해서 '애플리케이션'

<br/><br/>

### 웹(Web)
- 웹을 구성하는 3요소 HTML(내용,구조) + JavaScript(프로그래밍 언어) + CSS(디자인)

<br/>

#### HTML
- 컴퓨터에게 특정 일을 시킬 수 있는 언어가 아닌 단지 브라우저가 볼 수 있는 문서를 적는 언어이다.

<br/>

#### CSS
- HTML에 디자인을 입힐 수 있는 코드 Cascading Style Sheets

<br/>

#### HTML + CSS = '퍼블리싱'
- 이 작업을 하는 사람 = '퍼블리셔'

<br/>

#### 마크업
- 마크업의 M은 HTML(Hyper Text Markup Language)의 M을 뜻한다.
- 즉, HTML 작업을 마크업 작업이라고 부르고, HTML 작업을 주로 하는 사람들을 마크업 개발자라고 한다.

<br/>

#### JavaScript
- JSON 형식으로 날아온 응답을 열어서 HTML로 바꾼다.

<br/><br/>

### 반응형 웹
- 반응형 : 브라우저의 가로 넓이에 '반응'하여 구성요소가 변하는 기술
- 웹페이지의 크기(비율)가 사용자의 기기에 맞춰 자동으로 변형된다.
- 서로 다른 기기의 넓이에 따른 CSS를 추가로 코딩해야 하므로 작업시간이 오래걸리고 비용이 더 많이 들어가게 된다.

<br/><br/>

### 네이티브 애플리케이션
- 원래 정해놓은 언어들을 사용해 개발한 애플리케이션
- 원래 정해놓은 언어들을 사용해 운영체제 자체의 기능을 사용하기 때문에 '원주민'이라는 뜻을 가진 '네이티브'가 붙게 됨
- 하지만 운영체제 안에 브라우저가 내장되자 새로운 방식으로도 애플리케이션 개발이 가능해짐
- 바로 애플리케이션의 특정 부분에 '브라우저'를 울리는 방식이다.
- 그리고 HTML 파일을 불러올 URL을 설정해두는 것이다.

<br/><br/>

### 하이브리드 애플리케이션
- 네이티브와 브라우저가 혼합된 애플리케이션
- 브라우저 위에서 돌아가는 부분은 서버에 있는 원본 HTML, CSS, JavaScript를 수정하면 바뀐다. > 이 부분은 보통 앱 화면이 뜰 때 바뀐다.
- 반면 네이티브인 부분은 운영체제별로 다른 프로그래밍 언어를 통해 수정한 뒤 심사를 신청해야 한다.
- 심사 신청 뒤에도 사람들이 바뀐 애플리케이션으로 업데이트해야한다. > 시간이 오래걸리고 까다롭다.

---

<br/>

## 데이터베이스와 이미지 처리

<br/>

### 관계형 데이터베이스
- 데이터 관리 방법론
- 엑셀의 Sheet를 관계형 데이터베이스에서는 Table이라고 표현단다.
- 그리고 엑셀 파일 자체를 Schema 혹은 Database라고 표현한다.


<br/><br/>

### 관계형 데이터베이스 관리 시스템
- 데이터들을 파일로 만들어서 저장하고 관리해주는 소프트웨어
- 관계형 데이터베이스의 철학으로 만들어진 관리시스템을 RDBMS이라고 부른다.
- MSSQL, Oracle DB, MySQL, MariaDB

<br/><br/>

### 클라이언트에 데이터가 있다
- "그 데이터는 로컬에 있어요."
- "내부 DB에 저장하고 있어요."
- "네이티브에서 가져왔어요."
- 프론트/프론트엔드

<br/><br/>

### 서버에서 데이터를 가져왔다.
- API 요청
- DB
- 백/백엔드

<br/><br/>

### 이미지 처리
- 이미지 파일은 컴퓨터에 있다. > 클라이언트나 서버 둘 중 하나에 있다.
- 그리고 각 컴퓨터는 이미지 주소를 통해 이미지에 접근한다.
- 이 이미지들을 바꾸려면 파일을 바꾸거나 다른 주소를 지정하면 된다.
- 그리고 프로필 이미지 같은 파일들은 '관계'가 있기 때문에 관리가 필요하다. > 그래서 주소를 DB에 넣어서 관리한다.
- 마지막으로, 이미지가 클라이언트에 있는지 서버에 있는지 확인하는 가장 좋은 방법은 API 문서를 보는 것이다.
- API를 통해 이미지의 주소(URL)를 서버에서 받아온다면, 그 이미지는 서버에 있는 이미지라고 판단할 수 있다.

---

<br/>

## 프레임워크와 라이브러리

<br/>

### 프레임워크
- 애플리케이션을 쉽고 빠르게 개발할 수 있다.

<br/>

#### 각 언어별로 유명한 프레임워크들이 하나씩 있다.

- 자바 - Spring이라는 프레임워크를 사용하면 서버를 쉽고 빠르게 개발할 수 있다.
- 파이썬 - Django
- 루비 - Rails
- JavaScript - Express.js

<br/><br/>

### 라이브러리
- 다른사람들이 만들어놓은 코드를 이용한다는 측면에서 프레임워크와 같다.
- 각종 라이브러리와 코드들이 모여 프레임워크가 된다.
- 더불어 한 프로젝트에서 프레임워크는 하나만 쓸 수 있다.
- 반면 라이브러리는 더 작은 개념이다. 망치나 가위같은 도구들이기 때문에 한 프로젝트에서 함께 사용이 가능하다.

---

<br/>

## 협업, 소스관리, 디자인

<br/>

### Git
- 깃을 통해 개발자들은 개발 단계별로 '깃발'을 꽂을 수 있다.
- 그 행위를 커밋(Commit)이라고 한다.
- 커밋에는 무슨 개발을 했는지 적어주는 메모가 항상 따라다닌다.
- 그 메모를 커밋 로그(Commit Log)라고 한다.

<br/><br/>

### 디자인과 개발자간의 갈등 > UI
- 개발자는 포토샵과 일러스트 작업물의 수치를 하나씩 파악해야 하는 불편함이 생김
- 개발자들은 디자인의 수치를 모두 표시해서 달라는 '가이드' 요구
- 해결 => 스케치, 재플린, XD > 이 프로그램들은 디자이너의 작업 결과물의 수치를 보여준다.

---

![image](https://user-images.githubusercontent.com/61584142/123468843-471eb800-d62d-11eb-9695-2257b5d45d13.png)

---

##### vs code 

[https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf]

Ctrl+D // 현재 커서 위치의 단어와 같은 단어 하나씩 추가 선택 <br/>
Ctrl+Shift_L // 현재 커서 위치의 단어와 같은 단어 모두 선택 <br/>
Shift+Alt+(클릭 or 드래그) // 현재 커서 위치부터 클릭하거나 드래그한 위치까지 선택하여 여러 줄을 동시에 수정 <br/>

<br/><br/>

Alt + (위 아래 방향키) // 현재 줄 이동 <br/>
Alt+Shift+(위 아래 방향키) // 현재 줄 복사 <br/>
Ctrl+Shift+Alt+(방향키) // 여러 줄 동시 선택 <br/>

<br/><br/>

Shift+Alt+(오른쪽방향키) // 현재 커서 위치의 scope부터 순차적으로 선택 <br/>
Ctrl+Alt+(위아래방향키) // 여러 줄 동시에 수정 <br/>

<br/><br/>

Ctrl+` // 터미널보이기 <br/>
Ctrl+Shift+` // 새 커미널 생성 <br/>

---

<pre><code>ps -aux|grep py
raspivid -f or -i
rm -9 file
</code></pre>

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

[1] 텍스트와 특수문자를 조합해서 사진과 그림을 표현한 것. 
= 아스키 아트(ASCII Art)

[2] 최소화되고 모듈화된 소프트웨어 개발 방식을 위한 문화적 규범이자 철학적 접근 방식. 
= Unix 철학

[3] 명령줄 또는 명령어 인터페이스는 텍스트 터미널을 통해 사용자와 컴퓨터가 상호 작용하는 방식을 말한다. 
= Command-line

[4] 취미 활동으로 즐기는 아마추어 무선 통신. 
= HAM 라디오

[5] 사용자 인터페이스 개발을 위해 페이스북에서 만들고 공개한 오픈소스 자바스크립트 라이브러리. 
= React

[6] 변수를 정의한 클래스 외부에서도 접근할 수 있는 변수. 
= public 변수

[7] 외부에 노출되지 않고 정의한 클래스 내부에서만 접근할 수 있는 변수. 
= private 변수

[8] 아틀라시안(Atlassian)이 개발한 이슈추적 소프트 웨어로 버그 추적, 이슈 추적, 프로젝트 관리 기능 등을 제공한다. 
= Jira

[9] 객체 지향 프로그래밍의 핵심인 클래스와 그 서브클래스 간의 계층 구조를 도식으로 나타낸 것. 
= Class Hierarchy

[10] 프로그램을 작성할 때 각 모듈이 작동하는 논리를 표현하기 위한 언어이다. 특정 프로그래밍 언어의 문법이 아닌 알고리즘 그 자체이 집중할 수 있기 때문에 코딩 면접에서 많이 사용된다. 
= Pseudo code

---

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

## RESTful API
- REST API(RESTful API, 레스트풀 API)란 REST 아키텍처의 제약 조건을 준수하는 애플리케이션 프로그래밍 인터페이스를 뜻한다. <br/>REST는 Representational State Transfer의 줄임말이다. <br/><br/>

- API는 애플리케이션 소프트웨어를 구축하고 통합하는 정의 및 프로토콜 세트이다. <br/>때때로 API는 정보 제공자와 정보 사용자 간의 계약으로 지칭되며 소비자에게 필요한 콘텐츠(호출)와 생산자에게 필요한 콘텐츠(응답)를 구성한다. <br/><br/>

- 예를 들어 날씨 서비스용 API에서는 사용자는 우편번호를 제공하고, 생산자는 두 부분(첫 번째는 최고 기온, 두 번째는 최저 기온)으로 구성된 응답으로 답하도록 지정할 수 있다. <br/> 즉, 컴퓨터나 시스템과 상호 작용하여 정보를 검색하거나 기능을 수행하고자 할 때 API는 사용자가 원하는 것을 시스템에 전달할 수 있게 지원하여 시스템이 이 요청을 이해하고 이행하도록 할 수 있다. <br/><br/>

- API를 사용자 또는 클라이언트, 그리고 사용자와 클라이언트가 얻으려 하는 리소스 사이의 조정자로 생각하면 된다. <br/>API는 조직이 보안 및 제어를 유지관리(누가 무엇에 액세스할 수 있는지 결정)하면서 리소스와 정보를 공유할 수 있는 방법이기도 하다. <br/>API의 또 다른 이점은 리소스 검색 방법 또는 리소스의 출처에 대한 지식 없이도 사용이 가능하다는 점이다. <br/><br/>

- REST는 프로토콜이나 표준이 아닌 아키텍처 원칙 세트이다. <br/>API 개발자는 REST를 다양한 방식으로 구현할 수 있다. <br/>
    - RESTful API를 통해 요청이 수행될 때 RESTful API는 리소스 상태에 대한 표현을 요청자에게 전송한다. 
    - 이 정보 또는 표현은 HTTP: JSON(Javascript Object Notation), HTML, XLT 또는 일반 텍스트를 통해 몇 가지 형식으로 전송된다. 
    - JSON은 그 이름에도 불구하고 사용 언어와 상관이 없을 뿐 아니라 인간과 머신이 모두 읽을 수 있기 때문에 가장 널리 사용된다. <br/><br/>

### API가 RESTful로 간주되려면 다음 기준을 따라야 한다.
- 클라이언트, 서버 및 리소스로 구성되었으며 요청이 HTTP를 통해 관리되는 클라이언트-서버 아키텍처
- 스테이트리스(stateless) 클라이언트-서버 커뮤니케이션: 요청 간에 클라이언트 정보가 저장되지 않으며, 각 요청이 분리되어 있고 서로 연결되어 있지 않음
- 클라이언트-서버 상호 작용을 간소화하는 캐시 가능 데이터 

<br/>

### 정보가 표준 형식으로 전송되도록 하기 위한 구성 요소 간 통합 인터페이스. 여기에 필요한 것은 다음과 같다.
- 요청된 리소스가 식별 가능하며 클라이언트에 전송된 표현과 분리되어야 한다.
- 수신한 표현을 통해 클라이언트가 리소스를 조작할 수 있어야 한다(이렇게 할 수 있는 충분한 정보가 표현에 포함되어 있기 때문).
- 클라이언트에 반환되는 자기 기술적(self-descriptive) 메시지에 클라이언트가 정보를 어떻게 처리해야 할지 설명하는 정보가 충분히 포함되어야 한다.
- 하이퍼미디어: 클라이언트가 리소스에 액세스한 후 하이퍼링크를 사용해 현재 수행 가능한 기타 모든 작업을 찾을 수 있어야 한다.

<br/>

- 요청된 정보를 검색하는 데 관련된 서버(보안, 로드 밸런싱 등을 담당)의 각 유형을 클라이언트가 볼 수 없는 계층 구조로 체계화하는 계층화된 시스템. 
- 코드 온디맨드(선택 사항): 요청을 받으면 서버에서 클라이언트로 실행 가능한 코드를 전송하여 클라이언트 기능을 확장할 수 있는 기능. <br/><br/>
    - 이처럼 REST API는 따라야 할 기준이 있지만, 속도를 저하시키고 더 무겁게 만드는 XML 메시징, 빌트인 보안 및 트랜잭션 컴플라이언스처럼 특정 요구 사항이 있는 SOAP(Simple Object Access Protocol) 등의 규정된 프로토콜보다 사용하기 쉬운 것으로 간주된다. 
    - 이와 대조적으로 REST는 필요에 따라 구현할 수 있는 일련의 지침으로, 이를 통해 REST API는 더 빨라지고 경량화되며 사물인터넷(IoT) 및 모바일 앱 개발에 가장 적합한 API가 된다. 

<br/><br/><br/><br/><br/><br/><br/><br/>

## Flask
- Micro Web Framework -> 간단한 웹 사이트, 혹은 간단한 API 서버를 만드는 데에 특화 되어있는 Python Web Framework 이다.
- 파이썬 웹 어플리케이션을 만드는 Framwork > Django보다 더 간단하게 만들 수 있음
- 매우 심플하고 가벼운 느낌을 가지는 프레임 워크 > 가볍지만 핵심적인 내용과 기능을 가지고 있음 <br/><br/>

```
from flask import Flask
app = Flask(__name__)  # Flask 객체 생성
 
@app.route('/')
def index():
    return '<h1>Hello World!</h1>'
 
if __name__ == "__main__":  # 모듈이 실행 됨을 알림
    app.run(debug=True, port=5000)  # 서버 실행, 파라미터로 debug 여부, port 설정 가능
```

<br/><br/>

## BluePrint
- Flask는 application component를 만들거나, applicaion 안팎으로 공통적인 패턴을 지원하는 목적으로 블루프린트라는 컨셉을 사용한다. 
- Blueprint는 큰 application을 단순화시키는 역할을 하고, Flask extension(확장 프로그램, 라이브러리 등) 등록을 위한 중심 수단으로도 쓰인다. <br/><br/>

- 플라스크는 django와 달리 url들을 파일 단위에서 따로 관리하지 않고, controller의 endpoint 함수에 데코레이터를 붙여서 관리한다.
- 라우트함수(@app.route로 매핑되는 함수)들은 기능이 필요할때마다 계속 추가되어야 하기 때문에, create_app 함수내에 함수가 많을 경우 번거로워질 수 있다. <br/><br/>

#### 이런 상황에서 블루프린트(Blueprint)를 이용하면 라우트 함수들을 보다 구조적으로 관리할 수 있게 된다.

<br/>

- 블루프린트의 기본 개념은 어플리케이션에 블루프린트이 등록될 때 실행할 동작을 기록한다는 것이다. 플라스크는 요청을 보내고 하나의 끝점에서 다른 곳으로 URL을 생성할 때 뷰 함수와 블루프린트의 연관을 맺는다. <br/><br/>
    - module 을 url 에 등록하기 쉽게 해주는 방법이다.

<br/><br/><br/><br/><br/><br/><br/><br/>

## SOCKET
- 소켓은 프로세스가 드넓은 네트워크 세계로 데이터를 내보내거나 혹은 그 세계로부터 데이터를 받기 위한 실제적인 창구 역할을 한다. <br/>그러므로 프로세스가 데이터를 보내거나 받기 위해서는 반드시 소켓을 열어서 소켓에 데이터를 써보내거나 소켓으로부터 데이터를 읽어들여야 한다. <br/><br/>
- 소켓은 떨어져 있는 두 호스트를 연결해주는 도구로써 인터페이스의 역할을 하는데 데이터를 주고받을 수 있는 구조체로 소켓을 통해 데이터 통로가 만들어진다.
    - 이러한 소켓은 역할에 따라 서버소켓, 클라이언트소켓으로 구분된다.

<br/><br/>

## Server
- 클라이언트와 소켓의 연결 요청을 대기하고, 연결 요청이 오면 클라이언트 소켓을 생성하여 통신이 가능하게 한다. <br/><br/>
```
1. socket() 함수를 이용하여 소켓 생성
2. bind() 함수로 ip와 port 번호를 설정
3. listen() 함수로 클라이언트의 접근 요청에 수신 대기열을 만들어 몇 개의 클라이언트를 대기시킬지 결정
4. accept() 함수를 사용하여 클라이언트와의 연결을 기다림
```

<br/><br/>

## Client
- 실제로 데이터 송수신이 일어나는 것은 클라이언트 소켓이다. <br/><br/>
```
1. socket() 함수로 가장 먼저 소켓을 연다.
2. connect() 함수를 이용하여 통신할 서버의 설정된 ip와 port 번호에 통신을 시도
3. 통신을 시도시, 서버가 accept() 함수를 이용하여 클라이언트의 socket descriptor를 반환
4. 이를 통해 클라이언트와 서버가 서로 read(), write()를 하며 통신 (이 과정이 반복)
```

<br/><br/>

## SOCKET 통신
- Server와 Client가 특정 Port를 통해 실시간으로 양방향 통신을 하는 방식 <br/><br/>

    - Server와 Client가 계속 연결을 유지하는 양방향 통신
    - Server와 Client가 실시간으로 데이터를 주고받는 상황이 필요한 경우에 사용된다.
    - 실시간 동영상 Streaming이나 온라인 게임 등과 같은 경우에 자주 사용된다.

<br/><br/>

## HTTP 통신
- Client의 요청(Request)이 있을 때만 서버가 응답(Response)하여 해당 정보를 전송하고 곧바로 연결을 종료하는 방식 <br/><br/>

    - Client가 요청을 보내는 경우에만 Server가 응답하는 단방향 통신
    - Server로부터 응답을 받은 후에는 연결이 바로 종료된다.
    - 실시간 연결이 아니고, 필요한 경우에만 Server로 요청을 보내는 상황에 유용하다.
    - 요청을 보내 Server의 응답을 기다리는 어플리케이션의 개발에 주로 사용된다.

<br/><br/><br/><br/><br/><br/><br/><br/>

## TCP
- 양방향으로 바이트 스트림을 전송, 연결 지향성
- 오류 수정. 전송처리, 흐름제어 보장
- 송신된 순서에 따라 중복되지 않게 데이터를 수신 -> 오버헤드 발생
- 소량의 데이터보다 대량의 데이터 전송에 적합 -> TCP를 사용

<br/><br/>

## UDP
- 비연결형소켓
- 데이터의 크기에 제한이 있음
- 확실하게 전달이 보장되지 않음. -> 데이터가 손실되어도 오류가 발생하지 않음
- 실시간 멀티미디어 정보를 처리하기 위해 주로 사용 ex)전화

<br/><br/><br/><br/><br/><br/><br/><br/>

## 일반적인 함수
- 일반적인 함수는 파라미터를 받아 함수 내부로 진입하고 결과값을 돌려줄 때는 return키워드를 사용해 호출자에게 값을 돌려 주는 구조로 되어 있다. 
- 또는 파라미터 자체를 Call by reference로 전달(포인터 전달)해 호출자가 참조하는 값 자체를 함수 내부에서 변경하기도 한다. <br/><br/>> 이 경우 리턴값은 없거나 에러 여부를 전달하는 데 쓰이게 된다.

<br/>

<pre><code>// 일반적인 함수
function sum(num1, num2){
    return num1+num2;
}
 
// 함수 호출
sum(1, 2);</code></pre>

<br/><br/>

## Callback Function
- 콜백 함수는 함수로써 다른 함수에 전달되며, 이는 외부 함수 내에서 일종의 루틴 또는 동작을 완성하기 위해 호출된다. <br/><br/>> 어떤 이벤트가 발생한 후, 수행될 함수를 의미

<br/>

<pre><code>function greeting(name){
    alert('안녕하세요. ' + name);
}
 
function processUserInput(callback){
    var name = prompt('이름을 입력해 주세요.');
    callback(name);
}
 
processUserInput(greeting);</code></pre>

<br/><br/><br/><br/><br/><br/><br/><br/>

## Process
- 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
- 운영체제로부터 시스템 자원을 할당받는 작업의 단위 <br/><br/>> 즉, 동적인 개념으로는 실행된 프로그램을 의미한다.

<br/><br/>

## Thread
- 스레드(thread)란 프로세스(process) 내에서 실제로 작업을 수행하는 주체를 의미한다.
- 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행한다.
- 또한, 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스(multi-threaded process)라고 한다.

<br/><br/><br/><br/><br/><br/><br/><br/>

## HTTP
- 컴퓨터들끼리 HTML파일을 주고받을 수 있도록 하는 소통방식 또는 약속
- HTTP는 곧 컴퓨터사이의 소통이라 했다. 이때 요청과 응답으로 이루어져있는 것이 핵심이다.
- 각각의 HTTP 통신(요청/응답)은 독립적이다. 따라서 과거의 통신(요청/응답)에 대한 내용을 전혀 알지 못한다. <br/><br/>> 웹에서는 브라우저와 서버 간에 데이터를 주고받기 위한 방식으로 HTTP 프로토콜을 사용하고 있다. <br/>> ex) 한 사이트에 로그인을 했을 때 한번 받은 로그인정보는 다음 통신에서 지워지는 것이다. 

<br/>

### 그렇다면 어떻게 로그인한 상태가 지속되는 걸까?
- 우리가 로그인을 하면 서버에서 '토큰(token)'이란 것을 발급해준다. 이것을 로컬스토리지나 브라우저에 저장한 후, 다음 통신 때 서버에 토큰을 같이 넘겨주는 것이다. <br/><br/>> 이러한 로그인 정보와같이 여러번의 통신과정에서 '연속된 데이터 처리'가 필요한경우를 위해 토큰이나 쿠키 로컬스토리지 같은 기술이 만들어졌다.

<br/><br/>

## Request
- 웹 브라우저(클라이언트)를 통해 서버에 요청하는것 -> Request <br/><br/>
    - 웹 브라우저에서 서버에 요청하는 정보가 Request객체에 담기게 된다.
    - JSP컨테이너가 서블릿으로 변환될때 자동으로 생성된다.

<br/>

### Request관련 method
- String getParameter(String name) : name에 해당하는 요청한 파라미터 값을 리턴받는다.
- HttpSession getSession() : Session객체를 리턴받는다.
- StringBuffer getRequestURL() : 요청 URL값을 리턴받는다.

<br/><br/>

## Response
- 서버에서 웹 브라우저(클라이언트)에 응답하는 것 -> Response <br/><br/>
    - 클라이언트의 요청에 응답하는것이 Response이고, 응답의 정보가 Response객체에 담기게 된다.
    - Request는 헤더의 값을 읽어오는 반면, Response는 헤더에 값을 추가하고, 리다이렉트 하는 것

<br/>

### Response 관련 method
- void addCookie(Cookie cookie) : cookie를 추가한다.
- void sendRedirect(String URL) : 해당 URL로 리다이렉트한다.

<br/><br/>

## HTTP Status Code
### 2xx 
- 성공 (200번대의 상태 코드는 대부분 성공을 의미) <br/><br/>
    - 200 : GET 요청에 대한 성공
    - 204 : No Content. 성공했으나 응답 본문에 데이터가 없음
    - 205 : Reset Content. 성공했으나 클라이언트의 화면을 새로 고침하도록 권고
    - 206 : Partial Conent. 성공했으나 일부 범위의 데이터만 반환

<br/>

### 3xx 
- 리다이렉션 (300번대의 상태 코드는 대부분 클라이언트가 이전 주소로 데이터를 요청하여 서버에서 새 URL로 리다이렉트를 유도하는 경우) <br/><br/>
    - 301 : Moved Permanently, 요청한 자원이 새 URL에 존재
    - 303 : See Other, 요청한 자원이 임시 주소에 존재
    - 304 : Not Modified, 요청한 자원이 변경되지 않았으므로 클라이언트에서 캐싱된 자원을 사용하도록 권고. ETag와 같은 정보를 활용하여 변경 여부를 확인

<br/>

### 4xx 
- 클라이언트 에러(400번대 상태 코드는 대부분 클라이언트의 코드가 잘못된 경우/유효하지 않은 자원을 요청했거나 요청이나 권한이 잘못된 경우 발생/ 가장 익숙한 상태 코드는 404 코드. 요청한 자원이 서버에 없다는 의미) <br/><br/>
    - 400 : Bad Request, 잘못된 요청
    - 401 : Unauthorized, 권한 없이 요청. Authorization 헤더가 잘못된 경우
    - 403 : Forbidden, 서버에서 해당 자원에 대해 접근 금지
    - 405 : Method Not Allowed, 허용되지 않은 요청 메서드
    - 409 : Conflict, 최신 자원이 아닌데 업데이트하는 경우. ex) 파일 업로드 시 버전 충돌

<br/>

### 5xx 
- 서버 에러 (500번대 상태 코드는 서버 쪽에서 오류가 난 경우) <br/><br/>
    - 501 : Not Implemented, 요청한 동작에 대해 서버가 수행할 수 없는 경우
    - 503 : Service Unavailable, 서버가 과부하 또는 유지 보수로 내려간 경우

<br/><br/><br/><br/><br/><br/><br/><br/>

## GET(가져오다)
- GET : 존재하는 자원에 대한 요청 <br/><br/>
    - 서버에게 resource를 보내달라고 요청한다. 
    - 서버(혹은 DB)의 resource는 클라이언트로 전달만 될 뿐 변경되지 않는다.

<br/><br/>

## POST(게시하다)
- POST : 새로운 자원을 생성 <br/><br/>
    - 서버에게 resource를 보내면서 생성해 달라고 요청한다. <br/>> 예를들어 회원가입을 하면 DB에 새로운 회원정보가 등록되고, 사진을 업로드 하면 그 사진이 웹사이트에 등록된다.

<br/><br/>

## DELETE(지우다)
- DELETE : 존재하는 자원에 대한 삭제 <br/><br/>
    - 서버에게 resource의 삭제를 요청한다.

<br/><br/>

## PUT(집어넣다)
- PUT : 존재하는 자원에 대한 변경 <br/><br/>
    - 서버에게 resource의 업데이트 하거나 resource가 없다면 새로운 resource를 생성해 달라고 요청한다. 회원정보 수정 등에 사용된다.
    - PUT은 PATCH와 비교해서 전체 데이터를 교체하는 차이점이 있다. <br/><br/>
``` 
가령 user data의 구조가 user._id, user.firstName, user.lastName, user.age라고 한다면, 
회원정보 수정시 PUT은 _id를 찾아 age만 업데이트하더라도 항상 모든 필드값을 가져와서 모든 필드를 항상 새로운 값으로 교체한다.
```

<br/><br/>

## PATCH
- 서버에게resource의 업데이트를 요청합니다. 회원정보 수정 등에 사용된다.
- PATCH는 PUT과 비교해서 부분 데이터를 업데이트하는 차이점이 있다. <br/><br/>

```
가령 user data의 구조가 user._id, user.firstName, user.lastName, user.age라고 한다면, 
회원정보 수정시 PATCH는 _id를 찾아 age만 업데이트할때 _id와 age만 받아와서해당 부분을 업데이트 한다.
```

<br/><br/><br/><br/><br/><br/><br/><br/>

## 지역 변수(local variable)
- 함수 내부에서 선언된 변수는 오직 함수 내부에서만 접근할 수 있다.
- 또한, 함수 내부에서 선언된 변수는 함수의 호출이 종료되면 메모리에서 제거된다.

<br/><br/>

## 전역 변수(global variable)
- 함수 밖에서 선언된 변수는 함수 밖에서만 바로 접근할 수 있다.
- 함수 밖에서 선언된 변수를 함수 내부에서 접근하고자 할 때는 global 키워드를 함께 사용해야 한다.

<br/><br/>

## 정적 변수(static variable)
- 함수 내부에서 static 키워드로 선언한 변수를 의미한다. 
- 함수 내부에서 선언된 정적 변수는 함수의 호출이 종료되더라도 메모리상에서 사라지지 않는다. <br/><br/>> 하지만 지역 변수처럼 해당 함수 내부에서만 접근할 수 있다.

<br/><br/><br/><br/><br/><br/><br/><br/>

## hungarian case
- Microsoft 사의 한 헝가리인 개발자가 사용하던 변수명에서 유래된 변수명
- 변수의 자료형을 변수명의 접두어로 붙이는 방식으로 간단하게 변수명만 보고 자료형을 인식할 수 있는 방식
- 옛날에는 효율성을 끌어냈는데, 가독성이 떨어지고 최근에는 개발도구의 발전으로 많이 쓰이지 않는 방식

<br/>

    - private int intNum; // int형 변수, intNum 또는 iNum으로도 사용 
    - private String strName; // String형 변수, strName 또는 sName으로도 사용 
    - private boolean boolNext; // boolean형 변수, boolNext 또는 bNext으로도 사용

<br/><br/>

## snake_case
- snake_case란 단어가 합쳐진 부분마다 중간에 언더라인을 붙여 주는 방법
- 일반적으로는 언더라인을 사용하나, 언더라인 대신 하이픈(-)을 써도 snake-case라고 할 수 있다. <br/><br/>
`[ ex) Night_Of_Knights, noumi_kudryavka_anatolyevna_strugatskaya,… ]`

<br/>

### Train_Case = Snake_Case에서, 각 단어의 맨 앞글자를 대문자로 표기하는 것
`[ ex) Visual_Studio_Community_2013, Not_Upper_Camel_case, … ]`

<br/>

### spinal_case = snake_case에서, 각 단어의 맨 앞글자를 소문자로 표기하는 것
`[ ex) visual_studio_community_2013, not_lower_camel_case, … ]`

<br/><br/>

## CamelCase
- CamelCase란 단어가 합쳐진 부분마다 맨 처음 글자를 대문자로 표기하는 방법.
- 두 개 이상의 단어가 모인 합성어에서 사용된다.

<br/>

### lowerCamelCase = camelCase에서, 맨 앞글자를 소문자로 표기하는 것
- 나머지 뒤에 따라붙는 단어들의 앞글자는 모두 대문자로 표기 <br/><br/>
`[ ex) namuWikiReflecBeatComponent, beatMania,… ]`

<br/>

### UpperCamelCase (=PascalCase) = CamelCase에서, 맨 앞글자를 대문자로 표기하는 것
- 나머지 뒤에 따라붙는 단어들의 앞글자는 모두 대문자로 표기 <br/><br/>
`[ ex) NamuWikiReflecBeatComponent, BeatMania,… ]`

<br/><br/>

## 기본적인 변수명 네이밍 컨벤션
- 컴파일러에서 제한하는 변수 명명 규칙 <br/><br/>

    - 대소문자는 구분되며 길이의 제한은 없다.
    - 예약어를 사용해서는 안 된다.
    - 숫자로 시작하면 안 된다.
    - 특수문자는 _ 와 $ 만 허용한다.

<br/>

1. 변수는 첫 글자의 소문자로 시작하는 명사로 짓는다.
2. 여러 단어로 이루어진 이름인 경우 각 단어의 첫 글자를 대문자로 한다. (카멜 표기법 사용)

<br/><br/><br/><br/><br/><br/><br/><br/>

## programming flag
- 프로그래밍에서는 ‘상태를 기록하고 처리 흐름을 제어하기 위한 boolean 변수’를 의미 <br/><br/>> True or False

<br/><br/><br/><br/><br/><br/><br/><br/>

## interrupt
- 마이크로프로세서(CPU)가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치에 예외상황이 발생하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말한다.

<br/>

### 내부 인터럽트
- 하드웨어 고장(Hardware Interrupt) 
    - 컴퓨터 고장
    - 데이터 전달 과정에서의 비트 오류
    - 전원이 나간 경우 <br/>

- 실행할 수 없는 명령어 : 기억장치에서 인출한 명령어의 비트 패턴이 정의되어 있지 않은 경우 
- 명령어 실행 오류 : 나누기 0을 하는 경우
- 사용 권한 위배 : 사용자가 운영체제만 사용할 수 있는 자원에 액세스하는 경우

<br/>

### 외부 인터럽트 > 외부 인터럽트는 주로 입출력장치 에 의해 발생된다.
- 타이머 인터럽트 : 타이머가 일정한 시간 간격으로 중앙처리장치에게 인터럽트를 요청 
- 입출력 인터럽트 : 속도가 느린 입출력장치가 입출력 준비가 완료되었음을 알리기 위해 인터럽트를 요청

---

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

## 클라우드 서버
- 인터넷을 통해 서버를 서비스 형태로 이용하는 방식 <br/><br/>> 즉, 서버를 따로 소유하지 않고 서비스의 형태로 빌려서 이용한다. <br/>> 따라서 클라우드 서버는 물리 서버와는 달리, 눈에 보이는 형태가 없다. <br/><br/>
- Cloud 속에서 원하는 작업을 요청하여 실행한다는 데서 기원 <br/><br/>> 구름은 우리 눈에는 보이지 않는 가상의 공간을 뜻한다.

<br/>

### 서버란?

- 온라인에서 사업을 하기 위해서는 기본적으로 온라인상에 공간이 필요하다. <br/>예를 들어, 온라인쇼핑몰을 만들려고 한다면, 오프라인 매장에서 여러 상품들을 배치하고 고객들이 드나들 수 있는 공간이 필요하듯이, 온라인에서도 이러한 공간이 있어야 한다. <br/><br/>> 서버는 이러한 공간을 온라인에 만들어주는 역할을 한다. <br/>> 온라인 상에 상품의 정보를 제공하고, 서비스를 이용하는 고객들이 드나들 수 있는 공간을 제공해주는 것이다.

<br/>

> 서버는 물리적인 형태를 지니고 있다. 따라서 서버를 둘 장소도 필요하고 관리도 필요하다.

<br/>

### 클라우드 서버 장점

#### 1. 유연성이 좋아서 빠른 대응이 가능하다.
- 클라우드 서버는 마우스 클릭 몇번으로 서버를 만들고 삭제할 수 있다. <br/><br/>> 따라서 상황별로 빠른 대응이 가능하다. <br/><br/>

#### 2. 불필요하게 리소스를 낭비할 필요가 없다.
- 초반에는 최소사양으로 서버를 만들었다가, 이후에 필요하면 점점 늘릴 수 있다. <br/><br/>

#### 3. 서버 관리가 용이하다.
- 물리적인 서버는 관리하는 데에 많은 인력과 비용이 필요하다. <br/><br/>> 시스템 엔지니어, 네트워크 엔지니어, 소프트웨어 엔지니어 등 <br/><br/>
- 클라우드 서버를 이용하면 소프트웨어 엔지니어 혼자서도 서버를 관리할 수 있다. <br/><br/>> 즉, 서버 관리에 필요한 자원을 줄일 수 있다.

---

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
