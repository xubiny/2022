# 기본 IT 지식
## 프로그래밍 언어 & 운영체제(OS)

<br/>

### 인간과 컴퓨터 사이에는 '컴파일러'가 있어서 인간의 요구를 컴퓨터에게 전달해준다.
- 개발자는 컴파일러에게 문서로 일을 시키는 사람이다.
- Java, Python, Ruby, Swift 등 영어로 되어 있는 프로그래밍 언어를 사용해 컴파일러에게 명령을 전달하면, 컴파일러가 그 명령어를 기계어인 0과 1로 변환해 컴퓨터에게 전달을 하는 방식이다.

<br/><br/>

### 개발자는 컴퓨가 해야 하는 일에 대한 문서를 작성한다.
- 프로그래밍 언어로 문서 작업 하는 행동을 '프로그래밍' 혹은 '코딩'이라고 한다.
- 컴파일러는 코딩한 문서를 0과 1로 바꿔서 컴퓨터에게 전달하고, 컴퓨터는 그대로 행동한다.
- 개발자들의 작업을 도와주는 기능들이 들어가 있는 프로그램들을 IDE(Integrated Development Environment). 즉, 통합 개발 환경이라고 부른다.
- 쉽게 말해 개발을 하기 위한 모든 것들을 제공해주는 환경이다.
<pre>IDE(통합 개발 환경)

Android Studio - 안드로이드 애플리케이션 개발 용도
Xcode - 애플 운영 체제 위의 애플리케이션 개발 용도
Eclipse - C/C++ 개발, 자바 개발, 웹 개발 용도
PyCharm - 파이썬 개발용도</pre>

<br/><br/>

### 프로그래밍언어를 구분하는 기준, '저수준'과 '고수준'
- 저수준 > 컴퓨터 친화적인 언어
- 고수준 > 인간 친화적인 언어

<br/><br/>

### 컴퓨터 구성 요소
- CPU, 메모리(RAM), 보조기억장치(HDD, SDD), 메인보드 +@

<br/><br/>

### 운영체제 > 우리 대신 하드웨어를 관리해준다.
- Windows
- MacOS
- iOS
- Android

---

<br/>

## 네트워크, 클라이언트, 서버

<br/>

### 컴퓨터 연결
- 컴퓨터가 연결된 작은 지역을 LAN(Local Area Network)이라고 표현한다.
- 사람들은 도시의 여러 LAN을 하나로 연결해 MAN(Metropolitan Area Network)을 만들었다.
- 그리고 도시와 도시, 나라와 나라를 모두 연결해서 WAN(Wide Area Network)을 만들었다.

<br/><br/>

### 서버와 클라이언트
- 파일을 달라고 계속 보채는 컴퓨터를 '클라이언트'
- 파일을 주는 컴퓨터를 '서버'

<br/><br/>

### 우분투란?
- 리눅스의 유명한 버전 중 하나 Ubuntu

<br/><br/>

### 서버 - 호스팅
- 개인이 서버를 운영하면 여러가지 리스크가 발생하게 된다.
- 그래서 이 모든 일들을 대신해주는 서비스가 나타나기 시작했는데 이런 서비스를 제공하는 업체를 '호스팅 업체'라고 부른다.
- 국내에는 대표적으로 Cafe24, 가비아 등의 회사가 있다.

---

<br/>

## API와 JSON

<br/>

### 클라이언트는 서버에게 요청을 보낸다.
- 그럼 서버는 요청에 따라 적합한 처리를 해서 응답을 준다. 하지만 컴퓨터는 한글을 모른다. > 어떤 요청이 '메시지를 달라'는 요청인지, '로그인 시켜줘'라는 요청인지 알 수 없다.
- 요청을 구분할 수 있도록 하는 '체계'가 필요하다. > 그 체계가 바로 API이다.


<br/><br/>

### API
- API는 클라이언트, 서버와 같은 서로 다른 프로그램에서 요청과 응답을 주고받을 수 있게 만든 체계이다.
- API는 서버 개발자가 개발하고, 클라이언트 개발자는 그 API를 사용한다.
- API를 만들 때는 데이터를 주고 받는 기능도 함께 넣는다.

<br/><br/>

### CRUD 요청
- Create > POST
- Read > GET
- Update > PUT(전체) / PATCH(일부)
- Delete > DELETE

<br/><br/>

### CRUD가 체계적으로 나뉘지 않을 수도 있다.
- 그럼 그 몇몇 API들이 문제를 일으키고 버그가 생긴다.
- 따라서 사람들은 좀 더 체계적으로 API를 관리하고 싶어 했고 그 영향으로 조금 더 체계적인 API라는 사회 운동이 만들어진다.
- 그런 API를 REST(Representational State Transfer)한 API 즉, RESTful API라고 부른다.

<br/><br/>

### 컴퓨터는 코딩된 대로 생각하고 응답을 보낸다.
- 200 > 잘 됐어
- 400번대 코드 > 클라이언트의 요청에서 문제가 있는 경우 
- 500 > 서버에 문제가 있는 경우

<br/><br/>

### 더불어 응답에는 데이터가 필요할 수 있다.
- 예를 들어, 내 정보를 수정할 때는 먼저 내 정보를 불러와야 한다.
- 그럼 '내 정보를 불러와 줘!'라는 요청을 보내고, 응답으로 정보를 받아야 한다.
- 응답의 영어는 'Response'. 요청(Request)과 마찬가지로 응답(Response)도 데이터를 담을 수 있다.
- 이렇게 요청와 응답에 데이터를 담아 주고받음으로써 API 요청이 완성된다.

<br/><br/>

### 정리하면 API는 소프트웨어가 다른 소프트웨어의 기능을 쓰기 위해 중간에 필요한 체계이다.
- 기능을 사용하기 위해 주소로 요청을 보내면 응답을 해주는 소프트웨어끼리의 체계라고 이해하면 된다.
<pre>한 컴퓨터에 여러 소프트웨어가 함께 있는 경우

- 서로 다른 시스템의 기능을 사용하기 위해서는 API가 필요하다.
> 'ㅁㅁ 소프트웨어'는 API를 사용하여 정해진 방법대로 '다른 소프트웨어'에 요청을 보낸다.
> '다른 소프트웨어'는 요청대로 작업을 수행하고, 응답을 준다.
>> 물론 API는 응답을 보내는 쪽에서 만들고, 요청을 보내는 쪽은 활용할뿐이다.
>>> 즉, 해당 API를 미리 만들어놓지 않았다면 쓸 수 없다.

이때 새로운 용어 SDK가 등장한다.
> API를 제공해주는 '다른 소프트웨어'를 SDK(Software Development Kit)라고 부른다.
> 소프트웨어를 개발하기 위한 도구이다.
>> 즉, 'ㅁㅁ 소프트웨어'를 개발할 때 '다른 소프트웨어'이다. </pre>

<br/><br/>

### 요청과 응답을 주고받을 때의 형식 JSON
- JSON은 중괄호로 시작한다.
- 키(Key)와 값(Value)으로 이루어져 있다. 키와 값은 '콜론(:)'으로 구분한다.
- 클라이언트와 서버는 요청과 응답을 주고받고, 그때 필요한 데이터들을 JSON 형식으로 주고받는다.

---

<br/>

## 애플리케이션과 웹

<br/>

### 애플리케이션
- 운영체제 위에 올라가는 프로그램, 설치해야 하는 프로그램, 응용프로그램, 애플리케이션, 어플, 앱, 모두 같은 그룹이다. = 통칭해서 '애플리케이션'

<br/><br/>

### 웹(Web)
- 웹을 구성하는 3요소 HTML(내용,구조) + JavaScript(프로그래밍 언어) + CSS(디자인)

<br/>

#### HTML
- 컴퓨터에게 특정 일을 시킬 수 있는 언어가 아닌 단지 브라우저가 볼 수 있는 문서를 적는 언어이다.

<br/>

#### CSS
- HTML에 디자인을 입힐 수 있는 코드 Cascading Style Sheets

<br/>

#### HTML + CSS = '퍼블리싱'
- 이 작업을 하는 사람 = '퍼블리셔'

<br/>

#### 마크업
- 마크업의 M은 HTML(Hyper Text Markup Language)의 M을 뜻한다.
- 즉, HTML 작업을 마크업 작업이라고 부르고, HTML 작업을 주로 하는 사람들을 마크업 개발자라고 한다.

<br/>

#### JavaScript
- JSON 형식으로 날아온 응답을 열어서 HTML로 바꾼다.

<br/><br/>

### 반응형 웹
- 반응형 : 브라우저의 가로 넓이에 '반응'하여 구성요소가 변하는 기술
- 웹페이지의 크기(비율)가 사용자의 기기에 맞춰 자동으로 변형된다.
- 서로 다른 기기의 넓이에 따른 CSS를 추가로 코딩해야 하므로 작업시간이 오래걸리고 비용이 더 많이 들어가게 된다.

<br/><br/>

### 네이티브 애플리케이션
- 원래 정해놓은 언어들을 사용해 개발한 애플리케이션
- 원래 정해놓은 언어들을 사용해 운영체제 자체의 기능을 사용하기 때문에 '원주민'이라는 뜻을 가진 '네이티브'가 붙게 됨
- 하지만 운영체제 안에 브라우저가 내장되자 새로운 방식으로도 애플리케이션 개발이 가능해짐
- 바로 애플리케이션의 특정 부분에 '브라우저'를 울리는 방식이다.
- 그리고 HTML 파일을 불러올 URL을 설정해두는 것이다.

<br/><br/>

### 하이브리드 애플리케이션
- 네이티브와 브라우저가 혼합된 애플리케이션
- 브라우저 위에서 돌아가는 부분은 서버에 있는 원본 HTML, CSS, JavaScript를 수정하면 바뀐다. > 이 부분은 보통 앱 화면이 뜰 때 바뀐다.
- 반면 네이티브인 부분은 운영체제별로 다른 프로그래밍 언어를 통해 수정한 뒤 심사를 신청해야 한다.
- 심사 신청 뒤에도 사람들이 바뀐 애플리케이션으로 업데이트해야한다. > 시간이 오래걸리고 까다롭다.

---

<br/>

## 데이터베이스와 이미지 처리

<br/>

### 관계형 데이터베이스
- 데이터 관리 방법론
- 엑셀의 Sheet를 관계형 데이터베이스에서는 Table이라고 표현단다.
- 그리고 엑셀 파일 자체를 Schema 혹은 Database라고 표현한다.


<br/><br/>

### 관계형 데이터베이스 관리 시스템
- 데이터들을 파일로 만들어서 저장하고 관리해주는 소프트웨어
- 관계형 데이터베이스의 철학으로 만들어진 관리시스템을 RDBMS이라고 부른다.
- MSSQL, Oracle DB, MySQL, MariaDB

<br/><br/>

### 클라이언트에 데이터가 있다
- "그 데이터는 로컬에 있어요."
- "내부 DB에 저장하고 있어요."
- "네이티브에서 가져왔어요."
- 프론트/프론트엔드

<br/><br/>

### 서버에서 데이터를 가져왔다.
- API 요청
- DB
- 백/백엔드

<br/><br/>

### 이미지 처리
- 이미지 파일은 컴퓨터에 있다. > 클라이언트나 서버 둘 중 하나에 있다.
- 그리고 각 컴퓨터는 이미지 주소를 통해 이미지에 접근한다.
- 이 이미지들을 바꾸려면 파일을 바꾸거나 다른 주소를 지정하면 된다.
- 그리고 프로필 이미지 같은 파일들은 '관계'가 있기 때문에 관리가 필요하다. > 그래서 주소를 DB에 넣어서 관리한다.
- 마지막으로, 이미지가 클라이언트에 있는지 서버에 있는지 확인하는 가장 좋은 방법은 API 문서를 보는 것이다.
- API를 통해 이미지의 주소(URL)를 서버에서 받아온다면, 그 이미지는 서버에 있는 이미지라고 판단할 수 있다.

---

<br/>

## 프레임워크와 라이브러리

<br/>

### 프레임워크
- 애플리케이션을 쉽고 빠르게 개발할 수 있다.

<br/>

#### 각 언어별로 유명한 프레임워크들이 하나씩 있다.

- 자바 - Spring이라는 프레임워크를 사용하면 서버를 쉽고 빠르게 개발할 수 있다.
- 파이썬 - Django
- 루비 - Rails
- JavaScript - Express.js

<br/><br/>

### 라이브러리
- 다른사람들이 만들어놓은 코드를 이용한다는 측면에서 프레임워크와 같다.
- 각종 라이브러리와 코드들이 모여 프레임워크가 된다.
- 더불어 한 프로젝트에서 프레임워크는 하나만 쓸 수 있다.
- 반면 라이브러리는 더 작은 개념이다. 망치나 가위같은 도구들이기 때문에 한 프로젝트에서 함께 사용이 가능하다.

---

<br/>

## 협업, 소스관리, 디자인

<br/>

### Git
- 깃을 통해 개발자들은 개발 단계별로 '깃발'을 꽂을 수 있다.
- 그 행위를 커밋(Commit)이라고 한다.
- 커밋에는 무슨 개발을 했는지 적어주는 메모가 항상 따라다닌다.
- 그 메모를 커밋 로그(Commit Log)라고 한다.

<br/><br/>

### 디자인과 개발자간의 갈등 > UI
- 개발자는 포토샵과 일러스트 작업물의 수치를 하나씩 파악해야 하는 불편함이 생김
- 개발자들은 디자인의 수치를 모두 표시해서 달라는 '가이드' 요구
- 해결 => 스케치, 재플린, XD > 이 프로그램들은 디자이너의 작업 결과물의 수치를 보여준다.

---

![image](https://user-images.githubusercontent.com/61584142/123468843-471eb800-d62d-11eb-9695-2257b5d45d13.png)

---

##### vs code 

[https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf]

Ctrl+D // 현재 커서 위치의 단어와 같은 단어 하나씩 추가 선택 <br/>
Ctrl+Shift_L // 현재 커서 위치의 단어와 같은 단어 모두 선택 <br/>
Shift+Alt+(클릭 or 드래그) // 현재 커서 위치부터 클릭하거나 드래그한 위치까지 선택하여 여러 줄을 동시에 수정 <br/>

<br/><br/>

Alt + (위 아래 방향키) // 현재 줄 이동 <br/>
Alt+Shift+(위 아래 방향키) // 현재 줄 복사 <br/>
Ctrl+Shift+Alt+(방향키) // 여러 줄 동시 선택 <br/>

<br/><br/>

Shift+Alt+(오른쪽방향키) // 현재 커서 위치의 scope부터 순차적으로 선택 <br/>
Ctrl+Alt+(위아래방향키) // 여러 줄 동시에 수정 <br/>

<br/><br/>

Ctrl+` // 터미널보이기 <br/>
Ctrl+Shift+` // 새 커미널 생성 <br/>

---

<pre><code>ps -aux|grep py
raspivid -f or -i
rm -9 file
</code></pre>

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

[1] 텍스트와 특수문자를 조합해서 사진과 그림을 표현한 것. 
= 아스키 아트(ASCII Art)

[2] 최소화되고 모듈화된 소프트웨어 개발 방식을 위한 문화적 규범이자 철학적 접근 방식. 
= Unix 철학

[3] 명령줄 또는 명령어 인터페이스는 텍스트 터미널을 통해 사용자와 컴퓨터가 상호 작용하는 방식을 말한다. 
= Command-line

[4] 취미 활동으로 즐기는 아마추어 무선 통신. 
= HAM 라디오

[5] 사용자 인터페이스 개발을 위해 페이스북에서 만들고 공개한 오픈소스 자바스크립트 라이브러리. 
= React

[6] 변수를 정의한 클래스 외부에서도 접근할 수 있는 변수. 
= public 변수

[7] 외부에 노출되지 않고 정의한 클래스 내부에서만 접근할 수 있는 변수. 
= private 변수

[8] 아틀라시안(Atlassian)이 개발한 이슈추적 소프트 웨어로 버그 추적, 이슈 추적, 프로젝트 관리 기능 등을 제공한다. 
= Jira

[9] 객체 지향 프로그래밍의 핵심인 클래스와 그 서브클래스 간의 계층 구조를 도식으로 나타낸 것. 
= Class Hierarchy

[10] 프로그램을 작성할 때 각 모듈이 작동하는 논리를 표현하기 위한 언어이다. 특정 프로그래밍 언어의 문법이 아닌 알고리즘 그 자체이 집중할 수 있기 때문에 코딩 면접에서 많이 사용된다. 
= Pseudo code

---

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

## RESTful API
- REST API(RESTful API, 레스트풀 API)란 REST 아키텍처의 제약 조건을 준수하는 애플리케이션 프로그래밍 인터페이스를 뜻한다. <br/>REST는 Representational State Transfer의 줄임말이다. <br/><br/>

- API는 애플리케이션 소프트웨어를 구축하고 통합하는 정의 및 프로토콜 세트이다. <br/>때때로 API는 정보 제공자와 정보 사용자 간의 계약으로 지칭되며 소비자에게 필요한 콘텐츠(호출)와 생산자에게 필요한 콘텐츠(응답)를 구성한다. <br/><br/>

- 예를 들어 날씨 서비스용 API에서는 사용자는 우편번호를 제공하고, 생산자는 두 부분(첫 번째는 최고 기온, 두 번째는 최저 기온)으로 구성된 응답으로 답하도록 지정할 수 있다. <br/> 즉, 컴퓨터나 시스템과 상호 작용하여 정보를 검색하거나 기능을 수행하고자 할 때 API는 사용자가 원하는 것을 시스템에 전달할 수 있게 지원하여 시스템이 이 요청을 이해하고 이행하도록 할 수 있다. <br/><br/>

- API를 사용자 또는 클라이언트, 그리고 사용자와 클라이언트가 얻으려 하는 리소스 사이의 조정자로 생각하면 된다. <br/>API는 조직이 보안 및 제어를 유지관리(누가 무엇에 액세스할 수 있는지 결정)하면서 리소스와 정보를 공유할 수 있는 방법이기도 하다. <br/>API의 또 다른 이점은 리소스 검색 방법 또는 리소스의 출처에 대한 지식 없이도 사용이 가능하다는 점이다. <br/><br/>

- REST는 프로토콜이나 표준이 아닌 아키텍처 원칙 세트이다. <br/>API 개발자는 REST를 다양한 방식으로 구현할 수 있다. <br/>
    - RESTful API를 통해 요청이 수행될 때 RESTful API는 리소스 상태에 대한 표현을 요청자에게 전송한다. 
    - 이 정보 또는 표현은 HTTP: JSON(Javascript Object Notation), HTML, XLT 또는 일반 텍스트를 통해 몇 가지 형식으로 전송된다. 
    - JSON은 그 이름에도 불구하고 사용 언어와 상관이 없을 뿐 아니라 인간과 머신이 모두 읽을 수 있기 때문에 가장 널리 사용된다. <br/><br/>

### API가 RESTful로 간주되려면 다음 기준을 따라야 한다.
- 클라이언트, 서버 및 리소스로 구성되었으며 요청이 HTTP를 통해 관리되는 클라이언트-서버 아키텍처
- 스테이트리스(stateless) 클라이언트-서버 커뮤니케이션: 요청 간에 클라이언트 정보가 저장되지 않으며, 각 요청이 분리되어 있고 서로 연결되어 있지 않음
- 클라이언트-서버 상호 작용을 간소화하는 캐시 가능 데이터 

<br/>

### 정보가 표준 형식으로 전송되도록 하기 위한 구성 요소 간 통합 인터페이스. 여기에 필요한 것은 다음과 같다.
- 요청된 리소스가 식별 가능하며 클라이언트에 전송된 표현과 분리되어야 한다.
- 수신한 표현을 통해 클라이언트가 리소스를 조작할 수 있어야 한다(이렇게 할 수 있는 충분한 정보가 표현에 포함되어 있기 때문).
- 클라이언트에 반환되는 자기 기술적(self-descriptive) 메시지에 클라이언트가 정보를 어떻게 처리해야 할지 설명하는 정보가 충분히 포함되어야 한다.
- 하이퍼미디어: 클라이언트가 리소스에 액세스한 후 하이퍼링크를 사용해 현재 수행 가능한 기타 모든 작업을 찾을 수 있어야 한다.

<br/>

- 요청된 정보를 검색하는 데 관련된 서버(보안, 로드 밸런싱 등을 담당)의 각 유형을 클라이언트가 볼 수 없는 계층 구조로 체계화하는 계층화된 시스템. 
- 코드 온디맨드(선택 사항): 요청을 받으면 서버에서 클라이언트로 실행 가능한 코드를 전송하여 클라이언트 기능을 확장할 수 있는 기능. <br/><br/>
    - 이처럼 REST API는 따라야 할 기준이 있지만, 속도를 저하시키고 더 무겁게 만드는 XML 메시징, 빌트인 보안 및 트랜잭션 컴플라이언스처럼 특정 요구 사항이 있는 SOAP(Simple Object Access Protocol) 등의 규정된 프로토콜보다 사용하기 쉬운 것으로 간주된다. 
    - 이와 대조적으로 REST는 필요에 따라 구현할 수 있는 일련의 지침으로, 이를 통해 REST API는 더 빨라지고 경량화되며 사물인터넷(IoT) 및 모바일 앱 개발에 가장 적합한 API가 된다. 

<br/><br/><br/><br/><br/><br/><br/><br/>

## Flask
- Micro Web Framework -> 간단한 웹 사이트, 혹은 간단한 API 서버를 만드는 데에 특화 되어있는 Python Web Framework 이다.
- 파이썬 웹 어플리케이션을 만드는 Framwork > Django보다 더 간단하게 만들 수 있음
- 매우 심플하고 가벼운 느낌을 가지는 프레임 워크 > 가볍지만 핵심적인 내용과 기능을 가지고 있음 <br/><br/>

```
from flask import Flask
app = Flask(__name__)  # Flask 객체 생성
 
@app.route('/')
def index():
    return '<h1>Hello World!</h1>'
 
if __name__ == "__main__":  # 모듈이 실행 됨을 알림
    app.run(debug=True, port=5000)  # 서버 실행, 파라미터로 debug 여부, port 설정 가능
```

<br/><br/>

## BluePrint
- Flask는 application component를 만들거나, applicaion 안팎으로 공통적인 패턴을 지원하는 목적으로 블루프린트라는 컨셉을 사용한다. 
- Blueprint는 큰 application을 단순화시키는 역할을 하고, Flask extension(확장 프로그램, 라이브러리 등) 등록을 위한 중심 수단으로도 쓰인다. <br/><br/>

- 플라스크는 django와 달리 url들을 파일 단위에서 따로 관리하지 않고, controller의 endpoint 함수에 데코레이터를 붙여서 관리한다.
- 라우트함수(@app.route로 매핑되는 함수)들은 기능이 필요할때마다 계속 추가되어야 하기 때문에, create_app 함수내에 함수가 많을 경우 번거로워질 수 있다. <br/><br/>

#### 이런 상황에서 블루프린트(Blueprint)를 이용하면 라우트 함수들을 보다 구조적으로 관리할 수 있게 된다.

<br/>

- 블루프린트의 기본 개념은 어플리케이션에 블루프린트이 등록될 때 실행할 동작을 기록한다는 것이다. 플라스크는 요청을 보내고 하나의 끝점에서 다른 곳으로 URL을 생성할 때 뷰 함수와 블루프린트의 연관을 맺는다. <br/><br/>
    - module 을 url 에 등록하기 쉽게 해주는 방법이다.

<br/><br/><br/><br/><br/><br/><br/><br/>

## SOCKET
- 소켓은 프로세스가 드넓은 네트워크 세계로 데이터를 내보내거나 혹은 그 세계로부터 데이터를 받기 위한 실제적인 창구 역할을 한다. <br/>그러므로 프로세스가 데이터를 보내거나 받기 위해서는 반드시 소켓을 열어서 소켓에 데이터를 써보내거나 소켓으로부터 데이터를 읽어들여야 한다. <br/><br/>
- 소켓은 떨어져 있는 두 호스트를 연결해주는 도구로써 인터페이스의 역할을 하는데 데이터를 주고받을 수 있는 구조체로 소켓을 통해 데이터 통로가 만들어진다.
    - 이러한 소켓은 역할에 따라 서버소켓, 클라이언트소켓으로 구분된다.

<br/><br/>

## Server
- 클라이언트와 소켓의 연결 요청을 대기하고, 연결 요청이 오면 클라이언트 소켓을 생성하여 통신이 가능하게 한다. <br/><br/>
```
1. socket() 함수를 이용하여 소켓 생성
2. bind() 함수로 ip와 port 번호를 설정
3. listen() 함수로 클라이언트의 접근 요청에 수신 대기열을 만들어 몇 개의 클라이언트를 대기시킬지 결정
4. accept() 함수를 사용하여 클라이언트와의 연결을 기다림
```

<br/><br/>

## Client
- 실제로 데이터 송수신이 일어나는 것은 클라이언트 소켓이다. <br/><br/>
```
1. socket() 함수로 가장 먼저 소켓을 연다.
2. connect() 함수를 이용하여 통신할 서버의 설정된 ip와 port 번호에 통신을 시도
3. 통신을 시도시, 서버가 accept() 함수를 이용하여 클라이언트의 socket descriptor를 반환
4. 이를 통해 클라이언트와 서버가 서로 read(), write()를 하며 통신 (이 과정이 반복)
```

<br/><br/>

## SOCKET 통신
- Server와 Client가 특정 Port를 통해 실시간으로 양방향 통신을 하는 방식 <br/><br/>

    - Server와 Client가 계속 연결을 유지하는 양방향 통신
    - Server와 Client가 실시간으로 데이터를 주고받는 상황이 필요한 경우에 사용된다.
    - 실시간 동영상 Streaming이나 온라인 게임 등과 같은 경우에 자주 사용된다.

<br/><br/>

## HTTP 통신
- Client의 요청(Request)이 있을 때만 서버가 응답(Response)하여 해당 정보를 전송하고 곧바로 연결을 종료하는 방식 <br/><br/>

    - Client가 요청을 보내는 경우에만 Server가 응답하는 단방향 통신
    - Server로부터 응답을 받은 후에는 연결이 바로 종료된다.
    - 실시간 연결이 아니고, 필요한 경우에만 Server로 요청을 보내는 상황에 유용하다.
    - 요청을 보내 Server의 응답을 기다리는 어플리케이션의 개발에 주로 사용된다.

<br/><br/><br/><br/><br/><br/><br/><br/>

## TCP
- 양방향으로 바이트 스트림을 전송, 연결 지향성
- 오류 수정. 전송처리, 흐름제어 보장
- 송신된 순서에 따라 중복되지 않게 데이터를 수신 -> 오버헤드 발생
- 소량의 데이터보다 대량의 데이터 전송에 적합 -> TCP를 사용

<br/><br/>

## UDP
- 비연결형소켓
- 데이터의 크기에 제한이 있음
- 확실하게 전달이 보장되지 않음. -> 데이터가 손실되어도 오류가 발생하지 않음
- 실시간 멀티미디어 정보를 처리하기 위해 주로 사용 ex)전화

<br/><br/><br/><br/><br/><br/><br/><br/>

## 일반적인 함수
- 일반적인 함수는 파라미터를 받아 함수 내부로 진입하고 결과값을 돌려줄 때는 return키워드를 사용해 호출자에게 값을 돌려 주는 구조로 되어 있다. 
- 또는 파라미터 자체를 Call by reference로 전달(포인터 전달)해 호출자가 참조하는 값 자체를 함수 내부에서 변경하기도 한다. <br/><br/>> 이 경우 리턴값은 없거나 에러 여부를 전달하는 데 쓰이게 된다.

<br/>

<pre><code>// 일반적인 함수
function sum(num1, num2){
    return num1+num2;
}
 
// 함수 호출
sum(1, 2);</code></pre>

<br/><br/>

## Callback Function
- 콜백 함수는 함수로써 다른 함수에 전달되며, 이는 외부 함수 내에서 일종의 루틴 또는 동작을 완성하기 위해 호출된다. <br/><br/>> 어떤 이벤트가 발생한 후, 수행될 함수를 의미

<br/>

<pre><code>function greeting(name){
    alert('안녕하세요. ' + name);
}
 
function processUserInput(callback){
    var name = prompt('이름을 입력해 주세요.');
    callback(name);
}
 
processUserInput(greeting);</code></pre>

<br/><br/><br/><br/><br/><br/><br/><br/>

## Process
- 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
- 운영체제로부터 시스템 자원을 할당받는 작업의 단위 <br/><br/>> 즉, 동적인 개념으로는 실행된 프로그램을 의미한다.

<br/><br/>

## Thread
- 스레드(thread)란 프로세스(process) 내에서 실제로 작업을 수행하는 주체를 의미한다.
- 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행한다.
- 또한, 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스(multi-threaded process)라고 한다.

<br/><br/><br/><br/><br/><br/><br/><br/>

## HTTP
- 컴퓨터들끼리 HTML파일을 주고받을 수 있도록 하는 소통방식 또는 약속
- HTTP는 곧 컴퓨터사이의 소통이라 했다. 이때 요청과 응답으로 이루어져있는 것이 핵심이다.
- 각각의 HTTP 통신(요청/응답)은 독립적이다. 따라서 과거의 통신(요청/응답)에 대한 내용을 전혀 알지 못한다. <br/><br/>> 웹에서는 브라우저와 서버 간에 데이터를 주고받기 위한 방식으로 HTTP 프로토콜을 사용하고 있다. <br/>> ex) 한 사이트에 로그인을 했을 때 한번 받은 로그인정보는 다음 통신에서 지워지는 것이다. 

<br/>

### 그렇다면 어떻게 로그인한 상태가 지속되는 걸까?
- 우리가 로그인을 하면 서버에서 '토큰(token)'이란 것을 발급해준다. 이것을 로컬스토리지나 브라우저에 저장한 후, 다음 통신 때 서버에 토큰을 같이 넘겨주는 것이다. <br/><br/>> 이러한 로그인 정보와같이 여러번의 통신과정에서 '연속된 데이터 처리'가 필요한경우를 위해 토큰이나 쿠키 로컬스토리지 같은 기술이 만들어졌다.

<br/><br/>

## Request
- 웹 브라우저(클라이언트)를 통해 서버에 요청하는것 -> Request <br/><br/>
    - 웹 브라우저에서 서버에 요청하는 정보가 Request객체에 담기게 된다.
    - JSP컨테이너가 서블릿으로 변환될때 자동으로 생성된다.

<br/>

### Request관련 method
- String getParameter(String name) : name에 해당하는 요청한 파라미터 값을 리턴받는다.
- HttpSession getSession() : Session객체를 리턴받는다.
- StringBuffer getRequestURL() : 요청 URL값을 리턴받는다.

<br/><br/>

## Response
- 서버에서 웹 브라우저(클라이언트)에 응답하는 것 -> Response <br/><br/>
    - 클라이언트의 요청에 응답하는것이 Response이고, 응답의 정보가 Response객체에 담기게 된다.
    - Request는 헤더의 값을 읽어오는 반면, Response는 헤더에 값을 추가하고, 리다이렉트 하는 것

<br/>

### Response 관련 method
- void addCookie(Cookie cookie) : cookie를 추가한다.
- void sendRedirect(String URL) : 해당 URL로 리다이렉트한다.

<br/><br/>

## HTTP Status Code
### 2xx 
- 성공 (200번대의 상태 코드는 대부분 성공을 의미) <br/><br/>
    - 200 : GET 요청에 대한 성공
    - 204 : No Content. 성공했으나 응답 본문에 데이터가 없음
    - 205 : Reset Content. 성공했으나 클라이언트의 화면을 새로 고침하도록 권고
    - 206 : Partial Conent. 성공했으나 일부 범위의 데이터만 반환

<br/>

### 3xx 
- 리다이렉션 (300번대의 상태 코드는 대부분 클라이언트가 이전 주소로 데이터를 요청하여 서버에서 새 URL로 리다이렉트를 유도하는 경우) <br/><br/>
    - 301 : Moved Permanently, 요청한 자원이 새 URL에 존재
    - 303 : See Other, 요청한 자원이 임시 주소에 존재
    - 304 : Not Modified, 요청한 자원이 변경되지 않았으므로 클라이언트에서 캐싱된 자원을 사용하도록 권고. ETag와 같은 정보를 활용하여 변경 여부를 확인

<br/>

### 4xx 
- 클라이언트 에러(400번대 상태 코드는 대부분 클라이언트의 코드가 잘못된 경우/유효하지 않은 자원을 요청했거나 요청이나 권한이 잘못된 경우 발생/ 가장 익숙한 상태 코드는 404 코드. 요청한 자원이 서버에 없다는 의미) <br/><br/>
    - 400 : Bad Request, 잘못된 요청
    - 401 : Unauthorized, 권한 없이 요청. Authorization 헤더가 잘못된 경우
    - 403 : Forbidden, 서버에서 해당 자원에 대해 접근 금지
    - 405 : Method Not Allowed, 허용되지 않은 요청 메서드
    - 409 : Conflict, 최신 자원이 아닌데 업데이트하는 경우. ex) 파일 업로드 시 버전 충돌

<br/>

### 5xx 
- 서버 에러 (500번대 상태 코드는 서버 쪽에서 오류가 난 경우) <br/><br/>
    - 501 : Not Implemented, 요청한 동작에 대해 서버가 수행할 수 없는 경우
    - 503 : Service Unavailable, 서버가 과부하 또는 유지 보수로 내려간 경우

<br/><br/><br/><br/><br/><br/><br/><br/>

## GET(가져오다)
- GET : 존재하는 자원에 대한 요청 <br/><br/>
    - 서버에게 resource를 보내달라고 요청한다. 
    - 서버(혹은 DB)의 resource는 클라이언트로 전달만 될 뿐 변경되지 않는다.

<br/><br/>

## POST(게시하다)
- POST : 새로운 자원을 생성 <br/><br/>
    - 서버에게 resource를 보내면서 생성해 달라고 요청한다. <br/>> 예를들어 회원가입을 하면 DB에 새로운 회원정보가 등록되고, 사진을 업로드 하면 그 사진이 웹사이트에 등록된다.

<br/><br/>

## DELETE(지우다)
- DELETE : 존재하는 자원에 대한 삭제 <br/><br/>
    - 서버에게 resource의 삭제를 요청한다.

<br/><br/>

## PUT(집어넣다)
- PUT : 존재하는 자원에 대한 변경 <br/><br/>
    - 서버에게 resource의 업데이트 하거나 resource가 없다면 새로운 resource를 생성해 달라고 요청한다. 회원정보 수정 등에 사용된다.
    - PUT은 PATCH와 비교해서 전체 데이터를 교체하는 차이점이 있다. <br/><br/>
``` 
가령 user data의 구조가 user._id, user.firstName, user.lastName, user.age라고 한다면, 
회원정보 수정시 PUT은 _id를 찾아 age만 업데이트하더라도 항상 모든 필드값을 가져와서 모든 필드를 항상 새로운 값으로 교체한다.
```

<br/><br/>

## PATCH
- 서버에게resource의 업데이트를 요청합니다. 회원정보 수정 등에 사용된다.
- PATCH는 PUT과 비교해서 부분 데이터를 업데이트하는 차이점이 있다. <br/><br/>

```
가령 user data의 구조가 user._id, user.firstName, user.lastName, user.age라고 한다면, 
회원정보 수정시 PATCH는 _id를 찾아 age만 업데이트할때 _id와 age만 받아와서해당 부분을 업데이트 한다.
```

<br/><br/><br/><br/><br/><br/><br/><br/>

## 지역 변수(local variable)
- 함수 내부에서 선언된 변수는 오직 함수 내부에서만 접근할 수 있다.
- 또한, 함수 내부에서 선언된 변수는 함수의 호출이 종료되면 메모리에서 제거된다.

<br/><br/>

## 전역 변수(global variable)
- 함수 밖에서 선언된 변수는 함수 밖에서만 바로 접근할 수 있다.
- 함수 밖에서 선언된 변수를 함수 내부에서 접근하고자 할 때는 global 키워드를 함께 사용해야 한다.

<br/><br/>

## 정적 변수(static variable)
- 함수 내부에서 static 키워드로 선언한 변수를 의미한다. 
- 함수 내부에서 선언된 정적 변수는 함수의 호출이 종료되더라도 메모리상에서 사라지지 않는다. <br/><br/>> 하지만 지역 변수처럼 해당 함수 내부에서만 접근할 수 있다.

<br/><br/><br/><br/><br/><br/><br/><br/>

## hungarian case
- Microsoft 사의 한 헝가리인 개발자가 사용하던 변수명에서 유래된 변수명
- 변수의 자료형을 변수명의 접두어로 붙이는 방식으로 간단하게 변수명만 보고 자료형을 인식할 수 있는 방식
- 옛날에는 효율성을 끌어냈는데, 가독성이 떨어지고 최근에는 개발도구의 발전으로 많이 쓰이지 않는 방식

<br/>

    - private int intNum; // int형 변수, intNum 또는 iNum으로도 사용 
    - private String strName; // String형 변수, strName 또는 sName으로도 사용 
    - private boolean boolNext; // boolean형 변수, boolNext 또는 bNext으로도 사용

<br/><br/>

## snake_case
- snake_case란 단어가 합쳐진 부분마다 중간에 언더라인을 붙여 주는 방법
- 일반적으로는 언더라인을 사용하나, 언더라인 대신 하이픈(-)을 써도 snake-case라고 할 수 있다. <br/><br/>
`[ ex) Night_Of_Knights, noumi_kudryavka_anatolyevna_strugatskaya,… ]`

<br/>

### Train_Case = Snake_Case에서, 각 단어의 맨 앞글자를 대문자로 표기하는 것
`[ ex) Visual_Studio_Community_2013, Not_Upper_Camel_case, … ]`

<br/>

### spinal_case = snake_case에서, 각 단어의 맨 앞글자를 소문자로 표기하는 것
`[ ex) visual_studio_community_2013, not_lower_camel_case, … ]`

<br/><br/>

## CamelCase
- CamelCase란 단어가 합쳐진 부분마다 맨 처음 글자를 대문자로 표기하는 방법.
- 두 개 이상의 단어가 모인 합성어에서 사용된다.

<br/>

### lowerCamelCase = camelCase에서, 맨 앞글자를 소문자로 표기하는 것
- 나머지 뒤에 따라붙는 단어들의 앞글자는 모두 대문자로 표기 <br/><br/>
`[ ex) namuWikiReflecBeatComponent, beatMania,… ]`

<br/>

### UpperCamelCase (=PascalCase) = CamelCase에서, 맨 앞글자를 대문자로 표기하는 것
- 나머지 뒤에 따라붙는 단어들의 앞글자는 모두 대문자로 표기 <br/><br/>
`[ ex) NamuWikiReflecBeatComponent, BeatMania,… ]`

<br/><br/>

## 기본적인 변수명 네이밍 컨벤션
- 컴파일러에서 제한하는 변수 명명 규칙 <br/><br/>

    - 대소문자는 구분되며 길이의 제한은 없다.
    - 예약어를 사용해서는 안 된다.
    - 숫자로 시작하면 안 된다.
    - 특수문자는 _ 와 $ 만 허용한다.

<br/>

1. 변수는 첫 글자의 소문자로 시작하는 명사로 짓는다.
2. 여러 단어로 이루어진 이름인 경우 각 단어의 첫 글자를 대문자로 한다. (카멜 표기법 사용)

<br/><br/><br/><br/><br/><br/><br/><br/>

## programming flag
- 프로그래밍에서는 ‘상태를 기록하고 처리 흐름을 제어하기 위한 boolean 변수’를 의미 <br/><br/>> True or False

<br/><br/><br/><br/><br/><br/><br/><br/>

## interrupt
- 마이크로프로세서(CPU)가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치에 예외상황이 발생하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말한다.

<br/>

### 내부 인터럽트
- 하드웨어 고장(Hardware Interrupt) 
    - 컴퓨터 고장
    - 데이터 전달 과정에서의 비트 오류
    - 전원이 나간 경우 <br/>

- 실행할 수 없는 명령어 : 기억장치에서 인출한 명령어의 비트 패턴이 정의되어 있지 않은 경우 
- 명령어 실행 오류 : 나누기 0을 하는 경우
- 사용 권한 위배 : 사용자가 운영체제만 사용할 수 있는 자원에 액세스하는 경우

<br/>

### 외부 인터럽트 > 외부 인터럽트는 주로 입출력장치 에 의해 발생된다.
- 타이머 인터럽트 : 타이머가 일정한 시간 간격으로 중앙처리장치에게 인터럽트를 요청 
- 입출력 인터럽트 : 속도가 느린 입출력장치가 입출력 준비가 완료되었음을 알리기 위해 인터럽트를 요청

---

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

## 클라우드 서버
- 인터넷을 통해 서버를 서비스 형태로 이용하는 방식 <br/><br/>> 즉, 서버를 따로 소유하지 않고 서비스의 형태로 빌려서 이용한다. <br/>> 따라서 클라우드 서버는 물리 서버와는 달리, 눈에 보이는 형태가 없다. <br/><br/>
- Cloud 속에서 원하는 작업을 요청하여 실행한다는 데서 기원 <br/><br/>> 구름은 우리 눈에는 보이지 않는 가상의 공간을 뜻한다.

<br/>

### 서버란?

- 온라인에서 사업을 하기 위해서는 기본적으로 온라인상에 공간이 필요하다. <br/>예를 들어, 온라인쇼핑몰을 만들려고 한다면, 오프라인 매장에서 여러 상품들을 배치하고 고객들이 드나들 수 있는 공간이 필요하듯이, 온라인에서도 이러한 공간이 있어야 한다. <br/><br/>> 서버는 이러한 공간을 온라인에 만들어주는 역할을 한다. <br/>> 온라인 상에 상품의 정보를 제공하고, 서비스를 이용하는 고객들이 드나들 수 있는 공간을 제공해주는 것이다.

<br/>

> 서버는 물리적인 형태를 지니고 있다. 따라서 서버를 둘 장소도 필요하고 관리도 필요하다.

<br/>

### 클라우드 서버 장점

#### 1. 유연성이 좋아서 빠른 대응이 가능하다.
- 클라우드 서버는 마우스 클릭 몇번으로 서버를 만들고 삭제할 수 있다. <br/><br/>> 따라서 상황별로 빠른 대응이 가능하다. <br/><br/>

#### 2. 불필요하게 리소스를 낭비할 필요가 없다.
- 초반에는 최소사양으로 서버를 만들었다가, 이후에 필요하면 점점 늘릴 수 있다. <br/><br/>

#### 3. 서버 관리가 용이하다.
- 물리적인 서버는 관리하는 데에 많은 인력과 비용이 필요하다. <br/><br/>> 시스템 엔지니어, 네트워크 엔지니어, 소프트웨어 엔지니어 등 <br/><br/>
- 클라우드 서버를 이용하면 소프트웨어 엔지니어 혼자서도 서버를 관리할 수 있다. <br/><br/>> 즉, 서버 관리에 필요한 자원을 줄일 수 있다.

---

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

# Ruby와 Ruby on Rails
- 애자일(agile)방식에 어울리는 웹 프로그래밍 언어의 대표 주자.

<br/>

- Ruby는 1995년 마츠모토 유키히로라는 일본 사람이 고안한 언어라 일본에서는 Python보다 인기가 많다.
- 스트레스가 없는 쉬운 프로그래밍을 지향하고 우리의 삶을 반영해야 하며, 프로그래밍 언어는 컴퓨터가 아닌, 인간 중심으로 설계되어야 한다. (Ruby 철학)

<br/>

### Ruby on Rails
- Ruby의 웹 프로그래밍 프레임워크

<br/>

**Ruby 자체도 쉽고 간편한 언어이지만, 레일스 덕분에 더욱 사용하기 편리해졌다.**

<br/>

### Ruby의 장점
#### Ruby는 간결함과 생산성이 강조된 언어이다.
- 그렇기 때문에 어느정도 익숙해지면 개발하는 속도가 매우 빠르다.
- 웹사이트를 만들려고 할 때, 가장 빨리 만들 수 있는 언어가 Ruby이다.

<br/>

#### Ruby는 배우기도 매우 쉽기 때문에 누구나 금방 배울 수 있다.

<br/>

#### Ruby의 최대 장점은 확장성과 이식성이 매우 높다.
- 그렇기 때문에 유지보수에 드는 노력 또한 매우 절약해준다.
- Python이나 JavaScript 등 다른 언어로 개발된 라이브러리를 Ruby 위에 구현할 수 있다.

<br/>

### Ruby의 한계점
- 속도가 느리다. [C > Python > Ruby]

<br/>

- 어중간하다. <br/><br/>
        - 다른 언어들의 장점 사이에서 포지셔닝이 잘 되어있지 않다.
        - 아예 대규모 서비스에서 이용하기에도 실행 속도 측면이 걸리기에 이용하기 어렵다.
        - 또한, 협업이 필요한 대형 프로젝트에서는 Ruby가 쓰이기에 부적합하다.

<br/>

### Ruby는 어떤 프로젝트에서 이용하는 것이 좋을까?
- 웹사이트를 쉽고 빠르게 만들 수 있기 때문에 동접자가 많지 않은 간단한 사이트를 구축할 때 이용하는 것이 좋다.

<br/>

- 프로토타입을 만들 때 이용하는 것을 추천.
        - Ruby는 빠르게 무언가를 만들어보는 데에 굉장히 효율적인 언어이기 때문에, 스타트업처럼 빠르게 작은 서비스를 자주 출시해서 소비자의 반응을 봐야 할 때 이용하기 가장 좋은 언어이다.

<br/>

**= 고객중심의 서비스를 보다 빨리 개발하는 데에 목적이 있다면, 굉장히 적합한 환경이다.**

---

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

# API(Application Programming Interface)
- 응용 프로그램 프로그래밍 인터페이스는 응용 프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다.

- 주로 파일 제어, 창 제어, 화상 처리, 문자 제어 등을 위한 인터페이스를 제공한다.

![image](https://user-images.githubusercontent.com/61584142/159638711-8f5302f9-c3b3-4064-9c48-5e79a73b55f3.png)

<br/><br/>

## 인터페이스란?
- '자동차 브레이크 같은 것'  <br/><br/>
        - 사용이 편리하다(사용성)
        - 내부 구현이 숨겨져 있다(정보은닉)

> = 인터페이스는 특정 기술이나 기능에 대한 접점을 제공하여 사용자의 손쉬운 접근을 가능하게 한다.

<br/>

- 자동차 브레이크의 경우 운전자는 브레이크 페달을 밟음으로써 차량 내부의 기능(차량의 속력을 줄임)을 쉽게 제어할 수 있다. 별다른 고민없이 그저 커다란 페달을 살짝 밟기만 하면 된다.

<br/>

- 이러한 인터페이스의 편리한 사용성은 정보은닉에 기인한다. 자동차의 경우, 엔진과 차량을 제어하는 복잡한 기술과 기능을 내부에 숨기고, 운전자에게 드러내지 않는다. 그렇기에 운전자는 내부 정보에 대한 전문 지식 없이도 외부로 드러난 접점(인터페이스)을 이용할 수 있다. <br/><br/>> 인터페이스는 구현과 사용을 분리하고 기능을 추상화하여 사용하기 쉽게 만든다.

<br/><br/>

## API란?
- 사용자 인터페이스는 User와 End-User(최종 사용자)가 일치한다는 특징이 있다. <br/><br/>> UI는 해당 기능을 단순히 이용하기만 하는 최종 사용자를 위해서 설계된다.

<br/>

- 반면, API는 말그대로 애플리케이션을 프로그래밍하는데 쓰이는 인터페이스이다. <br/><br/>> 때문에, API의 사용자가 최종 사용자인 경우는 드물다.

<br/>

- 대부분의 경우 API의 사용자는 개발자이다.


<br/>

- API는 함수, 프로토콜, 도구들의 집합 형태로 제공된다. <br/><br/>> API 역시 인터페이스이기 떄문에 사용자(개발자)는 함수, 프로토콜, 도구들의 집합, 구현에 대해서는 신경쓰지 않아도 된다. <br/>> 개발자가 편리하게 사용할 수 있도록 내부 구현은 감춰져 있다. <br/>> 단지 API가 제공하는 기능을 이용해서 개발자가 원하는 새로운 기능(프로그램)을 만들면 되는 것이다.

<br/>

### 좋은 API는 흔히 쌓기 좋게 만들어 놓은 레고 블록에 비유한다.
- 이 블록을 쌓아서 어떤 결과물을 내어놓을 지는 개발자들과 비즈니스 환경에 달려있다.

<br/><br/>

## API의 역할은?
1. API는 서버와 데이터베이스에 대한 출입구 역할을 한다.
2. API는 애플리케이션과 기기가 원활하게 통신할 수 있도록 한다.
3. API는 모든 접속을 표준화한다.

<br/><br/>

## API 유형은?
### 1. private API - 내부 API로, 회사 개발자가 자체 제품과 서비스를 개선하기 위해 내부적으로 발행한다.
- 제 3자에게 노출되지 않는다.
### 2. public API - 개방형 API로, 모두에게 공개된다.
- 누구나 제한없이 API를 사용할 수 있다.
### 3. partner API - 기업이 데이터 공유에 동의하는 특정인들만 사용가능.
- 비즈니스 관계에서 사용되는 편이며, 종종 파트너 회사 간에 소프트웨어를 통합하기 위해 사용된다.

<br/><br/>

## API 장점?
- API를 사용하면 많은 이점들이 있는데, private API를 이용할 경우, 개발자들이 애플리케이션 코드를 작성하는 방법을 표준화함으로써, 간소화되고 빠른 프로세스 처리를 가능하게 한다.
- 소프트웨어를 통합하고자 할 때는 개발자들 간의 협업을 용이하게 만들어줄 수 있다.
- public API와 partner API를 사용하면, 기업은 타사 데이터를 활용하여 브랜드 인지도를 높일 수 있다. 뿐만 아니라 고객 데이터베이스를 확장하여 전환율까지 높일 수 있다.

---

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

# 임베디드 시스템과 펌웨어
## 임베디드는 내장형 시스템이다?
- Embedded 시스템은 '내장형'시스템 정도로 해석할 수 있다. <br/><br/>> 하지만, 컴퓨터치고 내장되어있지 않은 시스템이 어디있는가? <br/> 기기에 시스템이 외장되어 있다면, 그건 컴퓨터가 아니라 그저 하나의 '도구'일 것이다.

<br/><br/>

### 임베디드는 범용 컴퓨터(PC)의 반대말
- 우리가 흔히 쓰는 Personal Computer는 다양한 목적으로 쓰인다.
- 그러나 임베디드 시스템은 하나의 목적을 가지고 설계된다.

<br/>

### 세탁기를 개발한다고 할 때, 세탁기는 옷을 세탁하는 것이 목적이다.
```
일반 세탁을 할 것인지, 손빨래를 할 것인지, 이불빨래를 할 것인지, 헹굼을 몇 번 할건지, 
물의 온도는 어떻게 할 건지 등은 세탁이라는 목적 아래 구현될 기능이다.

> 사용자는 기능을 선택해 버튼을 누르면 되고, 현재 진행 상태를 LCD나 LED 등을 통해 확인할 수 있다.
```

<br/>

**이처럼 임베디드 시스템은 정해진 용도로만 기능을 제공한다.**

<br/>

### 임베디드 시스템은 일반 PC가 아닌 특수한 목적을 가진 가전제품을 구성하는 시스템이라고 보면 된다.
- 즉, 범용의 반대.

<br/><br/><br/>

## 임베디드 시스템을 구현할 소프트웨어, 펌웨어
- 하드웨어와 소프트웨어 중간에 있는 펌웨어.
- 임베디드 시스템은 하드웨어로만 구현할 수 있지만, 하드웨어와 소프트웨어를 병행해 구현할 수도 있다.
- 하드웨어로만 구현한다면, 직관적인만큼 빠른 속도가 장점이겠지만, 기능을 수정하거나 확장하기 어렵다.

<br/>

**그래서 펌웨어를 통해 소프트웨어를 병행한다면 기능의 수정이나 확장이 쉬워질 것이다.**
- 물론 펌웨어는 하드웨어를 직접 제어하기 때문에 범용 PC의 프로그래밍 개발 방식과는 완전히 다른 새로운 프로그래밍 체계를 익혀야 한다.

---

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

# 클라우드 컴퓨팅
## 클라우드 서비스가 기존의 웹 호스팅과 다른 점으로는 크게 세 가지의 특징을 꼽을 수 있다. 
1. 사용자의 필요에 따라서 뛰어난 컴퓨팅 능력을 얼마든지 이용할 수 있는 것. 
2. 사용자는 언제든지 자기가 사용하고 싶은 만큼 서비스를 이용할 수 있는 것. 
3. 서비스를 제공하는 업체에서 전부 관리하는 것.

<br/><br/>

## 프라이빗 클라우드
- 기업체의 데이터 센터에서 사내의 사용자들에게 서비스를 제공하는 것.
- VMware, OpenStack

<br/><br/>

## 퍼블릭 클라우드
- 인터넷을 통해서 다른 사업자가 클라우드 서비스를 제공하는 것.
- AWS, Microsoft Azure, IBM and Google Cloud platform

<br/><br/>

## 하이브리드 클라우드
- 퍼블릭클라우드와 사내에 설치된 프라이빗클라우드를 결합한 것. <br/><br/>> 퍼블릭 클라우드 인프라가 제공하는 모든 장점을 활용하는 동시에, 사업 운영에 필수적인 워크 로드를 통합적으로 통제하고, 자동화하며, 확장 가능한 환경을 구축하는 것이다.

<br/>

**최근에는 멀티클라우드 모델이나 여러 개의 IaaS 서비스를 이용하는 조직들이 점점 늘어나고 있다.**

<br/><br/><br/>

## 클라우드 컴퓨팅의 장점
### 비용 절감
- 클라우드 인프라를 이용하면 기기들을 구입하고, 유지하기 위해서 큰돈을 쓸 필요가 없기 때문에 비용이 절감된다.  <br/><br/>> 하드웨어나 관련 시설 및 장비에 투자를 할 필요도 없고, 그런 장비들이 들어설 데이터 센터를 짓지 않아도 되기 때문에 기업의 입장에서는 자본지출을 줄일 수 있다. 

<br/>

- 또한, 데이터 센터를 운영하기 위해서 IT 인력들을 고용할 필요도 없는데, 클라우드 서비스에 사용되는 하드웨어들은 모두 서비스 제공 업체가 유지관리를 하기 때문이다. <br/><br/>
- 그뿐만 아니라 클라우드 서비스를 이용하지 않는 시간에 대해서는 비용을 지불하지 않기 때문에 여기에서도 비용 절감 효과가 나타나게 된다.

<br/><br/>

### 이동성
- 클라우드에 정보를 저장한다는 것은 인터넷만 연결된다면 사용자가 언제 어디서든 그 정보에 접속할 수 있다는 것이다. 사용자들이 USB나 외장하드를 들고 다닐 필요도 없고, 여러 장의 CD에 저장하지 않아도 된다.


<br/><br/>

### 피해 복구
- 사용하던 노트북이나 스마트폰이 고장 나는 경우, 가장 먼저 데이터 손실이 걱정될 것이다.  <br/><br/>> 하지만 클라우드에 데이터를 저장해놓았다면, 그 데이터들에 언제든지 접근할 수 있다. 

<br/>

**즉, 클라우드 기반의 서비스를 이용하게 되면 자연재해나 정전과 같은 비상상황에서도 데이터를 빠르게 복구할 수 있다.**

<br/><br/><br/><br/>

## 1. 셀프 프로비저닝(provisioning)
-  최종 사용자들은 어떠한 종류의 워크 로드에 대해서도 컴퓨팅 리소스를 원하는 만큼 활용할 수 있다. <br/><br/>> 최종 사용자는 서버 이용 시간 및 스토리지와 같은 컴퓨팅 리소스를 프로비저닝(할당하고 준비하는 것) 할 수 있다. <br/>>> 원래는 IT 관리자를 고용해서 컴퓨팅 리소스를 관리하고 프로비저닝 하는 업무를 맡겨야 했던 것이지만, 그럴 필요가 없어지는 것이다.

<br/><br/>

## 2. 탄력성
- 기업들은 컴퓨팅 요구가 증가하면 사용량을 늘렸다가 수요가 감소하면 줄일 수 있다.  <br/><br/>> 클라우드를 이용하지 않고 사내에 인프라를 구축한다면 어마어마한 비용 투자가 발생하게 될 텐데, 사업이 잘 된다면 관계없지만 경기가 좋지 않다면 그런 인프라는 잉여로 남을 수 있다.

<br/><br/>

## 3. 사용량에 따른 지불
- 클라우드 서비스에서는 일반적으로 아주 세분화해서 요금을 책정하고 있기 때문에, 사용자들은 자신들이 사용한 리소스와 워크 로드만큼의 비용만 내면 된다.

<br/><br/>

## 4. 워크 로드 회복탄력성
- 클라우드 서비스 업체들은 리소스 리던던시(이중성) 기능을 많이 제공하고 있다. <br/><br/>> 그래서 스토리지를 복원할 수 있고, 기업들의 중요한 워크 로드가 안전하게 운영될 수 있도록 해준다. <br/><br/>>> 세계 각지에서 사업을 하는 경우에는 아주 유용하게 사용할 수 있는 기능이다.

<br/><br/>

## 5. 유연한 마이그레이션
- 조직을 운영하다 보면, 품질개선이나 비용절감, 또는 신규 서비스의 도입 등을 이유로 특정한 워크로드를 다른 시스템으로 옮겨야 하는 경우가 있다. <br/><br/>> 클라우드를 이용한다면, 다른 시스템이나 클라우드 서비스로 마이그레이션을 하는 경우에도 그 작업을 간편하게 처리할 수 있다.

<br/><br/>

## 6. 폭넓은 네트워크 접근성
- 사용자는 인터넷만 연결된다면 어떤 기가라도 관계없이 클라우드 데이터에 접근하거나 데이터를 업로드할 수 있다.

<br/><br/>

## 7. 멀티 테넌시(Multi-tenancy) 및 리소스 풀링(Resource pooling)
- 멀티 테넌시는 여러 명의 고객들이 물리적으로 같은 인프라나 동일한 애플리케이션을 공유하면서도, 자신들의 데이터에 대한 보안과 프라이버시를 보호할 수 있게 해주는 기술을 말한다. <br/><br/>> 그리고 리소스 풀링을 활용하면, 클라우드 사업자가 물리적으로 동일한 리소스로 여러 명의 고객들에게 서비스를 제공할 수 있다. <br/><br/>>> 클라우드 서비스에서는 동시에 수많은 고객들이 요구 사항을 처리할 수 있어야 하기 때문에, 서비스 제공자들은 충분한 크기의 유연한 리소스 풀을 확보하고 있어야만 한다.

<br/><br/><br/><br/>

## 클라우드 컴퓨팅 서비스의 유형
### 1) 서비스로서의 인프라(IaaS)
- AWS와 같은 Iaas 서비스 제공 업체들은 가상의 서버 인스턴스(instance)와 스토리지를 제공하고, 사용자들이 버추얼 머신(가상 기계, VM)에 워크 로드를 마이그레이션 할 수 있는 API도 제공하고 있다. 
- 사용자들은 스토리지 용량을 할당받게 되며, VM과 스토리지를 시작하고 멈추는 것은 물론이고, 원하는 대로 접속하고 설정도 할 수 있다. 
- IaaS 서비스 제공업체들은 소형, 중형, 대형, 메모리 최적화, 컴퓨팅 최적화 인스턴스를 제공하고 있으며, 다양한 워크로드의 요구사항에 맞는 맞춤형 인스턴스도 제공하고 있다.

<br/><br/>

### 2) 서비스로서의 플랫폼(PaaS)
- Paas 모델은 클라우드 제공업체들이 자신들의 인프라에 개발 도구들을 호스팅하는 것이다.
- 사용자들은 인터넷의 API, 웹 포털, 게이트웨이 소프트웨어 등을 통해서 이런 도구들을 이용하게 된다. 
- PaaS는 일반적인 소프트웨어 개발에 사용되기 때문에 PaaS 제공업체들에서는 서비스 내에서 개발이 완료되고 나면 그 소프트웨어를 호스팅하는 경우도 많다. 

<br/>

```
+
많이 이용하는 PaaS서비스로는 세일즈포스(Salesforce)의 라이트닝 플랫폼(Lightning Platform), 
AWS의 일래스틱 빈스토크(Elastic Beantalk), 구글의 앱 엔진(App Engin)등이 있다.
```

<br/><br/>

### 3) 서비스로서의 소프트웨어(SaaS)
- SaaS는 인터넷을 통해서 소프트웨어 애플리케이션을 사용할 수 있도록 하는 모델이다. <br/><br/>> 이런 애플리케이션들은 웹 서비스라고 부르기도 한다. <br/><br/>

- 사용자들은 인터넷에 연결된 컴퓨터나 모바일 기기를 이용해서 어디에서든 SaaS 애플리케이션과 서비스에 접속할 수 있다. 

<br/>

```
+ 
SaaS 모델에서는 사용자들이 애플리케이션 소프트웨어와 데이터베이스에 접근할 수 있는데. 
SaaS 애플리케이션의 대표적인 예로는 생산성 및 이메일 서비스인 마이크로소프트의 오피스 365를 들 수 있다.
```

---

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

## Container
- 컨테이너는 애플리케이션을 실제 구동 환경으로부터 추상화할 수 있는 논리 패키징 메커니즘을 제공한다. <br/><br/>
        - 애플리케이션과 애플리케이션이 동작하기 위해 필요한 라이브러리나 모듈 등을 묶어준다.
        - 이렇게 묶은 것을 컨테이너라고 부른다.

<br/>

- 애플리케이션과 애플리케이션을 구동하는 관경을 컨테이너 박스에 넣고 하나로 만든 것이라고 생각하면 된다.
- 컨테이너를 옮기면 안에 넣었던 소프트웨어들이 모두 함께 움직이기 때문에 하나하나 관리할 필요가 없게 되었다.

<br/>

- OS는 생각보다 더 다양한데, 운영체제와 배포판 등에 따라 기술 및 정책도 다르며, 이에 따라 명령어도 조금씩 달라진다. <br/><br/>
        - 이렇다 보니 새로 만든 애플리케이션을 실제 작업한 노트북에서 테스트 환경이나 실 서비스 운영환경으로 옮길 때마다 온갖 이상한 오류를 직면하게 된다.
        - 또한, 하나의 서버에 여러 개의 애플리케이션을 설치하는 것도 문제였다.
        - 서로 사용하는 라이브러리의 버전이 다르면 충돌이 발생하는 문제가 생겼다.

<br/>

**그래서 소프트웨어를 다른 컴퓨팅 환경으로 이동하면서도 안정적으로 실행하는 방법이 없을까? 라는 고민이 생겼고, 그렇게 탄생한 기술이 '컨테이너'이다.**

<br/><br/>

### 이러한 컨테이너 기술이 있기 전에는 VM 기술이 있었다.
- VM은 기존 환경 위에 가상화 기술을 이용해 Guest OS를 새로 설치한다. > OS 위에 OS를 설치하는 셈이다.
- 여러 OS를 동시에 구동해야 하기 때문에 VM을 이용하기 위해 만드는 시간도 오래걸리며, 성능도 낮아지게 된다.

<br/>

- 이에 비해 컨테이너는 OS가 아닌 묶었던 애플리케이션만 관리하며, 필요한 만큼의 OS 자원을 컨테이너에 할당할 수 있다.
- 따라서 성능 저하의 문제가 적어지고, 위에서 말한 문제점인 여러 개의 프로그램을 설치해도 컨테이너끼리 격리된 상황이기 때문에 서로 충돌로 인한 문제가 해결된다.

<br/>

- 컨테이너를 다른 서버로 옮기면, 옮긴 서버에서 컨테이너 안에 있는 환경 그대로 사용하면 되기 때문에 일관성있는 환경을 제공해준다.

<br/><br/>

### ex) 페이스북과 같이 거대한 서비스가 있다고 가정해보자.
- 이런 서비스는 사용자들이 매우 많기 때문에 서버 하나로는 처리가 불가능하다. <br/>> 따라서 여러 서버를 사용해야 하는데, 서버를 늘릴 때마다 매번 환경을 구축하는 것도 큰일이지만, 컨테이너를 이용한다면 컨테이너만 복사하면 해당 환경이 구축되기 때문에 관리의 비용이 축소되고, OS 자원도 필요한 만큼만 할당할 수 있다. <br/>> 덕분에 사용자가 많은 시간에는 늘리고, 적은 시간에는 줄일 수 있다.

<br/>

**탁월한 비용 절감 효과를 얻게 되는 것이다.**

<br/><br/><br/><br/>

## Docker
- 도커는 리눅스의 응용 프로그램들을 소프트웨어 컨테이너 안에 배치시키는 일을 자동화하기 위해 시작된 오픈 소스 프로젝트이다. <br/><br/>> 애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼이다.

<br/>

- 컨테이너를 이용해 소프트웨어를 컨테이너라는 표준화된 유닛으로 알아서 패키징해주며, 환경에 구애받지 않고, 애플리케이션을 신속하게 배포 및 확장할 수 있다. <br/><br/>> 따라서, 코드가 문제없이 실행될 것임을 확신할 수 있게 해준다. <br/>>> 컨테이너들을 쉽게 관리하고, 신속하게 배포 및 확장을 할 수 있게 해주는 것이다.

<br/>

![image](https://user-images.githubusercontent.com/61584142/159644983-6d625197-9314-4499-a983-6a4718609892.png)

<br/><br/>

### 도커 이미지란?
- 도커에는 컨테이너뿐만 아니라 도커 이미지라는 또 하나의 중요한 개념이 있다.
- 이미지는 컨테이너를 생성하기 위해 필요한 설계도를 말한다.
- 도커는 이미지를 보고 컨테이너를 생성하게 된다.
- 도커가 찍어놓은(build) 사진(Image)을 인화(실행)하면 컨테이너가 나오는 것이다.
- 사진은 여러 번 인화할 수 있고, 똑같은 사진이 인화되는 것처럼 다른 서버에서도 도커가 이미지를 이용해 컨테이너를 만들면 같은 환경을 구축할 수 있는 것이다.

<br/>

- 도커 이미지는 Docker File로 만들 수 있는데, 도커 파일은 도커가 어떻게 이미지를 만들지 이해하도록 적은 파일이다.
- 도커 파일에 사진(Image)을 어떻게 찍을지 적어놓으면 도커가 그것을 읽고, 이미지를 생성하게 된다. <br/><br/>> 이렇게 생성한 이미지를 저장해 놓을 수 있는 공간도 있는데, 이것을  Docker Hub라고 한다. <br/><br/>>> Docker Hub를 이용해 이미지를 공유할 수 있고, 인터넷만 연결되어 있으면 어디에서는 이미지를 다운로드할 수 있게 되었다.

<br/><br/><br/><br/>

## 우주인터넷
- 우주선, 위성, 탐사로봇 등을 하나의 인터넷 통신망으로 연결하는 것

<br/>

- 현재는 지구의 통제센터와 위성 간의 일대일 통신만 가능하지만 우주 인터넷을 활용하면 위성끼리의 통신이 가능해져서 통신 속도가 빨라진다. <br/><br/>> 광케이블 없이도 빠르게 인터넷과 이동통신 서비스를 이용할 수 있게 되는 것이다.

<br/><br/>

## 우주 인터넷에 주력하고 있는 유명 ICT 기업
### 구글 알파벳
- 구글의 모회사 알파벳은 지구촌 오지에 인터넷 환경을 제공하는 '프로젝트 룬(Project Loon)'을 상용화할 예정이디. 
- 아프리카 케냐에서 처음으로 이동통신 서비스를 시작하는 것인데, 룬 프로젝트의 경우, 지구 상공 20KM의 성층권에 통신중계기 등을 갖춘 초압 열기구를 띄우는 ‘기구(氣球) 인터넷’이라고 한다.

<br/><br/>

### 스페이스 X
-스페이스 X는 테슬라의 대표인 일론 머스크가 설립한 민간 우주기업으로, 인공위성으로 데이터 통신용 그물을 만드는 ‘스타링크(Starlink)’ 프로젝트를 진행하고 있다. 
- 이를 위해서는 약 2000개의 인공위성이 사용되는데, 1차적으로 4409개의 인공위성을 발사해서 거대한 위성 인터넷망을 구축한 후에 그보다 아래 궤도에 다시 7518개의 위성을 쏘아 초고속 인터넷을 구현한다. 

<br/><br/>

### 스웜 테크놀로지스
- 스웜 테크놀로지스는 미국의 벤처 기업으로 원격진료와 농작물 관리에 필요한 사물인터넷 서비스를 제공할 예정이라고한다. 

---

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

# ERP
- 비즈니스를 성공으로 이끄는 가장 중요한 두 가지의 핵심적인 요소는 효율성과 수익성이다.<br/><br/>> 불필요한 비용은 최소한으로 줄이면서 이익은 최대한으로 끌어올려야만 한다.

<br/>

- 효율성과 수익성을 달성하기 위해서는 사업의 진행 상황을 보다 정교하게 자동화해서 살펴보고, 평가할 수 있는 비즈니스 관리 체계를 갖추어야만 한다. <br/><br/>> 이러한 관리 방식은 전체적인 의사결정 과정을 개선하는 데에도 도움이 된다. 

<br/>

**ERP는 기업이 이러한 매니지먼트 업무를 효율적으로 수행할 수 있는 비즈니스 관리 소프트웨어를 말한다.**

<br/><br/><br/>

## ERP의 다른 기능
### 회계업무
- 구매 주문, 비용, 매출 리포트, 급여 등 재무와 관련한 모든 보고서를 하나의 인터페이스로 관리할 수 있어야 한다. <br/><br/>> 이렇게 된다면, 현금 흐름과 수익을 보다 쉽게 모니터링할 수 있고, 자금을 보다 효율적으로 사용하면서 소모성 비용을 줄일 수 있는 방법을 찾을 수 있다.

<br/><br/>

### 재고관리
- 비즈니스에서 물류와 재고 업무가 중요하다면, 상품을 잘 추적하고 관리할 수 있도록 ERP 소프트웨어가 관련된 모든 업무를 하나로 통합해 줘야 한다.  <br/><br/>> 따라서 재고가 얼마나 있는지, 어떤 물품이 배송될 예정인지, 공급업체에서는 어떤 상품들이 배송되어 입고될 예정인지에 대해서 쉽게 파악할 수 있다.

<br/><br/>

### 인사관리
- ERP 프로그램의 인사관리(HR) 모듈에는 급여, 채용, 업무평가, 근태관리, 일정관리 등 직원들을 관리하는데 필요한 모든 기능들이 포함되어 있어야 한다. <br/><br/>> 모든 직원들에 대한 관리와 커뮤니케이션을 한 군데 통합할 수 있는 원스톱 시스템이어야 한다.

<br/><br/>

### 고객관계관리(CRM) 및 마케팅
- 마케팅 전략이 얼마나 효율적으로 이루어지고 있는지를 파악하는 것은 매우 중요하다. <br/><br/>> 이메일 마케팅 홍보, 소셜 미디어 운영, 설문조사, 전화를 통한 고객만족도 조사 등 어떤 방식의 마케팅 전략이 가장 효과적인지에 대해서도 알고 있어야 한다. <br/><br/>>> CRM 모듈에서는 효과적인 방식과 그렇지 않은 방식을 알 수 있어야 하고, 추가적인 수익으로 이어지는 마케팅 전략을 수립하는 데 도움을 주어야 한다.

<br/><br/>

### 프로젝트 관리
- ERP 프로그램이 갖추고 있어야 하는 또 하나의 중요한 기능은 프로젝트 관리이다. <br/><br/>> 프로젝트 관리 도구는 조직 전체에 걸쳐서 내부적인 계획 수립과 프로젝트 실행을 위해 효율적으로 커뮤니케이션할 수 있는 기능을 제공한다. <br/><br/>>> 이러한 기능을 갖춘다면, 모든 이해관계자와 직원들이 회사의 현재 목표와 방향에 대해 모두 같은 정보를 공유할 수 있기 때문에 조직의 효율성이 높아지게 된다.
