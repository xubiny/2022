# ComputerScience
[1] 텍스트와 특수문자를 조합해서 사진과 그림을 표현한 것. 
= 아스키 아트(ASCII Art)

[2] 최소화되고 모듈화된 소프트웨어 개발 방식을 위한 문화적 규범이자 철학적 접근 방식. 
= Unix 철학

[3] 명령줄 또는 명령어 인터페이스는 텍스트 터미널을 통해 사용자와 컴퓨터가 상호 작용하는 방식을 말한다. 
= Command-line

[4] 취미 활동으로 즐기는 아마추어 무선 통신. 
= HAM 라디오

[5] 사용자 인터페이스 개발을 위해 페이스북에서 만들고 공개한 오픈소스 자바스크립트 라이브러리. 
= React

[6] 변수를 정의한 클래스 외부에서도 접근할 수 있는 변수. 
= public 변수

[7] 외부에 노출되지 않고 정의한 클래스 내부에서만 접근할 수 있는 변수. 
= private 변수

[8] 아틀라시안(Atlassian)이 개발한 이슈추적 소프트 웨어로 버그 추적, 이슈 추적, 프로젝트 관리 기능 등을 제공한다. 
= Jira

[9] 객체 지향 프로그래밍의 핵심인 클래스와 그 서브클래스 간의 계층 구조를 도식으로 나타낸 것. 
= Class Hierarchy

[10] 프로그램을 작성할 때 각 모듈이 작동하는 논리를 표현하기 위한 언어이다. 특정 프로그래밍 언어의 문법이 아닌 알고리즘 그 자체이 집중할 수 있기 때문에 코딩 면접에서 많이 사용된다. 
= Pseudo code

---

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

## RESTful API
- REST API(RESTful API, 레스트풀 API)란 REST 아키텍처의 제약 조건을 준수하는 애플리케이션 프로그래밍 인터페이스를 뜻한다. <br/>REST는 Representational State Transfer의 줄임말이다. <br/><br/>

- API는 애플리케이션 소프트웨어를 구축하고 통합하는 정의 및 프로토콜 세트이다. <br/>때때로 API는 정보 제공자와 정보 사용자 간의 계약으로 지칭되며 소비자에게 필요한 콘텐츠(호출)와 생산자에게 필요한 콘텐츠(응답)를 구성한다. <br/><br/>

- 예를 들어 날씨 서비스용 API에서는 사용자는 우편번호를 제공하고, 생산자는 두 부분(첫 번째는 최고 기온, 두 번째는 최저 기온)으로 구성된 응답으로 답하도록 지정할 수 있다. <br/> 즉, 컴퓨터나 시스템과 상호 작용하여 정보를 검색하거나 기능을 수행하고자 할 때 API는 사용자가 원하는 것을 시스템에 전달할 수 있게 지원하여 시스템이 이 요청을 이해하고 이행하도록 할 수 있다. <br/><br/>

- API를 사용자 또는 클라이언트, 그리고 사용자와 클라이언트가 얻으려 하는 리소스 사이의 조정자로 생각하면 된다. <br/>API는 조직이 보안 및 제어를 유지관리(누가 무엇에 액세스할 수 있는지 결정)하면서 리소스와 정보를 공유할 수 있는 방법이기도 하다. <br/>API의 또 다른 이점은 리소스 검색 방법 또는 리소스의 출처에 대한 지식 없이도 사용이 가능하다는 점이다. <br/><br/>

- REST는 프로토콜이나 표준이 아닌 아키텍처 원칙 세트이다. <br/>API 개발자는 REST를 다양한 방식으로 구현할 수 있다. <br/>
    - RESTful API를 통해 요청이 수행될 때 RESTful API는 리소스 상태에 대한 표현을 요청자에게 전송한다. 
    - 이 정보 또는 표현은 HTTP: JSON(Javascript Object Notation), HTML, XLT 또는 일반 텍스트를 통해 몇 가지 형식으로 전송된다. 
    - JSON은 그 이름에도 불구하고 사용 언어와 상관이 없을 뿐 아니라 인간과 머신이 모두 읽을 수 있기 때문에 가장 널리 사용된다. <br/><br/>

### API가 RESTful로 간주되려면 다음 기준을 따라야 한다.
- 클라이언트, 서버 및 리소스로 구성되었으며 요청이 HTTP를 통해 관리되는 클라이언트-서버 아키텍처
- 스테이트리스(stateless) 클라이언트-서버 커뮤니케이션: 요청 간에 클라이언트 정보가 저장되지 않으며, 각 요청이 분리되어 있고 서로 연결되어 있지 않음
- 클라이언트-서버 상호 작용을 간소화하는 캐시 가능 데이터 

<br/>

### 정보가 표준 형식으로 전송되도록 하기 위한 구성 요소 간 통합 인터페이스. 여기에 필요한 것은 다음과 같다.
- 요청된 리소스가 식별 가능하며 클라이언트에 전송된 표현과 분리되어야 한다.
- 수신한 표현을 통해 클라이언트가 리소스를 조작할 수 있어야 한다(이렇게 할 수 있는 충분한 정보가 표현에 포함되어 있기 때문).
- 클라이언트에 반환되는 자기 기술적(self-descriptive) 메시지에 클라이언트가 정보를 어떻게 처리해야 할지 설명하는 정보가 충분히 포함되어야 한다.
- 하이퍼미디어: 클라이언트가 리소스에 액세스한 후 하이퍼링크를 사용해 현재 수행 가능한 기타 모든 작업을 찾을 수 있어야 한다.

<br/>

- 요청된 정보를 검색하는 데 관련된 서버(보안, 로드 밸런싱 등을 담당)의 각 유형을 클라이언트가 볼 수 없는 계층 구조로 체계화하는 계층화된 시스템. 
- 코드 온디맨드(선택 사항): 요청을 받으면 서버에서 클라이언트로 실행 가능한 코드를 전송하여 클라이언트 기능을 확장할 수 있는 기능. <br/><br/>
    - 이처럼 REST API는 따라야 할 기준이 있지만, 속도를 저하시키고 더 무겁게 만드는 XML 메시징, 빌트인 보안 및 트랜잭션 컴플라이언스처럼 특정 요구 사항이 있는 SOAP(Simple Object Access Protocol) 등의 규정된 프로토콜보다 사용하기 쉬운 것으로 간주된다. 
    - 이와 대조적으로 REST는 필요에 따라 구현할 수 있는 일련의 지침으로, 이를 통해 REST API는 더 빨라지고 경량화되며 사물인터넷(IoT) 및 모바일 앱 개발에 가장 적합한 API가 된다. 

<br/><br/><br/><br/><br/><br/><br/><br/>

## Flask
- Micro Web Framework -> 간단한 웹 사이트, 혹은 간단한 API 서버를 만드는 데에 특화 되어있는 Python Web Framework 이다.
- 파이썬 웹 어플리케이션을 만드는 Framwork > Django보다 더 간단하게 만들 수 있음
- 매우 심플하고 가벼운 느낌을 가지는 프레임 워크 > 가볍지만 핵심적인 내용과 기능을 가지고 있음 <br/><br/>

```
from flask import Flask
app = Flask(__name__)  # Flask 객체 생성
 
@app.route('/')
def index():
    return '<h1>Hello World!</h1>'
 
if __name__ == "__main__":  # 모듈이 실행 됨을 알림
    app.run(debug=True, port=5000)  # 서버 실행, 파라미터로 debug 여부, port 설정 가능
```

<br/><br/>

## BluePrint
- Flask는 application component를 만들거나, applicaion 안팎으로 공통적인 패턴을 지원하는 목적으로 블루프린트라는 컨셉을 사용한다. 
- Blueprint는 큰 application을 단순화시키는 역할을 하고, Flask extension(확장 프로그램, 라이브러리 등) 등록을 위한 중심 수단으로도 쓰인다. <br/><br/>

- 플라스크는 django와 달리 url들을 파일 단위에서 따로 관리하지 않고, controller의 endpoint 함수에 데코레이터를 붙여서 관리한다.
- 라우트함수(@app.route로 매핑되는 함수)들은 기능이 필요할때마다 계속 추가되어야 하기 때문에, create_app 함수내에 함수가 많을 경우 번거로워질 수 있다. <br/><br/>

#### 이런 상황에서 블루프린트(Blueprint)를 이용하면 라우트 함수들을 보다 구조적으로 관리할 수 있게 된다.

<br/>

- 블루프린트의 기본 개념은 어플리케이션에 블루프린트이 등록될 때 실행할 동작을 기록한다는 것이다. 플라스크는 요청을 보내고 하나의 끝점에서 다른 곳으로 URL을 생성할 때 뷰 함수와 블루프린트의 연관을 맺는다. <br/><br/>
    - module 을 url 에 등록하기 쉽게 해주는 방법이다.

<br/><br/><br/><br/><br/><br/><br/><br/>

## SOCKET
- 소켓은 프로세스가 드넓은 네트워크 세계로 데이터를 내보내거나 혹은 그 세계로부터 데이터를 받기 위한 실제적인 창구 역할을 한다. <br/>그러므로 프로세스가 데이터를 보내거나 받기 위해서는 반드시 소켓을 열어서 소켓에 데이터를 써보내거나 소켓으로부터 데이터를 읽어들여야 한다. <br/><br/>
- 소켓은 떨어져 있는 두 호스트를 연결해주는 도구로써 인터페이스의 역할을 하는데 데이터를 주고받을 수 있는 구조체로 소켓을 통해 데이터 통로가 만들어진다.
    - 이러한 소켓은 역할에 따라 서버소켓, 클라이언트소켓으로 구분된다.

<br/><br/>

## Server
- 클라이언트와 소켓의 연결 요청을 대기하고, 연결 요청이 오면 클라이언트 소켓을 생성하여 통신이 가능하게 한다. <br/><br/>
```
1. socket() 함수를 이용하여 소켓 생성
2. bind() 함수로 ip와 port 번호를 설정
3. listen() 함수로 클라이언트의 접근 요청에 수신 대기열을 만들어 몇 개의 클라이언트를 대기시킬지 결정
4. accept() 함수를 사용하여 클라이언트와의 연결을 기다림
```

<br/><br/>

## Client
- 실제로 데이터 송수신이 일어나는 것은 클라이언트 소켓이다. <br/><br/>
```
1. socket() 함수로 가장 먼저 소켓을 연다.
2. connect() 함수를 이용하여 통신할 서버의 설정된 ip와 port 번호에 통신을 시도
3. 통신을 시도시, 서버가 accept() 함수를 이용하여 클라이언트의 socket descriptor를 반환
4. 이를 통해 클라이언트와 서버가 서로 read(), write()를 하며 통신 (이 과정이 반복)
```

<br/><br/>

## SOCKET 통신
- Server와 Client가 특정 Port를 통해 실시간으로 양방향 통신을 하는 방식 <br/><br/>

    - Server와 Client가 계속 연결을 유지하는 양방향 통신
    - Server와 Client가 실시간으로 데이터를 주고받는 상황이 필요한 경우에 사용된다.
    - 실시간 동영상 Streaming이나 온라인 게임 등과 같은 경우에 자주 사용된다.

<br/><br/>

## HTTP 통신
- Client의 요청(Request)이 있을 때만 서버가 응답(Response)하여 해당 정보를 전송하고 곧바로 연결을 종료하는 방식 <br/><br/>

    - Client가 요청을 보내는 경우에만 Server가 응답하는 단방향 통신
    - Server로부터 응답을 받은 후에는 연결이 바로 종료된다.
    - 실시간 연결이 아니고, 필요한 경우에만 Server로 요청을 보내는 상황에 유용하다.
    - 요청을 보내 Server의 응답을 기다리는 어플리케이션의 개발에 주로 사용된다.

<br/><br/><br/><br/><br/><br/><br/><br/>

## TCP
- 양방향으로 바이트 스트림을 전송, 연결 지향성
- 오류 수정. 전송처리, 흐름제어 보장
- 송신된 순서에 따라 중복되지 않게 데이터를 수신 -> 오버헤드 발생
- 소량의 데이터보다 대량의 데이터 전송에 적합 -> TCP를 사용

<br/><br/>

## UDP
- 비연결형소켓
- 데이터의 크기에 제한이 있음
- 확실하게 전달이 보장되지 않음. -> 데이터가 손실되어도 오류가 발생하지 않음
- 실시간 멀티미디어 정보를 처리하기 위해 주로 사용 ex)전화

<br/><br/><br/><br/><br/><br/><br/><br/>

## 일반적인 함수
- 일반적인 함수는 파라미터를 받아 함수 내부로 진입하고 결과값을 돌려줄 때는 return키워드를 사용해 호출자에게 값을 돌려 주는 구조로 되어 있다. 
- 또는 파라미터 자체를 Call by reference로 전달(포인터 전달)해 호출자가 참조하는 값 자체를 함수 내부에서 변경하기도 한다. <br/><br/>> 이 경우 리턴값은 없거나 에러 여부를 전달하는 데 쓰이게 된다.

<br/>

<pre><code>// 일반적인 함수
function sum(num1, num2){
    return num1+num2;
}
 
// 함수 호출
sum(1, 2);</code></pre>

<br/><br/>

## Callback Function
- 콜백 함수는 함수로써 다른 함수에 전달되며, 이는 외부 함수 내에서 일종의 루틴 또는 동작을 완성하기 위해 호출된다. <br/><br/>> 어떤 이벤트가 발생한 후, 수행될 함수를 의미

<br/>

<pre><code>function greeting(name){
    alert('안녕하세요. ' + name);
}
 
function processUserInput(callback){
    var name = prompt('이름을 입력해 주세요.');
    callback(name);
}
 
processUserInput(greeting);</code></pre>

<br/><br/><br/><br/><br/><br/><br/><br/>

## Process
- 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
- 운영체제로부터 시스템 자원을 할당받는 작업의 단위 <br/><br/>> 즉, 동적인 개념으로는 실행된 프로그램을 의미한다.

<br/><br/>

## Thread
- 스레드(thread)란 프로세스(process) 내에서 실제로 작업을 수행하는 주체를 의미한다.
- 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행한다.
- 또한, 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스(multi-threaded process)라고 한다.

<br/><br/><br/><br/><br/><br/><br/><br/>

## HTTP
- 컴퓨터들끼리 HTML파일을 주고받을 수 있도록 하는 소통방식 또는 약속
- HTTP는 곧 컴퓨터사이의 소통이라 했다. 이때 요청과 응답으로 이루어져있는 것이 핵심이다.
- 각각의 HTTP 통신(요청/응답)은 독립적이다. 따라서 과거의 통신(요청/응답)에 대한 내용을 전혀 알지 못한다. <br/><br/>> 웹에서는 브라우저와 서버 간에 데이터를 주고받기 위한 방식으로 HTTP 프로토콜을 사용하고 있다. <br/>> ex) 한 사이트에 로그인을 했을 때 한번 받은 로그인정보는 다음 통신에서 지워지는 것이다. 

<br/>

### 그렇다면 어떻게 로그인한 상태가 지속되는 걸까?
- 우리가 로그인을 하면 서버에서 '토큰(token)'이란 것을 발급해준다. 이것을 로컬스토리지나 브라우저에 저장한 후, 다음 통신 때 서버에 토큰을 같이 넘겨주는 것이다. <br/><br/>> 이러한 로그인 정보와같이 여러번의 통신과정에서 '연속된 데이터 처리'가 필요한경우를 위해 토큰이나 쿠키 로컬스토리지 같은 기술이 만들어졌다.

<br/><br/>

## Request
- 웹 브라우저(클라이언트)를 통해 서버에 요청하는것 -> Request <br/><br/>
    - 웹 브라우저에서 서버에 요청하는 정보가 Request객체에 담기게 된다.
    - JSP컨테이너가 서블릿으로 변환될때 자동으로 생성된다.

<br/>

### Request관련 method
- String getParameter(String name) : name에 해당하는 요청한 파라미터 값을 리턴받는다.
- HttpSession getSession() : Session객체를 리턴받는다.
- StringBuffer getRequestURL() : 요청 URL값을 리턴받는다.

<br/><br/>

## Response
- 서버에서 웹 브라우저(클라이언트)에 응답하는 것 -> Response <br/><br/>
    - 클라이언트의 요청에 응답하는것이 Response이고, 응답의 정보가 Response객체에 담기게 된다.
    - Request는 헤더의 값을 읽어오는 반면, Response는 헤더에 값을 추가하고, 리다이렉트 하는 것

<br/>

### Response 관련 method
- void addCookie(Cookie cookie) : cookie를 추가한다.
- void sendRedirect(String URL) : 해당 URL로 리다이렉트한다.

<br/><br/>

## HTTP Status Code
### 2xx 
- 성공 (200번대의 상태 코드는 대부분 성공을 의미) <br/><br/>
    - 200 : GET 요청에 대한 성공
    - 204 : No Content. 성공했으나 응답 본문에 데이터가 없음
    - 205 : Reset Content. 성공했으나 클라이언트의 화면을 새로 고침하도록 권고
    - 206 : Partial Conent. 성공했으나 일부 범위의 데이터만 반환

<br/>

### 3xx 
- 리다이렉션 (300번대의 상태 코드는 대부분 클라이언트가 이전 주소로 데이터를 요청하여 서버에서 새 URL로 리다이렉트를 유도하는 경우) <br/><br/>
    - 301 : Moved Permanently, 요청한 자원이 새 URL에 존재
    - 303 : See Other, 요청한 자원이 임시 주소에 존재
    - 304 : Not Modified, 요청한 자원이 변경되지 않았으므로 클라이언트에서 캐싱된 자원을 사용하도록 권고. ETag와 같은 정보를 활용하여 변경 여부를 확인

<br/>

### 4xx 
- 클라이언트 에러(400번대 상태 코드는 대부분 클라이언트의 코드가 잘못된 경우/유효하지 않은 자원을 요청했거나 요청이나 권한이 잘못된 경우 발생/ 가장 익숙한 상태 코드는 404 코드. 요청한 자원이 서버에 없다는 의미) <br/><br/>
    - 400 : Bad Request, 잘못된 요청
    - 401 : Unauthorized, 권한 없이 요청. Authorization 헤더가 잘못된 경우
    - 403 : Forbidden, 서버에서 해당 자원에 대해 접근 금지
    - 405 : Method Not Allowed, 허용되지 않은 요청 메서드
    - 409 : Conflict, 최신 자원이 아닌데 업데이트하는 경우. ex) 파일 업로드 시 버전 충돌

<br/>

### 5xx 
- 서버 에러 (500번대 상태 코드는 서버 쪽에서 오류가 난 경우) <br/><br/>
    - 501 : Not Implemented, 요청한 동작에 대해 서버가 수행할 수 없는 경우
    - 503 : Service Unavailable, 서버가 과부하 또는 유지 보수로 내려간 경우

<br/><br/><br/><br/><br/><br/><br/><br/>

## GET(가져오다)
- GET : 존재하는 자원에 대한 요청 <br/><br/>
    - 서버에게 resource를 보내달라고 요청한다. 
    - 서버(혹은 DB)의 resource는 클라이언트로 전달만 될 뿐 변경되지 않는다.

<br/><br/>

## POST(게시하다)
- POST : 새로운 자원을 생성 <br/><br/>
    - 서버에게 resource를 보내면서 생성해 달라고 요청한다. <br/>> 예를들어 회원가입을 하면 DB에 새로운 회원정보가 등록되고, 사진을 업로드 하면 그 사진이 웹사이트에 등록된다.

<br/><br/>

## DELETE(지우다)
- DELETE : 존재하는 자원에 대한 삭제 <br/><br/>
    - 서버에게 resource의 삭제를 요청한다.

<br/><br/>

## PUT(집어넣다)
- PUT : 존재하는 자원에 대한 변경 <br/><br/>
    - 서버에게 resource의 업데이트 하거나 resource가 없다면 새로운 resource를 생성해 달라고 요청한다. 회원정보 수정 등에 사용된다.
    - PUT은 PATCH와 비교해서 전체 데이터를 교체하는 차이점이 있다. <br/><br/>
``` 
가령 user data의 구조가 user._id, user.firstName, user.lastName, user.age라고 한다면, 
회원정보 수정시 PUT은 _id를 찾아 age만 업데이트하더라도 항상 모든 필드값을 가져와서 모든 필드를 항상 새로운 값으로 교체한다.
```

<br/><br/>

## PATCH
- 서버에게resource의 업데이트를 요청합니다. 회원정보 수정 등에 사용된다.
- PATCH는 PUT과 비교해서 부분 데이터를 업데이트하는 차이점이 있다. <br/><br/>

```
가령 user data의 구조가 user._id, user.firstName, user.lastName, user.age라고 한다면, 
회원정보 수정시 PATCH는 _id를 찾아 age만 업데이트할때 _id와 age만 받아와서해당 부분을 업데이트 한다.
```

<br/><br/><br/><br/><br/><br/><br/><br/>

## 지역 변수(local variable)
- 함수 내부에서 선언된 변수는 오직 함수 내부에서만 접근할 수 있다.
- 또한, 함수 내부에서 선언된 변수는 함수의 호출이 종료되면 메모리에서 제거된다.

<br/><br/>

## 전역 변수(global variable)
- 함수 밖에서 선언된 변수는 함수 밖에서만 바로 접근할 수 있다.
- 함수 밖에서 선언된 변수를 함수 내부에서 접근하고자 할 때는 global 키워드를 함께 사용해야 한다.

<br/><br/>

## 정적 변수(static variable)
- 함수 내부에서 static 키워드로 선언한 변수를 의미한다. 
- 함수 내부에서 선언된 정적 변수는 함수의 호출이 종료되더라도 메모리상에서 사라지지 않는다. <br/><br/>> 하지만 지역 변수처럼 해당 함수 내부에서만 접근할 수 있다.

<br/><br/><br/><br/><br/><br/><br/><br/>

## hungarian case
- Microsoft 사의 한 헝가리인 개발자가 사용하던 변수명에서 유래된 변수명
- 변수의 자료형을 변수명의 접두어로 붙이는 방식으로 간단하게 변수명만 보고 자료형을 인식할 수 있는 방식
- 옛날에는 효율성을 끌어냈는데, 가독성이 떨어지고 최근에는 개발도구의 발전으로 많이 쓰이지 않는 방식

<br/>

    - private int intNum; // int형 변수, intNum 또는 iNum으로도 사용 
    - private String strName; // String형 변수, strName 또는 sName으로도 사용 
    - private boolean boolNext; // boolean형 변수, boolNext 또는 bNext으로도 사용

<br/><br/>

## snake_case
- snake_case란 단어가 합쳐진 부분마다 중간에 언더라인을 붙여 주는 방법
- 일반적으로는 언더라인을 사용하나, 언더라인 대신 하이픈(-)을 써도 snake-case라고 할 수 있다. <br/><br/>
`[ ex) Night_Of_Knights, noumi_kudryavka_anatolyevna_strugatskaya,… ]`

<br/>

### Train_Case = Snake_Case에서, 각 단어의 맨 앞글자를 대문자로 표기하는 것
`[ ex) Visual_Studio_Community_2013, Not_Upper_Camel_case, … ]`

<br/>

### spinal_case = snake_case에서, 각 단어의 맨 앞글자를 소문자로 표기하는 것
`[ ex) visual_studio_community_2013, not_lower_camel_case, … ]`

<br/><br/>

## CamelCase
- CamelCase란 단어가 합쳐진 부분마다 맨 처음 글자를 대문자로 표기하는 방법.
- 두 개 이상의 단어가 모인 합성어에서 사용된다.

<br/>

### lowerCamelCase = camelCase에서, 맨 앞글자를 소문자로 표기하는 것
- 나머지 뒤에 따라붙는 단어들의 앞글자는 모두 대문자로 표기 <br/><br/>
`[ ex) namuWikiReflecBeatComponent, beatMania,… ]`

<br/>

### UpperCamelCase (=PascalCase) = CamelCase에서, 맨 앞글자를 대문자로 표기하는 것
- 나머지 뒤에 따라붙는 단어들의 앞글자는 모두 대문자로 표기 <br/><br/>
`[ ex) NamuWikiReflecBeatComponent, BeatMania,… ]`

<br/><br/>

## 기본적인 변수명 네이밍 컨벤션
- 컴파일러에서 제한하는 변수 명명 규칙 <br/><br/>

    - 대소문자는 구분되며 길이의 제한은 없다.
    - 예약어를 사용해서는 안 된다.
    - 숫자로 시작하면 안 된다.
    - 특수문자는 _ 와 $ 만 허용한다.

<br/>

1. 변수는 첫 글자의 소문자로 시작하는 명사로 짓는다.
2. 여러 단어로 이루어진 이름인 경우 각 단어의 첫 글자를 대문자로 한다. (카멜 표기법 사용)

<br/><br/><br/><br/><br/><br/><br/><br/>

## programming flag
- 프로그래밍에서는 ‘상태를 기록하고 처리 흐름을 제어하기 위한 boolean 변수’를 의미 <br/><br/>> True or False

<br/><br/><br/><br/><br/><br/><br/><br/>

## interrupt
- 마이크로프로세서(CPU)가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치에 예외상황이 발생하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말한다.

<br/>

### 내부 인터럽트
- 하드웨어 고장(Hardware Interrupt) 
    - 컴퓨터 고장
    - 데이터 전달 과정에서의 비트 오류
    - 전원이 나간 경우 <br/>

- 실행할 수 없는 명령어 : 기억장치에서 인출한 명령어의 비트 패턴이 정의되어 있지 않은 경우 
- 명령어 실행 오류 : 나누기 0을 하는 경우
- 사용 권한 위배 : 사용자가 운영체제만 사용할 수 있는 자원에 액세스하는 경우

<br/>

### 외부 인터럽트 > 외부 인터럽트는 주로 입출력장치 에 의해 발생된다.
- 타이머 인터럽트 : 타이머가 일정한 시간 간격으로 중앙처리장치에게 인터럽트를 요청 
- 입출력 인터럽트 : 속도가 느린 입출력장치가 입출력 준비가 완료되었음을 알리기 위해 인터럽트를 요청

---

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
