# Go 언어 웹 프로그래밍
- Go는 간결하고 유연한 문법을 지원하며, 고루틴으로 병행 처리 코드를 쉽게 작성할 수 있다. 또한, 상속이 아닌 조합으로 코드를 재사용하여 확장성이 좋고, 패키지화된 소스 코드에서 실제로 사용되는 부분만 컴파일하므로 컴파일 속도가 매우 빠르다.

<br/><br/><br/><br/>

# Go 언어
- Go는 아주 실용적인 언어이다. 빠른 성능, 안정성, 편의성, 쉬운 프로그래밍을 목표로 개발되었고, 시스템 프로그래밍부터 웹 애플리케이션 개발까지 여러 분야에서 여러 용도로 사용된다.

<br/><br/>

## Go의 특징
- 간결하고 유연한 문법
- 병행 프로그래밍
- 정적 타입 언어
- 동적 프로그래밍
- 쉬운 협업
- 가비지 컬렉션 제공
- 빠른 컴파일과 실행 속도

<br/><br/><br/><br/>

## 간결하고 유연한 문법
- Go는 간결하고 명확한 문법에 중점을 두고 설계됐다. 그래서 코드가 단순해졌고 가독성이 높아졌다.

<br/>

- 프로그래밍 언어에서 간결함은 아주 중요한 요소이다. 프로그래머가 언어의 모든 기능을 충분히 숙지하고 있다면 문제가 발생했을 때 가장 효과적인 선택을 할 수 있다. 다시 말해 프로그래머는 복잡한 문제를 해결하는 것에만 집중할 수 있게 된다. 언어의 기능이 많고 복잡하면 문제를 해결하는 것보다 기능을 이해하고 익히는 것에 더 많은 시간을 할애해야 한다.

<br/>

- Go를 사용하면 기억하기 쉬운 키워드 몇몇만으로도 규모가 큰 애플리케이션을 구현할 수 있다. 밑의 그림을 보면 다른 언어에 비해 Go의 키워드 수가 얼마나 적은지 알 수 있다. Go는 키워드를 이해하고 익히는 데 많은 시간을 할애하지 않아도 된다.

![image](https://user-images.githubusercontent.com/61584142/171325869-92f1b3b0-8c9d-4a64-9491-1049f8c29946.png)

<br/>

- Go는 간결하고 유연한 타입 시스템으로 객체 지향을 표현한다. 다른 대중적인 객체 지향 언어(C++, 자바, 파이썬 등)는 클래스 안에 상태와 동작을 정의하고, 추상 데이터 타입인 클래스를 인스턴스화해서 객체로 사용한다. 이렇게 만들어진 객체는 상태와 동작을 갖는다.

<br/><br/><br/><br/>

## Go는 상태를 표현하는 '타입'과 동작을 표현하는 '메서드'를 분리해서 정의한다.
- 타입은 어떤 값을 표현하는 수단이고, 메서드는 특정 타입의 동작을 표현한다. 이렇게 각각 따로 정의된 타입과 메서드를 바인딩하여 객체를 표현한다. 이처럼 객체의 상태와 동작이 느슨하게 결합된 방식이라 더욱 자유롭게 객체 기반의 프로그래밍을 할 수 있다. Go의 내장 타입이나 다른 패키지에 정의된 타입에도 원하는 메서드를 바인딩할 수 있어서 좀 더 자연스럽게 해당 타입을 사용할 수 있다.

<br/>

- 또 한 가지 특이한 점이 있다. 전통적인 객체 지향 언어는 상속으로 코드를 재사용하는데 Go의 구조체(struct)는 상속을 할 수 없다는 점이다. 대신 구조체가 다른 구초제를 포함하는 임베디드 타입 형태로 구조체를 정의할 수 있다. 이는 클래스 간의 과도한 상속 관계로 프로그램이 복잡해지는 것을 방지한다. Go는 상속이 아니라 조합으로 코드를 재사용한다.

![image](https://user-images.githubusercontent.com/61584142/171326465-b17f0a9b-e4a4-4810-998a-26329eb3fe01.png)


<br/>

- 물론 다른 언어에서도 조합으로 타입을 정의할 수 있다. 하지만 이는 상속을 구현하는 것보다 복잡하고 어려워서 실제로 많은 개발자가 고민없이 상속을 사용한다. 앞서 말했듯이 GO의 구조체는 조합으로만 정의할 수 있다. 따라서 이를 기반으로 코드를 작성하다 보면 조합으로 문제를 해결하는 것에 자연스레 익숙해진다.

<br/><br/><br/><br/>

## 병행 프로그래밍
- 지난 30여 년간 CPU의 성능이 무어의 법칙대로 18개월마다 2배씩 빨라졌다. 하지만 어느 순간 한계에 부딪혔고, CPU를 제작하는 회사들은 CPU 여러 개를 묶어 하나의 칩으로 사용하는 식으로 발전 방향을 우회했다. 이제는 컴퓨터 하나에 CPU 여러 개를 장착해서 CPU 여러 개가 동시에 계산을 수행하게 한다. 결과적으로는 더 빠른 계산이 가능해졌다. 필연적으로 소프트웨어에도 이러한 멀티 코어 전략에 영향을 받아 병행 처리나 병렬 처리를 지원하는 것이 필수 조건이 되었다.

<br/><br/>

### 무어의 법칙
- 무어의 법칙은 반도체 집적회로의 성능이 18개월마다 2배로 증가한다는 법칙이다. 인텔의 공동 서립자인 고든 무어가 1965년에 내놓은 것으로 다음 세 가지를 이야기했다.

<br/>

1. 메모리 용량이나 CPU의 속도는 18~24개월마다 2배씩 향상된다.
2. 컴퓨팅 성능은 18개월마다 2배씩 향상된다.
3. 컴퓨팅 가격은 18개월마다 반으로 떨어진다.

<br/>

#### 인텔 프로세서의 트랜지스터 집적수 성장과 무어의 법칙

![image](https://user-images.githubusercontent.com/61584142/171329396-de907b19-6474-47f3-ac14-ee7cc4763162.png)

<br/>

- 병행 프로그래밍(Concurrent programming)은 코드를 병렬로 동작하게 하여 멀티 코어의 이점을 충분히 활용할 수 있게 해준다. 하지만 대부분의 메임스트림 언어(C, C++, 자바 등)로는 병행 프로그램을 작성하고 테스트하기가 매우 어렵다. 스레드 간에 메모리를 공유하여 동기화하는 코드는 구현하기가 어렵고, 코드를 안전하게 잘 작성했다 하더라도 스레드 자체의 부하 때문에 기대한 만큼의 성능이 나오지 않는다.

<br/>

- 대안으로는 단일 스레드 기반으로 프로그램을 만들고 이를 프로세스 여러 개로 동작시키는 멀티 프로세싱 방식도 있다. 실제로 이 방식도 많이 사용한다(주로 Node.js 애플리케이션에서 많이 사용한다). 하지만 프로세스 간의 정보 공유나 동기화 작업을 해야 할 때 또 다른 어려움이 발생한다. 프로세스 간의 통신은 멀티 스레드 환경에서 공유 메모리를 사용하는 것보다 훨씬 더 어렵다.

<br/>

- 그런 이유로 최근에 함수형 언어가 주목받고 있다. 함수형 언어에서는 한 번 정해진 값은 바뀌지 않는다. 그래서 병행 처리를 좀 더 안전하게 할 수 있다. 하지만 객체 지향 프로그래밍에 익숙해진 사고를 함수형 언어에 맞게 바꾸는 것 또한 부담된다.

<br/>

- Go 언어를 설계할 때 특별히 중점을 둔 부분이 바로 병행 처리다. Go는 병행 처리 코드를 안전하고 작성하기 쉽게 설계했다. Go의 병행 처리 방식은 통신 순차 프로세스(Communicating Sequential Processes, CSP) 방식에 근간을 둔 것으로, 메모리를 공유하는 것이 아니라 메시지를 전달하는 방식으로 동기화한다.

<br/>

#### 통신 순차 프로세스
- 1978년 영국의 컴퓨터 과학자인 토니 호아가 CACM 논문에서 처음으로 통신 순차 프로세스(Communicating Sequential Processes)를 소개했다. CSP는 동시성을 지원하는 시스템에서 상호 작용 패턴을 표현하는 언어이다. CSP에서는 동시성을 커뮤니케이션의 입출력으로 본다. 그리고 메모리 공유 방식이 아니라 동기화 방식으로 통신한다. 이후 CSP는 동시성을 지원하는 개발 언어에 지대한 영향을 끼쳤꼬 지금까지도 많은 연구가 진행되고 있다.

<br/><br/><br/><br/>

## 고루틴과 채널
- Go에서 동시에 처리해야 하는 작업은 고루틴으로 실행하고, 고루틴끼리 메시지를 주고받는 작업은 채널이라는 통로를 사용한다. 고루틴은 Go 프로그램 안에서 동시에 독립적으로 샐행되는 흐름의 단위로, 스레드와 비슷한 개념이다. 하지만 스레드와 달리 고루틴은 수 킬로바이트 정도의 아주 적은 리소스에서 동작하므로 한 프로세스에 수천, 수만 개의 고루틴을 동작시킬 수 있다. 고루틴은 정보를 공유하는 방식이 아니라 서로 메시지를 주고받는 방식으로 동작한다. 그래서 Lock으로 공유 메모리를 관리할 필요가 없고 구현도 어렵지 않다.

<br/>

![image](https://user-images.githubusercontent.com/61584142/171330169-d17fc835-2fdd-4203-a2c9-afa6500eb33f.png)

<br/><br/><br/><br/>

## 스레드와 고루틴

![image](https://user-images.githubusercontent.com/61584142/171330332-3b343e8a-4ab2-4a58-86af-d46f77a840c3.png)

<br/><br/><br/><br/>

## Static + Dynamic
- 동적 언어의 개발 속도와 정적 언어의 안정성 두 장점을 모두 수용한 것이 Go 언어이다.

<br/>

- Go는 컴파일 기반의 정적 타입 언어이다. 하지만 동적 언어의 특성도 수용함으로써 동적인 느낌으로 코드를 작성할 수 있다. 즉, 컴파일러의 보장을 받으며 동적 언어의 유연함과 자유를 만끽할 수 있다. 이를 가능하게 해주는 것이 바로 덕 타이핑(duck typing) 방식으로 동작하는 Go의 인터페이스다.

<br/>

- Go의 인터페이스를 좀 더 자세히 살펴보면, Go에서 인터페이스의 역할은 객체의 동작을 표현하는 것이다. 인터페이스가 표현하고 있는 방식대로 객체가 동작한다면, 이 객체를 인터페이스로 사용할 수 있다.

<br/>

### 덕 타이핑
- 컴퓨터 프로그래밍 분야에서 덕 타이핑은 동적 타이핑의 한 종류로, 객체의 변수나 메서드의 집합이 객체의 타입을 결정하는 것을 말한다. 덕 타이핑은 클래스 상속이나 인터페이스 구현으로 타입을 구분하느 대신, 객체가 어떤 타입에 걸맞는 변수와 메서드를 지니면 객체가 그 타입에 속하는 것으로 간주한다. '덕 타이핑'이라는 용어는 '덕 테스트'에서 유래했다.
- "만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽤걱리는 소리를 낸다면 나는 그 새를 오리라고 부를 것이다."

<br/>

- 만약 특정 타입이 어떤 인터페이스를 구현(implement)한다면, 그 타입은 인터페이스가 정의한 방식대로 동작할 수 있다는 의미이다. 그냥 그게 전부다. implements 같은 키워드로 인터페이스를 구현했는지 정의할 필요 없다. 그저 특정 인터페이스에서 정의한 메서드를 가지고 있기만 하면 된다.

<br/>

- 동작이라고 표현한 것을 기억하자. 대부분의 정적 타입 언어에서 인터페이스가 그 타입의 태생이 무엇인지를 이야기한다면, Go의 인터페이스는 특정 타입이 어떻게 동작하는지를 이야기한다.

<br/>

- Read() 메서드가 정의된 Reader 인터페이스가 있다고 해보자. 만약 A라는 타입에 Read() 메서드가 정의되어 있다면, A 타입은 Reader 인터페이스로 사용될 수 있다. A 타입과 Reader 인터페이스 코드에서 어떠한 연결 고리도 없다.

<br/>

- 자바 같은 엄격한 객체 지향 언어에서는 특정 클래스가 어떤 인터페이스를 구현하는지 명시적으로 표기해주어야 한다. 당연한 말이지만 어떤 클래스가 특정 인터페이스로 사용되려면 implements 키워드로 명시해주어야 한다. 이 말을 뒤집어 생각해 보자. implements 키워드로 특정 인터페이스를 구현한다는 표기를 해주지 않으면 인터페이스에 정의된 메서드를 구현했다하더라도 그 인터페이스로 사용할 수 있는 방법은 없다.

<br/>

### 자바와 Go의 인터페이스 비교

![image](https://user-images.githubusercontent.com/61584142/171333528-ae81412a-3fc0-4af0-9e32-5dd38f2fbe4c.png)

<br/>

- 컴파일 언어로 특정 라이브러리나 프레임워크와 호환되는 어떤 객체를 만들려면 특정 인터페이스나 클래스를 상속받아 구현하는 것이 일반적이다(물론 동적으로 인보킹시킬 수도 있지만, 이와 같은 리플렉션 방식은 여러 가지 이유로 꼭 필요한 경우가 아니라면 자제하는 것이 좋다). 그렇게 생성된 클래스는 특정 라이브러리나 프레임워크와 연결 고리가 생겨버려 확장성이 떨어지게 된다.

<br/>

- Go는 인터페이스의 이러한 특징 덕에 모듈 간의 연계가 아주 쉽다. Go의 일반적인 패턴은 전체 플로우를 제어하는 미들웨어를 만들고, 인터페이스를 기반으로 전체 플로우를 제거하게 해서 라이브러리나 패키지를 담을 수 있는 형태로 미들웨어를 만드는 것이다.

<br/>

- Go의 인터페이스는 정적 언어에다 동적 언어의 유연함과 자유를 더해주고, 컴파일러의 도움을 받으며 동적인 코딩을 할 수 있게 해준 것에는 덕 타이핑 방식으로 동작하도록 설계한 덕분인 것 같다.

<br/><br/><br/><br/>

## 쉬운 협업
- 오늘날에는 소프트웨어을 개발할 때 대부분 여러 사람이 팀을 이루어 공동으로 작업한다. 특히 오픈 소스 프로젝트는 다양한 지역에 있는 프로그래머들이 서로 다른 시간대에 온라인으로 협업하여 큰 애플리케이션을 만들어간다. 큰 프로젝트는 작은 조각으로 나뉘어 몇몇 프로그래머에게 할당되고, 각자 자신의 작업 결과를 라이브러리나 패키지 형태로 만든다. 그것들이 모여 큰 프로그램 하나를 만드는 것이다.

<br/>

- 게다가 지금의 소트으웨어는 규모가 매우 크고 복잡해서 코드의 재사용성이 더욱 강조된다. 외부 라이브러리를 찾아 나의 프로그램에 적용하는 것은 소프트웨어를 만든느 과정에서 필수 작업이다.

<br/>

- Go는 작업 공간(workspace)을 구성하는 데 가이드를 제시하여 모든 개발자가 같은 작업 환경을 구성하게 했다. 보통 작업 환경은 저마다 다르게 구성하는데, 작업 환경이 다르면 소스 디렉터리 구조나 특정 환경 변수에 따라 프로그램이 다르게 동작할 수도 있다. 이는 협업 시 불필요한 에너지를 낭비하게 한다. Go 개발자 대부분은 같은 작업 환경에서 작업하므로 협업을 해도 외부 패키지 소스를 나의 로컬 환경에 설치하여 작업하기가 쉽다.

<br/>

- 협업할 때 중요한 또 하나는 코드의 스타일을 일관성 있게 맞추는 것이다. 개발자 커뮤니티에서는 괄호나 들여쓰기 같은 코드 서식 지정(formatting)에 관한 논쟁이 종종 일어난다. Go는 코드 스타일을 자동으로 맞춰주는 gofmt 도구를 제공함으로써 이 논쟁을 해결했다. gofmt 도구를 사용하면 코드를 보기 좋게 수직으로 정렬해주고 들여쓰기나 주석도 같은 서식을 지정해서 맞춰준다.

<br/>

- Go는 코드를 쉽게 공유할 수 있는 언어이다. Go에서 제공하는 툴을 사용하면 내가 만든 코드를 다른 사람이 사용할 수 있게 패키징하기 쉽고, 원격 저장소에 있는 소스를 내려받아 사용하는 것도 쉽다. Go에는 외부 패키지를 저장하고 관리해주는 중앙 저장소가 없다. 소스가 저장된 원격 저장소의 URL이 곧 패키지 이름이다. go get 명령을 사용하면 깃허브(GitHube), 비트버킷(BitBucket) 등의 원격 소스 저장소에서 패키지 소스를 가져와 로컬 환경에 설치할 수 있고 의존성 관리까지 해준다.

<br/>

자바 - maven <br/>Node.js - npm<br/>파이썬 - pip<br/>루비 - gem

<br/>

- 자바나 C++ 같은 전통적인 객체 지향 언어에서는 보통 인터페이스와 추상 클래스(abstract class)를 기반으로 프레임워크를 구성하고, 구성한 프레임워크를 기반으로 세부 기능을 만들어간다. 인터페이스와 추상 클래스의 구조는 소프트웨어 전체의 동작 방식을 결정하므로 초기 프레임워크를 구성하는 작업은 아주 중요하다. 그리고 이렇게 한 번 구성된 프레임워크는 변경하기가 아주 까다롭다.

<br/>

- Go는 사용자 정의 타입을 먼저 만들어 놓고 인터페이스는 나중에 추가할 수도 있고, 다른 패키지 타입에 메서드를 추가로 정의할 수도 있다. 이는 초기 프레임워크 설계에 대한 부담을 줄여주고, 지속적인 리팩토링을 통해 실용적인 방식으로 개발하게 해준다.

<br/><br/><br/><br/>

## 가비지 컬렉션
- C나 C++ 같은 언어는 가비지 컬렉션을 제공하지 않아서 개발자가 직접 메모리를 관리해야 한다. 메모리를 할당하고 해제하는 작업은 까다롭고 디버깅도 어려워서 로직을 작성하는 것보다 더 많은 시간을 할애하기도 한다. 이에 반해 Go 언어는 가비지 컬렉션을 제공하므로 메모리 관리에 신경쓰지 않고 문제 해겨에만 집중할 수 있다.

<br/><br/><br/><br/>

## 빠른 컴파일과 실행 속도
- 2003년 켄트벡이 TDD(Test-Driven-Development, 테스트 주도 개발)를 주장한 이후 TDD의 중요성은 계속 강조되고 있다. TDD는 '테스트 코드 작성(red) -> 코드 완성으로 테스트 성공(green) -> 리팩토링(refactor)' 사이클로 개발하게 한다. TDD는 코드가 수정될 때마다 수정된 코드를 컴파일하고 실행하는 것을 전제로 한다. 하지만 프로그램의 규모가 커지고 테스트 단계가 많아질수록 red-green-refactor 사이클은 점점 느려진다. C++나 자바 같은 컴파일 기반의 언어는 컴파일 과정이 전체 사이클을 느리게 하고, 컴파일이 필요 없는 파이썬이나 루비 같은 인터프리터 언어는 실행 과정이 느리다.

<br/>

![image](https://user-images.githubusercontent.com/61584142/171336608-40625281-e43f-4e5e-b5c2-c8a19a6cee36.png)

<br/>

- Go는 패키지화된 소스 코드에서 실제로 사용되는 부분만 컴파일하므로 컴파일 속도가 빠르다. 패키지1이 패키지2를 참조하고 있고 패키지2가 패키지3을 참조하고 있을 때 main 패키지에서 패키지1을 임포트하면 컴파일 언어는 보통 패키지1, 패키지2, 패키지3 모두 컴파일한다. 하지만 Go는 main 패키지에서 패키지2나 패키지3의 코드를 사용하지 않는다면 패키지1만 컴파일한다. 이렇게 최적화된 컴파일 방식이라 아무리 규모가 큰 프로젝트라도 대부분 수 초 이내에 컴파일이 완료된다. Go의 문법을 간결하게 설계한 것도 이처럼 빠른 컴파일 속도를 유지하기 위해서다.

<br/>

- Go는 빠른 성능을 목표로 개발됐다. 개발 초기에는 빠른 실행 속도에 초점을 두었다. 여러 자료에서 Go의 실행 속도는 C나 C++와 유사한 성능을 보인다. Go는 컴파일과 실행 속도가 빨라서 개발 사이클을 빠르게 유지할 수 있다. Go의 빠른 컴파일과 실행 속도 덕에 스크립팅 언어가 사용되는 곳에서 Go를 사용하기도 한다.

---

<br/><br/><br/><br/><br/><br/><br/><br/>

# Go 개발 환경
### 1. GOPATH 지정
- Go 작업 파일(소스 코드, 실행 파일, 패키지 파일 등)이 위치할 경로를 GOPATH로 지정한다.

<br/>

### 2. 기본 디렉터리 구성
- GOPATH 하위 경로에 다음 디렉터리를 세 개를 생성한다.
    - src : Go 소스 파일
    - pkg : 패키지 파일(확장자는 .A)
    - bin : 실행 파일

<br/>

### 3. PATH 등록
- 어디서든 Go 실행 파일을 실행할 수 있게 GOPATH의 bin 경로를 환경 변수 PATH에 등록 한다.

<br/><br/><br/><br/>

## 작업 공간의 전체 디렉터리 구조 예

![image](https://user-images.githubusercontent.com/61584142/171337231-26518d1a-0248-4903-8637-a50873a031d4.png)

<br/><br/><br/><br/>

## Go 프로그램의 두 가지 타입
1. 실행 가능한 프로그램: 명령 프롬프트에서 명령을 내려 실행할 수 있는 프로그램
2. 라이브러리: 다른 프로그램에서 호출하여 사용할 수 있게 만든 코드의 묶음

---

<br/><br/><br/><br/><br/><br/><br/><br/>

# Go 문법의 특징
- 변수와 상수
- 프로그램의 기본 흐름 제어(if, switch, for)
- 함수
- 패키지

<pre><code>// ➊ 패키지 선언
package main
  
// ➋ 외부 패키지 임포트
import "fmt"
  
// ➌ main 함수
func main() {
  
    // ➍ 외부 패키지 사용
    fmt.Println("Hello World!")
}</code></pre>

<br/><br/><br/><br/>

## 간결함과 유연함
- Go는 문법 요소는 줄이고 유연함을 높였다. 그래서 적은 문법으로 풍부한 기능을 구현할 수 있다. Go에는 while문이 없어서 for문으로만 반복을 표현한다. 또한, 복잡한 if문 대신 switch문 case에 조건식을 넣어 간결하게 표현한다.




